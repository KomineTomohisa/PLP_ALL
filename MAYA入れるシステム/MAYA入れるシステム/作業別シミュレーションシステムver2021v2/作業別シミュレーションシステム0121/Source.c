#include <stdio.h>
#include <stdlib.h> 
#include <string.h>
#include<ctype.h>
#include <math.h>
#include<conio.h>

//プロトタイプ宣言-----------------------------------------------------------
void ShowFinMsg(char*);
void Del_Com(char*);
void GetNowPath(char*, char*);
void ReadHeader();
void ReadJyunjyo(FILE*);
void WriteHeader(FILE*);
void ReadKumitateichi();
void ReadKumitsuke();
void ReadBuhin();
void MakingS0();
void KP4MaikingOffset(int);//工具パターン4,5の時のを入れる位置を考える
void MaikingOffset(int, double*, double*, double*);
void FileCopy(FILE*);
void Reset();//二回目に回す際にリセットすべき数値をリセットする(ヘッダー部分にステップ数を入れるため)

void Make_VFDL();
void Read_movement();
void Make_kumitatemae(int);
void Make_kumitatego(int);
void Make_karioki(int);
void Make_finish(int);

int Move_decision(int, int);
//void Make_oyabuhin_coord(int);
//void Make_oyabuhin_move(FILE *, int);
//void Make_kobuhin_coord(int);
//void Make_kobuhin_move(FILE *, int);
void start_to_kumitatemae(FILE*, int, int);
void kumitatemae_to_kumitatego(FILE*, int, int);
void kumitatego_to_kumitatemae(FILE*, int, int);
void kumitatego_to_karioki(FILE*, int, int);
void karioki_to_kumitatemae(FILE*, int, int);
void kumitatego_to_finish(FILE*, int, int);
void Make_Joutai(int, int);
//void Make_karioki_coord(int);
//void Make_karioki_move(FILE *, int);
//void Make_hozi_move(FILE *, int);
//void Make_motinaosu_move(FILE *, int);
//void Make_kanseioki_coord(int);
void Make_kanseioki_move(FILE*, int);
//void Make_kumitatejunbi_move(FILE *, int);
void Make_pre_assembly(FILE*, int*, int);
void Make_Joutai(int, int);
void DirDecision(double, double, double);
void rotation_matrix_Coord(double, double, double);

void Kumimove(FILE*, double, double, double, double, double, double, int);//組立移動
void Kumitate(FILE*, int, int, int, int, int);//組立
void Remove(FILE*, int, int, int);//治具から外す
void Turn(FILE*, int, double, double, double, double, double, double, int);//回転する(持ち直す)
void Fix(FILE*, int, int, int);//治具に付ける
void Release(FILE*, int, int);//放す
void Reach(FILE*, double, double, double, double, double, double, int);//伸ばす
void Grip(FILE*, int, int, int);//掴み取る
void Carry(FILE*, double, double, double, double, double, double, int);//運ぶ
void leave(FILE*, int, int);//置き放す
void Gripping(FILE*, int, int);//掴む
void Tipmove(FILE*, int, int, int);//先端移動
void KouguKumi(FILE*, int, int, int, int, int);//工具を用いる場合の組立

void WReach(FILE*, double, double, double, double, double, double, double, double, double, double, double, double);//両手同時に伸ばす(左、右)
void WGrip(FILE*, int, int, int, int);//両手で掴み取る(左、右)
void WCarry(FILE*, double, double, double, double, double, double, double, double, double, double, double, double);//両手同時に運ぶ(左、右)
void WTurn(FILE*, int, double, double, double, double, double, double, int, double, double, double, double, double, double);//両手回転させる(左、右)
void WRelease(FILE*, int, int);//両手同時に放す(左、右)
void WKumimove(FILE*, double, double, double, double, double, double, double, double, double, double, double, double);//両手で組立て移動
void WFix(FILE*, int, int, int, int);//両手で付ける
void WGripping(FILE*, int, int);//両手で掴む(左、右)
void Wleave(FILE*, int, int);//両手同時に置き放す(左、右)
void WRemove(FILE*, int, int, int, int);//治具から外す

//定数の宣言 --------------------------------------------------

#define STR_MAX 1000
#define DEF_PAR_FNAME "システムパラメータ.txt" 
#define FGETS_MAX_LENGTH 20000
#define MaxN 8000 //取り扱う最大の部品数を8000とする
#define MaxMM 1000000 //取り扱う最大の中間製品を1,000,000とする
#define MaxDN 300 //CSVファイル一行に記入される最大の文字数(部品数は64部品なので300用意する)
#define MaxSupport 1000
#define Oya 1
#define Ko 2
#define Tyukan 3
#define KOUGU 4
#define JIG 5
#define Start_P 6//初期位置
#define Kumitsuke 0
#define PI acos(-1)
#define Oya1 7
#define Ko1 8
#define Tyukan1 9
#define Oya2 10
#define Ko2 11
#define Tyukan2 12
#define Original_P 13//先端変更の時の元の位置
#define ChangeKOUGU 14

#define move 0
#define addition1 0
#define addition2 1
#define addition3 2
#define target 1//作業を行う対象
#define destination 2//対象を運ぶ目的地


#define hidarite 1	
#define migite 0
#define ryoute 2

//状態の番号
#define kumitatemae 1
#define kumitatego 2
#define karioki 0
#define hukusujig 3//複数治具で仮置きしない時

#define kumimae_to_kumigo 1
#define kumigo_to_karioki 2
#define kumigo_to_kumimae 3
#define karioki_to_kumimae 4
#define saisyo_to_kumimae 5
#define kumigo_to_saigo 6
#define kumigo_to_karioki2 7//できた中間製品が次の組立で子部品になる時

//両手の番号は0以上、片手、工具の番号は0未満
#define katate_migi -1
#define tegumi 3
#define youenjo 4
#define oomono_ko 5//子部品が重い
#define oomono_oya 6//親部品が重い
#define oomono_oyako 7//親部品と子部品両方重い
#define oya2ko1 1
#define oya1ko2 2
#define oya2ko2 0
#define kougu2 -2
#define kougu1 -3
#define kougu3 -4


//動作が0は何も動作を行わない
#define none 0
#define nobasu 1
#define tsukamitoru 2
#define hakobu 3
#define motinaosu 4
#define tsukeru 5
#define hanasu 6
#define kumitateidou 7
#define kumitateru 8
#define tsukamu 9
#define hazusu 10
#define okihanasu 11
#define nobasu_tsuika 12//基本の動作に追加した伸ばす
#define hakobu_tsuika 13//基本の動作に追加した運ぶ
#define motinaosu_tsuika 14//基本の動作に追加した持ち直す
#define nobasu_kougu 15
#define tsukamu_kougu 16
#define hakobu_kougu 17
#define sentanhenkou 18

//動作のパターンの番号
#define saisyo_and_karioki_to_kumimae_migi 1//片手(右手で組立てる)
#define kumigo_to_saigo_migi 2
#define kumigo_migi_to_karioki_hukusujig_migi 3
#define kumimae_to_kumigo_migi 4
#define kumigo_to_kumimae_migi 5
#define kumigo_to_karioki_migi 6

#define saisyo_and_karioki_to_kumimae_tegumi 7//手組みの動作
#define kumigo_to_saigo_tegumi 8
#define kumigo_to_kumimae_tegumi 9
#define kumigo_to_karioki_tegumi 10
#define kumigo_tegumi_to_kumimae_migi_oya 11//組立後の状態(手組み)→組立前の状態(右手)親部品が手組みでできた部品の時
#define kumigo_tegumi_to_kumimae_migi_ko 12//組立後の状態(手組み)→組立前の状態(右手)子部品が手組みでできた部品の時
#define kumigo_migi_to_kumimae_tegumi 13//組立後の状態(右手)→組立前の状態(手組み)

#define saisyo_and_karioki_to_kumimae_oomono_ko 14//大物組付けの動作(子部品が大物)
#define kumigo_to_saigo_oomono 15
#define kumimae_to_kumigo_oomono 16
#define kumigo_migi_to_kumimae_oomono_ko 17
#define kumigo_tegumi_to_kumimae_oomono_ko 18
#define kumigo_to_karioki_oomono 19

#define saisyo_and_karioki_to_kumimae_oomono_oya 20//大物組付けの動作(子部品が大物)
#define kumigo_to_kumimae_oomono_oya 21

#define saisyo_and_karioki_to_kumimae_oomono_oyako 22//大物組付けの動作(子部品、親部品の両方が大物)
#define kumigo_to_kumimae_oomono_oyako 23

#define saisyo_and_karioki_to_kumimae_youenjo 24//大物組付けの動作、仮置きの動作は片手(右手で組立てる)と共通、組立前から組立後は大物と共通
#define kumigo_migite_to_kumimae_youenjo 25
#define kumigo_tegumi_to_kumimae_youenjo_oya 26//組立後の状態(手組み)→組立前の状態(要援助)親部品が手組みでできた部品の時
#define kumigo_tegumi_to_kumimae_youenjo_ko 27//組立後の状態(手組み)→組立前の状態(要援助)子部品が手組みでできた部品の時
#define kumigo_oomono_to_kumimae_youenjo 28

#define saisyo_and_karioki_to_kumimae_oya1ko2 29
#define kumimae_to_kumigo_ryoute2 30
#define kumigo_migi_to_kumimae_oya1ko2 31
#define kumigo_tegumi_to_kumimae_oya1ko2_ko_migi 32//組立後の状態(手組み)→組立前の状態(親1子2)右手側の子部品が手組みでできた部品の時
#define kumigo_tegumi_to_kumimae_oya1ko2_ko_hidari 33//組立後の状態(手組み)→組立前の状態(親1子2)左手側の子部品が手組みでできた部品の時
#define kumigo_tegumi_to_kumimae_oya1ko2_oya 34//組立後の状態(手組み)→組立前の状態(親1子2)親部品が手組みでできた部品の時
#define kumigo_oomono_to_kumimae_oya1ko2 35

#define saisyo_and_karioki_to_kumimae_oya2ko1 36
#define kumimae_to_kumigo_oya2ko1 37
#define kumigo_to_kumimae_oya2ko1_hidari 38
#define kumigo_to_kumimae_oya2ko1_migi 39
#define kumigo_to_kumimae_oya2ko1_attached 40
#define kumigo_tegumi_to_kumimae_oya2ko1_migi 41
#define kumigo_tegumi_to_kumimae_oya2ko1_hidari 42

#define saisyo_and_karioki_to_kumimae_oya2ko2 43
#define kumigo_oya2ko2_to_kumimae_oya2ko2_attached 44
#define kumigo_oya2ko2_to_kumimae_oya2ko1 45
#define kumigo_to_kumimae_oya2ko2_hidari 46
#define kumigo_to_kumimae_oya2ko2_migi 47
#define kumigo_oya2ko2_to_karioki_all 48
#define kumigo_oya2ko2_to_karioki_migi 49
#define kumigo_oya2ko2_to_karioki_hidari 50
#define kumigo_oya2ko2_to_karioki_hukusujig 51

#define saisyo_and_karioki_to_kumimae_kougu2 52
#define kumigo_to_saigo_kougu 53
#define kumigo_kougu_to_karioki_samekougu 54
#define kumigo_kougu_to_karioki_kariokikougu 55
#define karioki_to_kumimae_samekougu2 56
#define kumigo_kougu_to_kumimae_samekougu2 57
#define kumigo_kougu_to_kumimae_changekougu2 58
#define kumigo_kougu_to_kumimae_migi 59
#define kumigo_kougu_to_kumimae_tegumi 60
#define kumigo_migi_to_kumimae_kougu2 61
#define kumigo_tegumi_to_kumimae_kougu2_oya 62
#define kumigo_oomono_to_kumimae_kougu2 63
#define kumigo_kougu_to_kumimae_oomono_oya 64
#define kumigo_kougu_to_kumimae_oomono_ko 65
#define kumigo_kougu_to_kumimae_oomono_oyako 66
#define kumigo_kougu_to_kumimae_youenjo 67
#define kumigo_kougu_to_kumimae_oya1ko2 68

#define kumigo_kougu_to_karioki_hukusujig 69
#define kumigo_tegumi_to_kumimae_oya2ko2_tegumi_hidari 70
#define kumigo_tegumi_to_kumimae_oya2ko2_tegumi_migi 71

#define kumigo_oya2ko2_to_saigo 72
#define kumigo_kougu_to_kumimae_tegumi 73

#define kumigo_tegumi_to_kumimae_kougu2_ko 74

#define saisyo_and_karioki_to_kumimae_kougu1 75
#define karioki_to_kumimae_samekougu1 76
#define kumigo_kougu_to_kumimae_samekougu1 77
#define kumigo_kougu_to_kumimae_changekougu1 78
#define kumigo_migi_to_kumimae_kougu1 79
#define kumigo_tegumi_to_kumimae_kougu1_oya 80
#define kumigo_oomono_to_kumimae_kougu1 81
#define kumigo_tegumi_to_kumimae_migi_ko_jigukotei 82
#define saisyo_and_karioki_to_kumimae_kougu3 83
#define kumigo_tegumi_to_kumimae_kougu1_ko_oyajigu 84
#define kumigo_tegumi_to_kumimae_kougu2_ko_oyajigu 85

//構造体の宣言 --------------------------------------------------


//右手が1、左手が2
struct Hands {
	int Hnum;
	double IchiX;//位置Ｘ
	double IchiY;
	double IchiZ;
	int DirX;//方向Ｘ
	int DirY;
	int DirZ;
} A_Hands[MaxN + 1];


struct Kougus {
	int Bnum;//識別番号
	double IchiX;//位置Ｘ
	double IchiY;
	double IchiZ;
	int DirX;//方向Ｘ
	int DirY;
	int DirZ;
} A_Kougus[MaxN + 1];

struct Parts {
	int Bnum;//識別番号
	double IchiX;//位置Ｘ
	double IchiY;
	double IchiZ;
	int DirX;//方向Ｘ
	int DirY;
	int DirZ;

} A_Parts[MaxN + 1];

struct Jigus {
	int Jnum;//識別番号
	double IchiX;//位置Ｘ
	double IchiY;
	double IchiZ;
	double H_IchiX;//位置Ｘ
	double H_IchiY;
	double H_IchiZ;
	int DirX;//方向Ｘ
	int DirY;
	int DirZ;
	double SizeX;//大きさＸ
	double SizeY;
	double SizeZ;
	int Iro;//色番号
	int SyokiS;//初期状態(0:非表示,1:表示)
} A_Jigus[MaxN + 1];

struct Desks {
	int Dnum;//識別番号
	double SizeX1;//大きさＸ1(位置の座標からの左側の大きさ)
	double SizeX2;//大きさＸ2(位置の座標からの右側の大きさ)
	double SizeY;
	double SizeZ;
	int Iro;//色番号
	double IchiX;//位置Ｘ
	double IchiY;
	double IchiZ;
	int Dir;//角度
} A_Desks[MaxN + 1];


struct Bboxs {
	int Bnum;//識別番号
	int Oyako;//親子関係
	int Type;//タイプ
	int Iro;//色番号
	double SizeX;//大きさＸ
	double SizeY;
	double SizeZ;
	double Atusa;//部品箱の厚さ
	double IchiX;//位置Ｘ
	double IchiY;
	double IchiZ;
	int DirX;//方向Ｘ
	int DirY;
	int DirZ;
} A_Bboxs[MaxN + 1];


struct Objects {
	int Id;//オブジェクト番号
	int Flag;//1ならばその状態の時に存在する部品
	double IchiX;//位置Ｘ
	double IchiY;
	double IchiZ;
	int DirX;//方向Ｘ
	int DirY;
	int DirZ;
} A_Objects[2][MaxN + 1];


struct Supports {
	int Id;//支えの関係を作るもの(手や机や部品箱など)の番号
	int Flag;//1ならばその状態の時に存在する部品
	int PId[MaxSupport];//支えられているもののＩｄ
	int Length;//支えているものの数
} A_Supports[2][MaxN + 1];

struct Kumitateichi {
	int num;//接触線番号
	int Kparts;//固定部品
	int Iparts;//移動部品
	char KumitukeDir[3];//組付け方向
	double ASP_X;//ASP
	double ASP_Y;
	double ASP_Z;
	double APP_X;//APP
	double APP_Y;
	double APP_Z;
	double Offset_X;//Offset
	double Offset_Y;
	double Offset_Z;
}A_Kumitateichi[MaxN + 1];

struct Buhin {//部品属性の読み取り
	int Buhinnum;//部品番号
	double Tyusin_X;//組付くときの中心座標
	double Tyusin_Y;
	double Tyusin_Z;
	double Lengrh_X;//部品の長さ
	double Lengrh_Y;
	double Lengrh_Z;
	double X_max;//各軸に置いての最大値・最小値
	double X_min;
	double Y_max;
	double Y_min;
	double Z_max;
	double Z_min;
	int Kougu;//工具番号を入力(用いない場合は0)
	int KouguType;//工具のタイプ(保持できる工具:1,保持出来ない工具:2)
	int Okikata;//置き方を入力(ランダム:2，整列:1)
	int Atsukai;//取り扱い(1:無し,2:有)
}A_Buhin[MaxN];

struct Okishitei {//置き放しの指定する位置・部品の情報
	int Okiba_No;//仮置き場の番号
	int Bnum;//対象の部品
	double IchiX;//その位置
	double IchiY;
	double IchiZ;

}A_Okishitei[MaxN];

struct KOkishitei {//親子逆になる場合の置き放しの指定する位置の情報
	int Okiba_No;//仮置き場の番号
	int Bnum;//対象の部品
	double IchiX;//その位置
	double IchiY;
	double IchiZ;

}A_KOkishitei[MaxN];

struct TyukanTyusin {//中間製品の中心点になる部品を記録します(一番最初の親部品が中間製品の中心点になる部品)
	int TyukanNum;//中間製品番号
	int Tyusin;//中心点になる部品番号
}A_Tyukantyusin[MaxN];


struct kumijun//組立順序一行ずつを入れておく構造体
{
	int kuminum;//組付け番号
	int oya;//親部品
	int ko;//子部品
	int tyukan;//できる中間製品
	char dir[5];//組付ける方向
	int jig;//治具番号
	//int base;//ベース部品
	int scene_type;//組立の際にどの組立動作のパターンを用いるか
	int kougu;//使用する工具番号
	int XLineDir;
	int YLineDir;
	int ZLineDir;
}kumijun[MaxN - 1];

struct kumihead//組立順序の組立順序番号などが書いてある行を入れておく構造体
{
	char K[2];//最初のK
	int KJnum;//組立順序番号
	int flag;//存在フラグ
	int x;
}kumihead;

struct move_pattern
{
	int num;
	//int jig_flag;//治具に部品をつけるかつけないか
	//int both_hands;//両手作業かどうか
	//int renzoku_flag;//連続して複数の部品を取る場合に1、それ以外は0
	//int oya_length;//親部品の動作の数
	//int ko_length;//子部品の動作の数
	//int karioki_length;//仮置きの動作の数
	//int hoji_length;//保持の動作の数
	//int junbi_length;//仮置きと保持をしない場合の中間製品に関する動作
	//int motinaosu_length;//持ち直すの動作の数
	//int Right_length;//右手の動作の数
	//int Left_length;//左手の動作の数

	int length[2];//length[a] aが0には右手の動作数、１には左手の動作数

	//int renzoku_flag[50];//連続する動作に印をつける
	//int renzoku_length[25];//連続した動作の数
	//int Right_hand[50][2];//Right_hand[a][b]　aは何番目の動作パターンか　bの0には動作 1には対象物を入力
	//double Right_hand_addition[50][3];//追加した動作を行う座標
	//int Left_hand[50][2];//left_hand[a][b]　aは何番目の動作パターンか　bの0には動作 1には対象物を入力
	//double Left_hand_addition[50][3];//追加した動作を行う座標
	//double kobuhin[50][7];//kobuhin[a][b][c] aは何番目の動作パターンか　bの0には動作　1には使用する手を入れる(0:右手,1左手,2両手)　2から4には追加した動作を行う座標もしくは角度　5には使用する工具を入力　6には対象物を入力
	//double karioki[50][7];	double hoji[50][7];
	//double moti[50][7];
	//double junbi[50][7];
	int Move[2][50][3];//move[a][b][c]　aは0に右手の動作,1に左手の動作,bは何番目の動作パターンか　cの0には動作 1には対象物を入力 2には目的のモノを入力
	double Move_addition[2][50][3];//追加した動作を行う座標,角度
}M_pattern[MaxN - 1];

struct pre_parts
{
	//int pre_tyukan;
	//int kijun_buhin;
	//int kumitsuke_length;//組付けの個数
	//int tantai_num;//単体部品の個数
	int kumitsuke[MaxN - 1][3];/*組付けの部品1が0、部品2が1、組立部品が2に入る*/
	int tantai_buhin[MaxN];
}pre_parts;

struct jig_parts//治具についている部品の中心点を保存する構造体
{
	int num;//治具についている部品の部品番号
	int jignum;
	int Id;
	double IchiX;
	double IchiY;
	double IchiZ;
}jig_parts[MaxN / 2];



//グローバル変数の宣言 --------------------------------------------------
char SEIHIN_Name[STR_MAX], inPath_Header[STR_MAX], inPath_Jyunjyo[STR_MAX], outPath_VFDL[STR_MAX], inPath_Kumitsuke[STR_MAX], inPath_Kumitateichi[STR_MAX], inPath_Buhin[STR_MAX], inPath_VFDL_KARI[STR_MAX], outPath_VFDL_KARI[STR_MAX], outPath_Hyouka[STR_MAX], inPath_input[STR_MAX];
int Worknum, Linenum, Kounum, Step, YStep, Soku, Kcheck, Scene;//Worknum:作業者番号, Linenum:ライン番号, Kounum:工程番号, Step:ステップ数, YStep:有効ステップ数, Soku:速度指定, Kcheck:干渉チェック, Scene:状態情報
int N, Kougu, Jigu, Tukunum, Bboxnum, Tupointnum, Okihanashinum = 0, KOkihanashinum = 0;//N:部品数, Kougu:工具数, Jigu:治具数, Tukunum:机の数, Bboxnum:部品箱数, Tupointnum:通過点数,Okihanashinum:置き放し指定回数,KOkihanashinum:親子逆の場合の位置指定回数
int TN, Tnumber, Tflg, STN, STnum, STflg;//TN:中間部品数, Tnumber:中間部品番号, Tflg:中間部品存在フラグ(予測), STN:生成中間部品数, STnum生成中間部品番号, STflg:生成中間部品存在フラグ(予測)
//int Jyunjyo[MaxN - 1][5];//組立順序の配列(4は工具パターンを入力)
int putting = 0, Sessyokusen, SType;//putting:置き放し回数,Sessyokusen:接触線数,SType:状態タイプ(0:組立前,1:組立後,2:仮置き)
int Kumi[FGETS_MAX_LENGTH][FGETS_MAX_LENGTH];//組付け
int a = 0/*, Kumitatenum = 0*/;//a:main関数を回すための数,b:Objects[b][i]のための,Kumitatenum:現在の組み立て回数,d:bではない数
int KumiN, Tnum = 0;//組付け番号数,中間製品が何個目か
int OyaPnum, KoPnum;//親部品、子部品がObjectで何行目にあるか
int SOyaPnum, SKoPnum;//親部品、子部品がSuportで何行目にあるか
int Num = 1, ZNum = 1, HighNum = 0, Flg = 1,/* Skakudo = 0,*/ TurnNum = 0;//Num:変化の連番, ZNum:後続命令数, HighNum:ハイライト部品数, Flg:フラグ, Skakudo:総回転角度, TurnNum:総回転数
double Skakudo = 0;
int Kaitenkaisu = 0;
int HNum = 0;//有効ステップ数+無効ステップ数
int IdoF;//移動があるかないか
double Time = 0.5, SKyori = 0, STime = 0, Kyori, MKyori = 0, HKyori = 0;//Time:時間値, SKyori:総移動距離, STime:累計時間値,Kyori:両手の総移動距離,MKyori:右手の総移動距離,HKyori:左手の総移動距離
//double KIdo;//組立移動の時に用いる子部品の移動先
double KIdo_X, KIdo_Y, KIdo_Z;
int e = 0;//治具についてる親部品の番号(Offset導出に用いる),使う中間製品の数
double B_bigX = 0, B_bigY = 0, B_sitaZ = 0;
//int KouguFlag;//工具のフラグ(0：工具は前後で用いてない、1：ひとつ前では工具を用いず、次の組付けでは工具を用いる、2：一つ前では用いて、次は用いないとき、3：前で用いた工具をそのまま用いるとき、4：工具は前後で用いるが、使う工具が違うとき)
//int KBnum, Kougunum;//子部品が部品属性の何番目に書かれているか、工具の構造体の何番目に入っているかを記憶している
int KBnum0, Kougunum0;//ひとつ前の子部品が部品属性の何番目に書かれているか、工具の構造体の何番目に入っているかを記憶している
int Jyunjyonum[2], loop = 0, RoopN = 0;//今何番目の順序を読み込んでいるか,ループを抜け出すかフラグ,何回ループしたか
char Jyunjyonumbar[3] = { '\0' };
//int KouguPnum[MaxN][3];//KoubuPnum[][0]:工具のパターンは何番か(1:従来2:左手で一つずつ3:左手でたくさん4:片手自立5:両手自立0:工具無し)、KouguPnum[][1]:連続で何本組み付けるか、KouguPnum[][2]:何番の工具を使うか
int KouguPN;//工具パターンが何個あるか
int KPRenzoku = 0;//工具の連続を記録、現在何本目かを残数で明記
int Rcount;//KouguPnum[MaxN][3]が何番目かをカウントする
double KKIdo_X, KKIdo_Y, KKIdo_Z;

int N0 = 0;//仮の部品数

int gyousu = 0, dousasu = 0;//gyousuu:組立順序の行数　dousasu:読み込んだ動作データベースの動作の数
char movement[STR_MAX];
//int Sessyokunum;//用いる接触線の番号
//int kaitenflag = 0;
int hold_hands = -1;//部品を掴んている手
int TyuPnum = 0;//中間製品がobjectsでどこにあるか
int hoziflag = 0, boxflag = 0;//子部品をすでに保持しているかどうかのフラグ,箱が指定されているかどうかのフラグ１ならば指定されていない
int Total_Box = 0;//組立に用いない部品も含めた部品箱の数
int pre_count = 0, pre_assemble[MaxN], tantaibuhinsu = 0, PreStep = 0;//予め組立てておかなければならない中間製品の数,予め組立てておく中間製品番号、組立順序に出てくる単体部品の数,事前に中間製品を用意するためのステップ数
int not_use[MaxN / 2], not_use_count = 0, not_use_flag = 0;//組立てた後に使用しない中間製品番号、組立てた後に使用しない中間製品の数
int MaxPL;//最大の中間製品番号
int First_Time = 0;
int oya_hoji = 0;//親部品を保持しているもの
double KIdo_X1, KIdo_Y1, KIdo_Z1;//組立移動の開始位置
int OyaPnum1, KoPnum1, TyuPnum1 = 0;//親部品、子部品がObjectで何行目にある
int R_OyaPnum, R_KoPnum, R_TyuPnum = 0;//親部品、子部品がObjectで何行目にある
int L_OyaPnum, L_KoPnum, L_TyuPnum = 0;//親部品、子部品がObjectで何行目にある
int KobuhinzahyouPnum = 0;//KobuhinzahyouPnum：親部品が二つの時に子部品を運ぶ位置の方の子部品がObjectでどこにあるか
int JigPartssu = 0;//治具についている部品の数
int Oya2flag = 0;//親部品が2つの時にどちらの親部品を基準にするかのフラグ 親部品が1つで組立順序2行の1行目が基準の時は1、2行目の時は2、両方ともすでに治具についている時は3
int Oya2Jigflag = 0;//0の時は親部品2部品とも新たに治具に付けるとき、1の時は最初の部品、2の時は2番目の部品、3の時はすでに2部品ともに治具についている時
double Oya2hoseiX = 0, Oya2hoseiY = 0, Oya2hoseiZ = 0;//親部品が2つあり、親部品が2つとも同じ治具の時に補正するための変数
//int Jigparts1 = 0, Jigparts2 = 0;//親部品が2つの時に治具についている部品Jigparts1は組立順序一行目の部品が治具についているとその部品番号が入る、Jigparts2は組立順序2行目の部品が治具についているとその部品番号が入る
//int KouguPnum = 0, Kougunum = 0;//KouguPnum：objectで使用する工具がどこにあるか、Kougunum：工具番号
int Kouguflag = 0;//工具を用いているかどうかのフラグ、0の時は用いていない、用いているときは組立順序に記述した工具の番号が記述されている
int kariokiflag = 1;
int NewNOS0 = 1;//1ならば新しいNOS0
//ワールド座標系における組立後位置,修正後の組立位置
double Re_X, Re_Y, Re_Z;
int ChangeJig = 0, ChangeJig2 = 0;//使用する治具を変える時の親部品の部品番号
int JigKobuhin = 0, JigKobuhin2 = 0;//子部品が治具についているの子部品の部品番号
int hyoukamode = 0;
int Oyakaiten = 0;
double Oyakaitenkakudo = 0;

int maxkumijun = 0;
int Filename = 0;
FILE* kari;
FILE* hyouka;

int main(int argc, char* argv[]) {



	FILE* fp1;
	FILE* fp3;
	FILE* fp4;
	FILE* fp5;
	FILE* fp6;
	FILE* fp7;


	char NowPath[STR_MAX]; //最終的にパラメータファイルのフルパスを入れる
	char WkD[STR_MAX];
	//char temp[FGETS_MAX_LENGTH];


	//このプログラムのあるパスを取得して、NowPathに入れる
	GetNowPath(NowPath, argv[0]);
	strcat(NowPath, "Input\\");	//パラメータファイルの置き場は.exeがあるフォルダ下のInputとする
	sprintf(movement, "%s変化のパターンリスト.csv", NowPath);
	strcat(NowPath, DEF_PAR_FNAME); //NowPath に パラメータファイル名を結合して、フルパスにする
	printf("%\n", NowPath);
	/************************************************************************************************/
	/*パスワードの認証*/
	/************************************************************************************************/
	//if (PWCheck(argc, argv[1]) == 0) return 0; //パスワードが一致しなかったら0が返ってくる → プログラムの終了 (= return 0)



	fp1 = fopen(NowPath, "r");
	if (fp1 == NULL) ShowFinMsg("パラメータファイルがありません"); // ファイルを開けなければ終了
	if (fscanf(fp1, "%s", SEIHIN_Name) == EOF) ShowFinMsg("製品名が不正です");
	if (fscanf(fp1, "%d", &Filename) == EOF) ShowFinMsg("読み取るファイル名を記述してください");
	//if (fscanf(fp1, "%s", inPath_Jyunjyo) == EOF) ShowFinMsg("組立順序が不正です");
	//if (fscanf(fp1, "%d", &NewNOS0) == EOF) ShowFinMsg("NOS0の情報が足りません");
	//if (fscanf(fp1, "%d", &hyoukamode) == EOF) ShowFinMsg("VFDLを出力するのか評価だけなのかの情報が足りません");
	if (fscanf(fp1, "%d", &maxkumijun) == EOF) ShowFinMsg("読み取る組立順序ファイルの最大数を記述してください");
	if (fscanf(fp1, "%s", inPath_input) == EOF) ShowFinMsg("inputのアドレスが不正です");
	if (fscanf(fp1, "%s", outPath_VFDL) == EOF) ShowFinMsg("VFDLのoutputのアドレスが不正です");
	if (fscanf(fp1, "%s", outPath_Hyouka) == EOF) ShowFinMsg("ステップ数のoutputのアドレスが不正です");
	printf("%s", SEIHIN_Name);
	printf("読み込む最大のファイル番号は%d\n", maxkumijun);

	if (Filename == 1)
	{
		sprintf(inPath_Header, "%s\\%s_網羅_レイアウト.csv", inPath_input, SEIHIN_Name);
		sprintf(inPath_Kumitsuke, "%s\\%s_網羅_組付け.csv", inPath_input, SEIHIN_Name);

	}
	if (Filename == 2)
	{
		sprintf(inPath_Header, "%s\\%s_部品群_レイアウト.csv", inPath_input, SEIHIN_Name);
		sprintf(inPath_Kumitsuke, "%s\\%s_部品群_組付け.csv", inPath_input, SEIHIN_Name);
	}
	if (Filename == 3)
	{
		sprintf(inPath_Header, "%s\\%s_分解_レイアウト.csv", inPath_input, SEIHIN_Name);
		sprintf(inPath_Kumitsuke, "%s\\%s_分解_組付け.csv", inPath_input, SEIHIN_Name);
	}

	sprintf(inPath_Kumitateichi, "%s\\%s_接触関係_組立位置情報.csv", inPath_input, SEIHIN_Name);
	sprintf(inPath_Buhin, "%s\\%s_部品属性.csv", inPath_input, SEIHIN_Name);
	
	sprintf(inPath_VFDL_KARI, "%s\\VFDL_KARI.csv", outPath_VFDL);
	//sprintf(outPath_Hyouka, "%s", outPath_VFDL);
	// 
	//printf("%s\n", inPath_Jyunjyo);
	/*if (fscanf(fp1, "%s", inPath_Header) == EOF) ShowFinMsg("ヘッダー情報が不正です");
	if (fscanf(fp1, "%s", inPath_Jyunjyo) == EOF) ShowFinMsg("組立順序が不正です");
	if (fscanf(fp1, "%s", outPath_VFDL) == EOF) ShowFinMsg("VFDL1が不正です");
	if (fscanf(fp1, "%s", inPath_Kumitateichi) == EOF) ShowFinMsg("接触関係＿組立位置情報が不正です");
	if (fscanf(fp1, "%s", inPath_Kumitsuke) == EOF) ShowFinMsg("組付けが不正です");
	if (fscanf(fp1, "%s", inPath_Buhin) == EOF) ShowFinMsg("部品属性が不正です");
	if (fscanf(fp1, "%s", outPath_Hyouka) == EOF) ShowFinMsg("評価が不正です");
	if (fscanf(fp1, "%s", inPath_VFDL_KARI) == EOF) ShowFinMsg("VFDL(仮)が不正です");
	if (fscanf(fp1, "%s", movement) == EOF) ShowFinMsg("動作データベースが不正です");
	if (fscanf(fp1, "%d", &NewNOS0) == EOF) ShowFinMsg("NOS0の情報が足りません");
	if (fscanf(fp1, "%d", &hyoukamode) == EOF) ShowFinMsg("VFDLを出力するのか評価だけなのかの情報が足りません");
	*/
	//if (fscanf(fp1, "%s", inPath_SetDifficulty) == EOF) ShowFinMsg("組み付けのやりづらさファイルが不正です");

	//出力先のフルパスをWkDに代入する
	
	//if (hyoukamode != 2)
	{
		strcpy(WkD, outPath_Hyouka);
		strcat(WkD, "\\");
		strcat(WkD, SEIHIN_Name);

		strcpy(outPath_Hyouka, WkD);
		if (Filename == 1)
		{
			strcat(WkD, "_網羅");
		}
		else if (Filename == 2)
		{
			strcat(WkD, "_部品群");
		}
		else if (Filename == 3)
		{
			strcat(WkD, "_分解");
		}
		strcat(WkD, "_ステップ数総合評価.csv");

		//printf("%s\n", WkD);
		hyouka = fopen(WkD, "w");
		if (hyouka == NULL) ShowFinMsg("評価のフルパスが不正です");
		
		fprintf(hyouka, "組立順序番号,ステップ数,事前ステップ,ステップ数−事前ステップ,手の総移動距離,右手の移動距離,左手の移動距離,親部品の回転回数,総回転回数,親部品の回転角度,総回転角度\n");
	}

	Read_movement();//動作の流れの読み込み

	ReadBuhin();//部品属性の読み取り

	ReadKumitateichi();//組立位置の読み取り

	ReadKumitsuke();//組付けの読み取り
	
	//出力先のフルパスをWkDに代入する
	strcpy(WkD, outPath_VFDL);
	strcat(WkD, "\\");
	strcat(WkD, "VFDL_KARI.csv");
	
	//printf("%s\n", WkD);
	kari = fopen(WkD, "w");
	if (kari == NULL) ShowFinMsg("フルパスが不正です");
	
	Make_VFDL();
	
	if (remove(inPath_VFDL_KARI) == 0)
		printf("%sを削除しました。\n", inPath_VFDL_KARI);
	else
		printf("%sを削除できませんでした。\n", inPath_VFDL_KARI);
}

void Make_VFDL()
{
	FILE* fp6;
	FILE* fp7;
	char temp[FGETS_MAX_LENGTH];
	char WkD[STR_MAX], houkoukariX[3], houkoukariZ[3];
	int d = 0, base = 0;
	char buff[10];
	int pre_oya = 0, pre_ko = 0, i = 0, j = 0, movenum;
	int jigcount = 0, Jig = 0, Jig2 = 0, KouguNum = 0, KouguNum2 = 0;
	int kumjunbangou = 0;
	int hyoukacount = 0, hyoukabangou = 0;
	int Count = 0;

	double temp_ichi[MaxN / 2][3], temp_num[MaxN / 2][2];
	int count = 0;

	for (kumjunbangou = 0; kumjunbangou <= maxkumijun; kumjunbangou++)
	{
		if (Filename == 1)
		{
			sprintf(WkD, "%s\\%s_網羅_動作付組立順序%d.csv", inPath_input, SEIHIN_Name, kumjunbangou);
		}
		else if (Filename == 2)
		{
			sprintf(WkD, "%s\\%s_部品群_動作付組立順序%d.csv", inPath_input, SEIHIN_Name, kumjunbangou);
		}
		else if (Filename == 3)
		{
			sprintf(WkD, "%s\\%s_分解_動作付組立順序%d.csv", inPath_input, SEIHIN_Name, kumjunbangou);
		}

		//sprintf(WkD, "%s\\%s_網羅_動作付き組立順序%d.csv", inPath_input, SEIHIN_Name, kumjunbangou);
		fp6 = fopen(WkD, "r");
		//if (fp6 == NULL) ShowFinMsg("組立順序情報が不正です");
		if (fp6 != NULL)
		{
			fgets(temp, FGETS_MAX_LENGTH, fp6);
			Del_Com(temp);//csvファイルはデータごとにカンマがついた形で保存されているので、カンマを消す
			sscanf(temp, "%s%d%d%d", &kumihead.K, &kumihead.KJnum, &kumihead.flag, &kumihead.x);

			while (fgets(temp, FGETS_MAX_LENGTH, fp6) != NULL)//ファイルの最後まで
			{
				if (strstr(temp, "K") != NULL)//読み込んだ行にKの文字があるとき
				{
				onemore:
					
					ReadHeader();//レイアウト情報を読み取る
					
					itoa(kumihead.KJnum, buff, 10);
					strcpy(WkD, outPath_VFDL);
					strcat(WkD, "\\");
					strcat(WkD, SEIHIN_Name);
					if (Filename == 1)
					{
						strcat(WkD, "_網羅");
					}
					else if (Filename == 2)
					{
						strcat(WkD, "_部品群");
					}
					else if (Filename == 3)
					{
						strcat(WkD, "_分解");
					}
					strcat(WkD, "_VFDL");
					strcat(WkD, buff);
					//strcat(WkD, KJ);
					strcat(WkD, ".csv");
					char* fname = WkD;
					
					//組立てたものの今後の組立で用いない中間製品を調べる
					for (i = 0; i < gyousu - 1; i++)
					{
						for (j = i; j < gyousu; j++)
						{
							if (kumijun[i].tyukan == kumijun[j].ko || kumijun[i].tyukan == kumijun[j].oya)//今後の組立で用いる中間製品であった時
							{
							
								not_use_flag = 1;
								break;
							}
						}

						if (not_use_flag == 0)//今後の組立で用いない中間製品であった時
						{
						
							not_use[not_use_count] = kumijun[i].tyukan;
							not_use_count++;
						}
						not_use_flag = 0;
					}

					//両手2部品組付けの親2子2を見つける
					for (i = 0; i < gyousu - 1; i++)
					{
						if (kumijun[i].scene_type == oya1ko2)//子部品2つを両手で組立てるとき
						{
							if (kumijun[i].tyukan != kumijun[i + 1].oya && kumijun[i].tyukan != kumijun[i + 1].ko)
							{
								kumijun[i].scene_type = kumijun[i + 1].scene_type = oya2ko2;
								//i++; //武井さん
							}

							i++; //2022/1/14　古屋変更
						}
					}

					MakingS0();//初めの状態を作成

					if (gyousu + 1 != N)//部品数と行数＋1が一致しない時(予め中間製品を組立てておかなければならない時)もしくは最後まで組立を行わないとき
					{
						Make_pre_assembly(kari, pre_assemble, pre_count);
					}

					for (a = 0; a < gyousu; a++)//座標や動作を作成する(組立順序の回数分繰り返す)
					{
						movenum = 0;
						if (kumijun[a - 1].scene_type == tegumi && kumijun[a].scene_type != tegumi)
						{
							for (i = 0; i < JigPartssu; i++)//手組みしている部品は手組みを行っている間はプログラム内では手組みの治具についている設定になってるので手組みでなくなった時に放す
							{
								temp_num[i][0] = jig_parts[i].num;
								temp_num[i][1] = jig_parts[i].jignum;
								temp_ichi[i][0] = jig_parts[i].IchiX;
								temp_ichi[i][1] = jig_parts[i].IchiY;
								temp_ichi[i][2] = jig_parts[i].IchiZ;
								jig_parts[i].num = 0;
								jig_parts[i].jignum = 0;
								jig_parts[i].IchiX = 0;
								jig_parts[i].IchiY = 0;
								jig_parts[i].IchiZ = 0;
							}

							for (i = 0; i < JigPartssu; i++)
							{
								if (temp_num[i][0] != kumijun[a - 1].tyukan)//仮置きする中間製品と部品番号が一致した部品は仮置きする部品なので一致しない部品だけを保存する
								{
									jig_parts[i].num = temp_num[i][0];
									jig_parts[i].jignum = temp_num[i][1];
									jig_parts[i].IchiX = temp_ichi[i][0];
									jig_parts[i].IchiY = temp_ichi[i][1];
									jig_parts[i].IchiZ = temp_ichi[i][2];
									count++;
								}
							}
							JigPartssu = count;
							count = 0;
						}

						if (NewNOS0 == 0)
						{
							Jig = kumijun[a].jig - 1;
							KouguNum = kumijun[a].kougu - 1;
						}
						else
						{
							for (i = 0; i < Jigu; i++)
							{
								if (A_Objects[0][3 * N + 2 + i + putting].Id == kumijun[a].jig)
								{
									Jig = i;
									break;
								}

							}
							for (i = 0; i < Kougu; i++)
							{
								if (A_Objects[0][3 * N + 2 + i + putting + Jigu].Id == kumijun[a].kougu)
								{
									KouguNum = i;
									break;
								}
							}
						}

						if (kumijun[a].scene_type == oya2ko1 || kumijun[a].scene_type == oya2ko2)
						{
							
							if (NewNOS0 == 0)
							{
								Jig2 = kumijun[a + 1].jig - 1;
							}
							else
							{
								for (i = 0; i < Jigu; i++)
								{
									if (A_Objects[0][3 * N + 2 + i + putting].Id == kumijun[a + 1].jig)
									{
										Jig = i;
										break;
									}

								}
								for (i = 0; i < Kougu; i++)
								{
									if (A_Objects[0][3 * N + 2 + i + putting + Jigu].Id == kumijun[a + 1].kougu)
									{
										KouguNum2 = i;
										break;
									}
								}
							}
						}

						if (kumijun[a].scene_type == oya2ko1 || kumijun[a].scene_type == oya2ko2)
						{
							
							for (i = 0; i < JigPartssu; i++)//部品がすでに治具についているか調べる
							{
								if (jig_parts[i].num == kumijun[a].oya && jig_parts[i].jignum == Jig)//すでに治具についていればカウント
								{
									jigcount++;
								}
								else if (jig_parts[i].num == kumijun[a + 1].oya && jig_parts[i].jignum == Jig2)
								{
									jigcount++;
								}
							}
						}
						else
						{
							for (i = 0; i < JigPartssu; i++)//部品がすでに治具についているか調べる
							{
								if (jig_parts[i].num == kumijun[a].oya && jig_parts[i].jignum == Jig)//すでに治具についていればカウント
								{
									jigcount++;
								}
								else if (jig_parts[i].num == kumijun[a].oya && jig_parts[i].jignum != Jig)//親部品がすでに治具についているが使用する治具ではないとき
								{
									ChangeJig = kumijun[a].oya;
								}
								else if (jig_parts[i].num == kumijun[a].ko)//子部品が治具についているとき
								{
									JigKobuhin = kumijun[a].ko;
								}
							}
						}

						if (kumijun[a].scene_type == oya1ko2 || kumijun[a].scene_type == oya2ko2)
						{
							for (i = 0; i < JigPartssu; i++)//子部品が治具についているか調べる
							{
								if (jig_parts[i].num == kumijun[a].ko)//治具についていればカウント
								{
									JigKobuhin = kumijun[a].ko;
								}
								else if (jig_parts[i].num == kumijun[a + 1].ko)
								{
									JigKobuhin2 = kumijun[a + 1].ko;
								}
							}
						}

						Make_kumitatemae(a);//組立前の状態を作る
						
						//一つ前の組立で出来た中間製品が親部品のとき、かつ最初の組立でないとき、もしくは部品が使用する治具にすでについているとき　連続した組付けの途中で手組みにするとき　　　　　　　　　　　　　　　　　　　　手組みしてできた中間製品が治具に付くとき                                                                                      
						if ((((kumijun[a - 1].tyukan == kumijun[a].oya && a != 0) || jigcount != 0) && ChangeJig == 0) || (((kumijun[a - 1].tyukan == kumijun[a].oya && a != 0) || jigcount != 0) && kumijun[a].scene_type == tegumi) || (((kumijun[a - 1].tyukan == kumijun[a].oya && a != 0)|| (kumijun[a - 1].tyukan == kumijun[a].ko && a != 0)) && kumijun[a - 1].scene_type == tegumi))//古屋学会用
						{
							
							printf("%d\n", kumijun[a - 1].tyukan);
							movenum = Move_decision(kumigo_to_kumimae, a);//作成する状態から動作を決定
							Make_Joutai(a, movenum);
							kumitatego_to_kumitatemae(kari, a, movenum);
							Count++;
						}
						else//一つ前の組立で出来た中間製品が子部品または今回の組立で用いられていない時
						{
							//printf("%d\n", kumijun[a - 1].tyukan);
							//Make_oyabuhin_move(kari, a);
							movenum = Move_decision(karioki_to_kumimae, a);//作成する状態から動作を決定
							Make_Joutai(a, movenum);
							start_to_kumitatemae(kari, a, movenum);
							Count++;
						}
						//Make_kobuhin_coord(a);
						//Make_kobuhin_move(kari, a);
						//hoziflag = 0;
						jigcount = 0;
						ChangeJig = 0;
						ChangeJig2 = 0;
						JigKobuhin = 0;
						JigKobuhin = 0;
						Make_kumitatego(a);
						movenum= Move_decision(kumimae_to_kumigo, a);//作成する状態から動作を決定
						Make_Joutai(a, movenum);
						
						kumitatemae_to_kumitatego(kari, a, movenum);

						Count++;
						
							if ((kumijun[a].scene_type != oya2ko2 && kumijun[a].scene_type != oya1ko2 && kumijun[a].scene_type != oya2ko1 && kumijun[a + 1].scene_type != oya2ko2 && kumijun[a + 1].scene_type != oya2ko1 && kumijun[a].tyukan != kumijun[a + 1].oya && kumijun[a].tyukan != kumijun[a + 1].ko && a != gyousu - 1)//現在の組立が両手でないかつ、次の組立が親部品が2つ(親2子2、親2子1)でないときに,次の組付けで出来た中間製品が用いられず組立順序の最終行でない時
								|| ((kumijun[a].scene_type == oya1ko2 || kumijun[a].scene_type == oya2ko1) && kumijun[a + 2].scene_type != oya2ko2 && kumijun[a + 2].scene_type != oya2ko1 && kumijun[a + 1].tyukan != kumijun[a + 2].oya && kumijun[a + 1].tyukan != kumijun[a + 2].ko && a + 1 != gyousu - 1)//現在の組立が両手でできる中間製品が1つ(親1子2または親2子1)で次の組立が親部品が2つ(親2子2、親2子1)でないときに、次の組付けで出来た中間製品が用いられず組立順序の最終行でない時
								|| (kumijun[a].scene_type == oya2ko2 && (kumijun[a + 2].scene_type != oya2ko2 || kumijun[a + 2].scene_type != oya2ko1) && kumijun[a].tyukan != kumijun[a + 2].oya && kumijun[a + 1].tyukan != kumijun[a + 2].oya && a + 1 != gyousu - 1)//現在の組付けが親部品2つ(親2子2)で次の組立が親部品2つ(親2子1または親2子2)でなくできた中間製品が用いられていない時で組立順序の最後ではないとき
								//|| ((kumijun[a].scene_type == oya2ko2 && kumijun[a + 2].scene_type != oya2ko2) && ((kumijun[a].tyukan == kumijun[a + 2].oya || kumijun[a].tyukan == kumijun[a + 2].ko) && (kumijun[a+1 ].tyukan == kumijun[a + 2].oya || kumijun[a+1].tyukan == kumijun[a + 2].ko)))
								|| (kumijun[a].scene_type != oya2ko2 && kumijun[a].scene_type != oya1ko2 && kumijun[a].scene_type != oya2ko1 && (kumijun[a + 1].scene_type == oya2ko2 || kumijun[a + 1].scene_type == oya2ko1) && kumijun[a].tyukan != kumijun[a + 1].oya && kumijun[a].tyukan != kumijun[a + 2].oya && a != gyousu - 1)//現在の組付けが両手でないかつ、次の組立が親部品2つ(親2子1または親2子2)のときにできた中間製品が親部品にならならず、組立順序の最後ではないとき
								|| ((kumijun[a].scene_type == oya1ko2 || kumijun[a].scene_type == oya2ko1) && (kumijun[a + 2].scene_type == oya2ko2 || kumijun[a + 2].scene_type == oya2ko1) && kumijun[a + 1].tyukan != kumijun[a + 2].oya && kumijun[a + 1].tyukan != kumijun[a + 3].oya && a + 1 != gyousu - 1)//現在の組立が両手でできる中間製品が1つ(親1子2または親2子1)で次の組立が親部品が2つ(親2子2、親2子1)の時、次の組付けで出来た中間製品が用いられず組立順序の最終行でない時
								|| (kumijun[a].scene_type == oya2ko2 && (kumijun[a + 2].scene_type == oya2ko2 || kumijun[a + 2].scene_type == oya2ko1) && (kumijun[a].tyukan != kumijun[a + 2].oya && kumijun[a + 1].tyukan != kumijun[a + 3].oya) && (kumijun[a].tyukan != kumijun[a + 3].oya && kumijun[a + 1].tyukan != kumijun[a + 2].oya) && a + 1 != gyousu - 1))//現在の組付けが親部品2つ(親2子2)で次の組立が親部品2つ(親2子2または親2子1)で、できた中間製品が両方とも次の両手組付けで用いられていないとき用いられていない時
							{
								
								//治具についている部品すべてを仮置きする時の操作
								/*if (kumijun[a].scene_type == oya1ko2 || kumijun[a].scene_type == oya2ko1)
								{
									//Make_karioki(a+1);
									if (kumijun[a+1].jig == kumijun[a + 2].jig)//使用する治具が同じとき
									{
										Make_karioki(a+1);
									}
									else//使用する治具が異なるとき
									{
										for (i = a + 2;i < gyousu - 1;i++)
										{
											if (kumijun[i].jig == kumijun[a+1].jig && kumijun[i].oya != kumijun[a+1].tyukan)//今回使用した治具と同じ治具を使用する組付けで今回できた中間製品と親部品が異なるときは仮置き
											{
												Make_karioki(a);
												break;
											}
											else if (kumijun[i].oya == kumijun[a+1].tyukan)//今回使用した治具と同じ治具を使用する組付けで、今回できた中間製品と親部品が異なる組付けの前にその部品を用いる組付けがあるならばそのまま治具に付けておく
											{
												SType = hukusujig;
												break;
											}
										}
									}
								}
								else
								{
									if (kumijun[a].jig == kumijun[a + 1].jig)//使用する治具が同じとき
									{
										Make_karioki(a);
									}
									else//使用する治具が異なるとき
									{
										if (kumijun[a].scene_type == tegumi)//手組みの時は手で保持しているので必ず仮置きになる
										{
											Make_karioki(a);
										}
										else
										{
											for (i = a + 1;i < gyousu - 1;i++)
											{
												if (kumijun[i].jig == kumijun[a].jig && kumijun[i].oya != kumijun[a].tyukan)//今回使用した治具と同じ治具を使用する組付けで今回できた中間製品と親部品が異なるときは仮置き
												{
													Make_karioki(a);
													break;
												}
												else if (kumijun[i].oya == kumijun[a].tyukan)//今回使用した治具と同じ治具を使用する組付けで、今回できた中間製品と親部品が異なる組付けの前にその部品を用いる組付けがあるならばそのまま治具に付けておく
												{
													SType = hukusujig;
													break;
												}
											}
										}
									}
								}*/

								if (not_use_count > 0)
								{

									if (kumijun[a].scene_type == oya1ko2 || kumijun[a].scene_type == oya2ko1)
									{

										for (i = 0; i < not_use_count; i++)
										{
											if (kumijun[a + 1].tyukan == not_use[i])
											{
												not_use_flag = 1;
												break;
											}
										}
									}
									else
									{
										for (i = 0; i < not_use_count; i++)
										{
											if (kumijun[a].tyukan == not_use[i])
											{
												not_use_flag = 1;
												break;
											}
										}
									}
								}
								if (not_use_flag == 1)//今後用いない中間製品であった時
								{
									//要検討
									Make_karioki(a);
									movenum = Move_decision(kumigo_to_karioki, a);//作成する状態から動作を決定
									Make_Joutai(a, movenum);
									kumitatego_to_finish(kari, a, movenum);
									Count++;

								}
								else

								{
							
									if (kumijun[a].scene_type == oya1ko2 || kumijun[a].scene_type == oya2ko1)
									{

										if (kumijun[a + 1].jig == kumijun[a + 2].jig)//使用する治具が同じとき
										{
											Make_karioki(a + 1);
											movenum = Move_decision(kumigo_to_karioki, a + 1);//作成する状態から動作を決定
											Make_Joutai(a + 1, movenum);
											kumitatego_to_karioki(kari, a + 1, movenum);
											Count++;
										}
										else//使用する治具が異なるとき
										{
											for (i = a + 2; i < gyousu - 1; i++)
											{
												if (kumijun[i].jig == kumijun[a + 1].jig && kumijun[i].oya != kumijun[a + 1].tyukan)//今回使用した治具と同じ治具を使用する組付けで今回できた中間製品と親部品が異なるときは仮置き
												{
													Tnum++;
													Make_karioki(a + 1);
													movenum = Move_decision(kumigo_to_karioki, a + 1);//作成する状態から動作を決定
													Make_Joutai(a + 1, movenum);
													kumitatego_to_karioki(kari, a + 1, movenum);
													Count++;
													break;
												}
												else if (kumijun[i].oya == kumijun[a + 1].tyukan || kumijun[i].ko == kumijun[a + 1].tyukan)//今回使用した治具と同じ治具を使用する組付けで、今回できた中間製品と親部品が異なる組付けの前にその部品を用いる組付けがあるならばそのまま治具に付けておく
												{
													SType = hukusujig;
													Tnum++;
													Tnum++;
													movenum = Move_decision(kumigo_to_karioki, a + 1);//作成する状態から動作を決定
													Make_Joutai(a + 1, movenum);
													kumitatego_to_karioki(kari, a + 1, movenum);
													Count++;
													break;
												}
											}
										}
									}
									else if (kumijun[a].scene_type == oya2ko2)
									{
										if (not_use_count > 0)
										{
											for (i = 0; i < not_use_count; i++)
											{
												if (kumijun[a].tyukan == not_use[i])
												{
													not_use_flag = not_use_flag + 1;
												}
												else if (kumijun[a + 1].tyukan == not_use[i])
												{
													not_use_flag = not_use_flag + 2;
												}
											}
										}
										if (not_use_flag == 1)
										{
											kariokiflag = kariokiflag * 5;
											//Make_karioki(a);
											//movenum = Move_decision(kumigo_to_karioki, a);//作成する状態から動作を決定
											//kumitatego_to_finish(kari, a, movenum);
											//Tnum++;
										}
										else if (not_use_flag == 2)
										{
											//Tnum++;
											kariokiflag = kariokiflag * 2;
											//Make_karioki(a+1);
											//movenum = Move_decision(kumigo_to_karioki, a+1);//作成する状態から動作を決定
											//kumitatego_to_finish(kari, a+1, movenum);
										}
										else if (not_use_flag == 3)
										{
											kariokiflag = kariokiflag * 2 * 5;
											Make_karioki(a);
											movenum = Move_decision(kumigo_to_karioki, a);//作成する状態から動作を決定
											Make_Joutai(a, movenum);
											kumitatego_to_finish(kari, a, movenum);
											Count++;
										}

										if (not_use_flag != 3)//両方の部品が完成品ではないとき
										{
											if ((kumijun[a].jig == kumijun[a + 2].jig && kumijun[a + 1].jig == kumijun[a + 3].jig) || (kumijun[a].jig == kumijun[a + 3].jig && kumijun[a + 1].jig == kumijun[a + 2].jig))//使用する治具が次の組立と同じとき
											{
												kariokiflag = kariokiflag * 2 * 5;
												Make_karioki(a);
												movenum = Move_decision(kumigo_to_karioki, a);//作成する状態から動作を決定
												Make_Joutai(a, movenum);
												kumitatego_to_finish(kari, a, movenum);
												Count++;
											}
											else//使用する治具が次の組立と異なるとき
											{
												for (i = a + 2; i < gyousu - 1; i++)
												{
													//先に同じ行に対する判定で先に当てはまるものがあったら、もう一つの判定に当てはまるモノがあってもカウントしたくないので、素数で管理
													if (kumijun[i].jig == kumijun[a + 1].jig && kumijun[i].oya != kumijun[a + 1].tyukan && kariokiflag % 3 != 0)//2行目に対し今回使用した治具と同じ治具を使用する組付けで今回できた中間製品と親部品が異なるときは仮置き
													{
														kariokiflag = kariokiflag * 2;
													}
													else if ((kumijun[i].oya == kumijun[a + 1].tyukan || kumijun[i].ko == kumijun[a + 1].tyukan) && kariokiflag % 2 != 0)//2行目に対して今回使用した治具と同じ治具を使用する組付けで、今回できた中間製品と親部品が異なる組付けの前にその部品を用いる組付けがあるならばそのまま治具に付けておく
													{
														kariokiflag = kariokiflag * 3;
													}
													else if (kumijun[i].jig == kumijun[a].jig && kumijun[i].oya != kumijun[a].tyukan && kariokiflag % 7 != 0)//1行目に対して今回使用した治具と同じ治具を使用する組付けで今回できた中間製品と親部品が異なるときは仮置き
													{
														kariokiflag = kariokiflag * 5;
													}
													else if ((kumijun[i].oya == kumijun[a].tyukan || kumijun[i].ko == kumijun[a].tyukan) && kariokiflag % 5 != 0)//1行目に対して今回使用した治具と同じ治具を使用する組付けで、今回できた中間製品と親部品が異なる組付けの前にその部品を用いる組付けがあるならばそのまま治具に付けておく
													{
														kariokiflag = kariokiflag * 7;
													}
												}

												if (kariokiflag % 2 == 0 && kariokiflag % 5 == 0)//両方を仮置き
												{
													Make_karioki(a);
													movenum = Move_decision(kumigo_to_karioki, a);//作成する状態から動作を決定
													Make_Joutai(a, movenum);
													kumitatego_to_finish(kari, a, movenum);
													Count++;
												}
												else if (kariokiflag % 2 == 0 && kariokiflag % 7 == 0)//2行目の方の中間製品を仮置き
												{
													Tnum++;
													Make_karioki(a + 1);
													movenum = Move_decision(kumigo_to_karioki, a + 1);//作成する状態から動作を決定
													Make_Joutai(a + 1, movenum);
													kumitatego_to_finish(kari, a + 1, movenum);
													Count++;
												}
												else if (kariokiflag % 3 == 0 && kariokiflag % 5 == 0)//1行目の方の中間製品を仮置き
												{
													Make_karioki(a);
													movenum= Move_decision(kumigo_to_karioki, a);//作成する状態から動作を決定
													Make_Joutai(a, movenum);
													kumitatego_to_finish(kari, a, movenum);
													Tnum++;
													Count++;
												}
												else if (kariokiflag % 3 == 0 && kariokiflag % 7 == 0)//1行目の方の中間製品を仮置き
												{
													for (i = 0; i < 3 * N + 2 + Kougu + putting + Jigu; i++)
													{
														if (kumijun[a].tyukan == A_Objects[1][i].Id)
														{
															TyuPnum = i;
														}
														else if (kumijun[a + 1].tyukan == A_Objects[1][i].Id)
														{
															TyuPnum1 = i;
														}
													}
													if (A_Objects[0][TyuPnum].IchiX > A_Objects[0][TyuPnum1].IchiX)//右手左手でどの中間製品を扱うのかの判定
													{
														R_TyuPnum = TyuPnum;
														L_TyuPnum = TyuPnum1;
													}
													else
													{
														R_TyuPnum = TyuPnum1;
														L_TyuPnum = TyuPnum;
													}
													SType = hukusujig;
													Tnum++;
													Tnum++;
													movenum= Move_decision(kumigo_to_karioki, a);//作成する状態から動作を決定
													Make_Joutai(a, movenum);
													kumitatego_to_finish(kari, a, movenum);
													Count++;
												}
											}
											kariokiflag = 1;
											not_use_flag = 0;
										}
									}
									else//組立順序2行分の組立ではないとき
									{
									
										if (kumijun[a].jig == kumijun[a + 1].jig)//使用する治具が同じとき
										{
											Make_karioki(a);
											movenum= Move_decision(kumigo_to_karioki, a);//作成する状態から動作を決定
											kumitatego_to_karioki(kari, a, movenum);
											Count++;
										}
										else//使用する治具が異なるとき
										{
											

											if (kumijun[a].scene_type == tegumi)//手組みの時は手で保持しているので必ず仮置きになる
											{
											
												Make_karioki(a);
												movenum = Move_decision(kumigo_to_karioki, a);//作成する状態から動作を決定
												kumitatego_to_karioki(kari, a, movenum);
												Count++;
											}
											else
											{
												//for (i = a + 1; i < gyousu - 1; i++)
												for (i = a + 1; i <= gyousu - 1; i++)//古屋変更
												{
													if (kumijun[i].jig == kumijun[a].jig && kumijun[i].oya != kumijun[a].tyukan)//今回使用した治具と同じ治具を使用する組付けで今回できた中間製品と親部品が異なるときは仮置き
													{
														Make_karioki(a);
														movenum= Move_decision(kumigo_to_karioki, a);//作成する状態から動作を決定
														kumitatego_to_karioki(kari, a, movenum);
														Count++;
														break;
													}
													else if (kumijun[i].oya == kumijun[a].tyukan || kumijun[i].ko == kumijun[a].tyukan)//今回使用した治具と同じ治具を使用する組付けで、今回できた中間製品と親部品が異なる組付けの前にその部品を用いる組付けがあるならばそのまま治具に付けておく
													{
														SType = hukusujig;
														if (kumijun[a].kougu != kumijun[a + 1].kougu && kumijun[a].kougu != 0)//使用する工具が変更されている時、用いた工具を工具置き場に戻すので工具置き場の位置に合わせる
														{
															A_Objects[1][3 * N + 2 + putting + Jigu + KouguNum].IchiX = A_Kougus[KouguNum].IchiX;//工具の位置を工具置き場にする
															A_Objects[1][3 * N + 2 + putting + Jigu + KouguNum].IchiY = A_Kougus[KouguNum].IchiY;//工具の位置を工具置き場にする
															A_Objects[1][3 * N + 2 + putting + Jigu + KouguNum].IchiZ = A_Kougus[KouguNum].IchiZ;//工具の位置を工具置き場にする
														}
														movenum= Move_decision(kumigo_to_karioki, a);//作成する状態から動作を決定
														kumitatego_to_karioki(kari, a, movenum);
														Tnum++;
														Count++;
														break;
													}
												}
											}
										}
									}
								}

								not_use_flag = 0;
							}
							//else if (kumijun[a].scene_type == oya2ko2 && a + 1 != gyousu - 1 && (kumijun[a].jig == kumijun[x].jig || kumijun[a + 1].jig == kumijun[x].jig))//両手2部品でできた部品の片方を仮置きするとき,もしくは仮置きしない時
							else if (kumijun[a].scene_type == oya2ko2 && a + 1 != gyousu - 1)
							{
							
								if ((kumijun[a + 2].scene_type == oya2ko2 || kumijun[a + 2].scene_type == oya2ko1) && (kumijun[a].tyukan == kumijun[a + 2].oya || kumijun[a + 1].tyukan == kumijun[a + 2].oya) && (kumijun[a].tyukan != kumijun[a + 3].oya || kumijun[a + 1].tyukan != kumijun[a + 3].oya))//現在の組立が親2子2で次の組立が親部品2つで同じ部品を2つとも用いるとき
								{//何もしない

								}
								else if ((kumijun[a + 2].scene_type != oya2ko2 && kumijun[a].tyukan == kumijun[a + 2].oya)//現在の組付けが親2子2で次の組付けが親2子2でないとき、組立順序1行目の部品が親部品になっているとき(2行目の部品を用いないとき)
									|| (kumijun[a + 2].scene_type == oya2ko2 && kumijun[a].tyukan == kumijun[a + 2].oya) || (kumijun[a + 2].scene_type == oya2ko2 && kumijun[a].tyukan == kumijun[a + 3].oya))//現在の組付けが親2子2で次の組付けが親2子2のとき、組立順序1行目の組付けが次の組付けのどちらかの親部品になっている時
								{//今回できた2行目の中間製品を仮置き
									/*if (((kumijun[a + 2].scene_type != oya2ko2 && kumijun[a].tyukan == kumijun[a + 2].oya) || (kumijun[a + 2].scene_type == oya2ko2 && kumijun[a].tyukan == kumijun[a + 2].oya) && kumijun[a].jig == kumijun[a + 2].jig)
										|| (kumijun[a + 2].scene_type == oya2ko2 && kumijun[a].tyukan == kumijun[a + 3].oya&&kumijun[a].jig == kumijun[a + 3].jig))//使用する治具が同じ時
									{
										Make_karioki(a + 1);
									}
									else
									{
										for (i = a + 2;i < gyousu - 1;i++)
										{
											if (kumijun[i].jig == kumijun[a].jig && kumijun[i].oya != kumijun[a].tyukan)//今回使用した治具と同じ治具を使用する組付けで今回できた中間製品と親部品が異なるときは仮置き
											{
												Make_karioki(a);
												break;
											}
											else if (kumijun[i].oya == kumijun[a].tyukan)//今回使用した治具と同じ治具を使用する組付けで、今回できた中間製品と親部品が異なる組付けの前にその部品を用いる組付けがあるならばそのまま治具に付けておく
											{
												SType = hukusujig;
												break;
											}
										}
									}*/

									if (not_use_count > 0)
									{
										for (i = 0; i < not_use_count; i++)
										{
											if (kumijun[a + 1].tyukan == not_use[i])
											{
												not_use_flag = 2;
												break;
											}
										}
									}
									if (not_use_flag == 2)//今後用いない中間製品であった時
									{
										//要検討
										Tnum++;
										kariokiflag = kariokiflag * 2 * 7;
										Make_karioki(a + 1);
										movenum= Move_decision(kumigo_to_karioki, a + 1);//作成する状態から動作を決定
										Make_Joutai(a + 1, movenum);
										kumitatego_to_finish(kari, a + 1, movenum);
										Count++;
									}
									else
									{
										//小峯
										if ((((kumijun[a + 2].scene_type != oya2ko2 && kumijun[a].tyukan == kumijun[a + 2].oya) || (kumijun[a + 2].scene_type == oya2ko2 && kumijun[a].tyukan == kumijun[a + 2].oya)) && kumijun[a].jig == kumijun[a + 2].jig)
											|| (kumijun[a + 2].scene_type == oya2ko2 && kumijun[a].tyukan == kumijun[a + 3].oya && kumijun[a].jig == kumijun[a + 3].jig))//使用する治具が同じ時
										{
											Tnum++;
											kariokiflag = kariokiflag * 2 * 7;
											Make_karioki(a + 1);
											movenum = Move_decision(kumigo_to_karioki, a + 1);//作成する状態から動作を決定
											Make_Joutai(a + 1, movenum);
											kumitatego_to_karioki(kari, a + 1, movenum);
											Count++;
										}
										else//使用する治具が異なるとき
										{
											//小峯修正
											for (i = a + 2; i <= gyousu; i++)
											{
												if (kumijun[i].jig == kumijun[a + 1].jig && kumijun[i].oya != kumijun[a + 1].tyukan)//今回使用した治具と同じ治具を使用する組付けで今回できた中間製品と親部品が異なるときは仮置き
												{
													Make_karioki(a + 1);
													movenum= Move_decision(kumigo_to_karioki, a + 1);//作成する状態から動作を決定
													Make_Joutai(a + 1, movenum);
													kumitatego_to_karioki(kari, a + 1, movenum);
													Count++;
													break;
												}
												else if (kumijun[i].oya == kumijun[a + 1].tyukan || kumijun[i].ko == kumijun[a + 1].tyukan)//今回使用した治具と同じ治具を使用する組付けで、今回できた中間製品と親部品が異なる組付けの前にその部品を用いる組付けがあるならばそのまま治具に付けておく
												{
													kariokiflag = kariokiflag * 3 * 7;
														for (i = 0; i < 3 * N + 2 + Kougu + putting + Jigu; i++)
														{
															if (kumijun[a].tyukan == A_Objects[1][i].Id)
															{
																TyuPnum = i;
															}
															else if (kumijun[a + 1].tyukan == A_Objects[1][i].Id)
															{
																TyuPnum1 = i;
															}
														}
														if (A_Objects[0][TyuPnum].IchiX > A_Objects[0][TyuPnum1].IchiX)//右手左手でどの中間製品を扱うのかの判定
														{
															R_TyuPnum = TyuPnum;
															L_TyuPnum = TyuPnum1;
														}
														else
														{
															R_TyuPnum = TyuPnum1;
															L_TyuPnum = TyuPnum;
														}
													
													SType = hukusujig;
													Tnum++;
													Tnum++;
													movenum= Move_decision(kumigo_to_karioki, a + 1);//作成する状態から動作を決定
													Make_Joutai(a + 1, movenum);
													kumitatego_to_karioki(kari, a + 1, movenum);
													Count++;
													break;
												}
												
											}
										}
									}
									not_use_flag = 0;
								}
								else if ((kumijun[a + 2].scene_type != oya2ko2 && kumijun[a + 1].tyukan == kumijun[a + 2].oya)//現在の組付けが親2子2で次の組付けが親2子2でないとき、組立順序2行目の部品が親部品になっているとき(1行目の部品を用いないとき)
									|| (kumijun[a + 2].scene_type == oya2ko2 && kumijun[a + 1].tyukan == kumijun[a + 2].oya) || (kumijun[a + 2].scene_type == oya2ko2 && kumijun[a + 1].tyukan == kumijun[a + 3].oya))//現在の組付けが親2子2で次の組付けが親2子2のとき、組立順序2行目の組付けが次の組付けのどちらかの親部品になっている時
								{
									if (not_use_count > 0)
									{
										for (i = 0; i < not_use_count; i++)
										{
											if (kumijun[a].tyukan == not_use[i])
											{
												not_use_flag = 1;
												break;
											}
										}
									}
									if (not_use_flag == 1)//今後用いない中間製品であった時
									{
										//要検討
										kariokiflag = kariokiflag * 3 * 5;
										Make_karioki(a);
										movenum = Move_decision(kumigo_to_karioki, a);//作成する状態から動作を決定
										Make_Joutai(a, movenum);
										kumitatego_to_finish(kari, a, movenum);
										Tnum++;
										Count++;

									}
									else
									{
										if ((((kumijun[a + 2].scene_type != oya2ko2 && kumijun[a + 1].tyukan == kumijun[a + 2].oya) || (kumijun[a + 2].scene_type == oya2ko2 && kumijun[a + 1].tyukan == kumijun[a + 2].oya)) && kumijun[a + 1].jig == kumijun[a + 2].jig)
											|| (kumijun[a + 2].scene_type == oya2ko2 && kumijun[a + 1].tyukan == kumijun[a + 3].oya && kumijun[a + 1].jig == kumijun[a + 3].jig))//使用する治具が同じ時
										{
											kariokiflag = kariokiflag * 3 * 5;
											Make_karioki(a);
											movenum = Move_decision(kumigo_to_karioki, a);//作成する状態から動作を決定
											Make_Joutai(a, movenum);
											kumitatego_to_karioki(kari, a, movenum);
											Tnum++;
											Count++;
										}
										else
										{
											for (i = a + 2; i < gyousu - 1; i++)
											{
												if (kumijun[i].jig == kumijun[a].jig && kumijun[i].oya != kumijun[a].tyukan)//今回使用した治具と同じ治具を使用する組付けで今回できた中間製品と親部品が異なるときは仮置き
												{
													kariokiflag = kariokiflag * 3 * 5;
													Make_karioki(a);
													movenum= Move_decision(kumigo_to_karioki, a);//作成する状態から動作を決定
													Make_Joutai(a, movenum);
													kumitatego_to_karioki(kari, a, movenum);
													Tnum++;
													Count++;
													break;
												}
												else if (kumijun[i].oya == kumijun[a].tyukan || kumijun[i].ko == kumijun[a].tyukan)//今回使用した治具と同じ治具を使用する組付けで、今回できた中間製品と親部品が異なる組付けの前にその部品を用いる組付けがあるならばそのまま治具に付けておく
												{
													kariokiflag = kariokiflag * 3 * 7;
													//Make_karioki(a);//huruya
													if (kumijun[a].scene_type == oya2ko2)
													{
														for (i = 0; i < 3 * N + 2 + Kougu + putting + Jigu; i++)
														{
															if (kumijun[a].tyukan == A_Objects[1][i].Id)
															{
																TyuPnum = i;
															}
															else if (kumijun[a + 1].tyukan == A_Objects[1][i].Id)
															{
																TyuPnum1 = i;
															}
														}
														if (A_Objects[0][TyuPnum].IchiX > A_Objects[0][TyuPnum1].IchiX)//右手左手でどの中間製品を扱うのかの判定
														{
															R_TyuPnum = TyuPnum;
															L_TyuPnum = TyuPnum1;
														}
														else
														{
															R_TyuPnum = TyuPnum1;
															L_TyuPnum = TyuPnum;
														}
													}
													SType = hukusujig;
													Tnum++;
													Tnum++;
													movenum = Move_decision(kumigo_to_karioki, a);//作成する状態から動作を決定
													Make_Joutai(a, movenum);
													kumitatego_to_karioki(kari, a, movenum);
													Count++;
													break;
												}
											}
										}
									}
									kariokiflag = 1;
									not_use_flag = 0;
								}
							}
							
							else if ((kumijun[a].scene_type != oya2ko2 && kumijun[a].scene_type != oya1ko2 && kumijun[a].scene_type != oya2ko1 && kumijun[a + 1].scene_type != oya2ko2 && kumijun[a + 1].scene_type != oya2ko1 && (kumijun[a].scene_type !=tegumi&&kumijun[a].tyukan == kumijun[a + 1].ko))//現在の組付けが両手作業でなく、できた中間製品が子部品になるときかつ手組みではない時　古屋学会用 
								|| ((kumijun[a].scene_type == oya1ko2 || kumijun[a].scene_type == oya2ko1) && kumijun[a + 2].scene_type != oya2ko2 && kumijun[a + 2].scene_type != oya2ko1 && kumijun[a + 1].tyukan == kumijun[a + 2].ko))//現在の組付けが両手でできる中間製品が1つの時(親1子2または親2子1)で次の組立が親部品が2つ(親2子2、親2子1)でないとき、できた中間製品が子部品になる時
							{//出来た中間製品が次の組付けで子部品の時(できた中間製品が次の組立で子部品になるので保持しておく必要がある時に使う)
							
								if (kumijun[a].scene_type == oya1ko2 || kumijun[a].scene_type == oya2ko1)
								{

									Make_karioki(a + 1);
									movenum= Move_decision(kumigo_to_karioki2, a + 1);//作成する状態から動作を決定
									Make_Joutai(a + 1, movenum);
									kumitatego_to_karioki(kari, a + 1, movenum);
									Count++;
									//hoziflag = 1;
								}
								else
								{
									
									if (kumijun[a].jig == kumijun[a + 1].jig)
									{
										Make_karioki(a);
										movenum = Move_decision(kumigo_to_karioki2, a);//作成する状態から動作を決定
										Make_Joutai(a, movenum);
										kumitatego_to_karioki(kari, a, movenum);
										Count++;
										//hoziflag = 1;
									}
									else
									{
										//printf("%d\n", kumijun[a - 1].tyukan);
										//printf("d\n");
										SType = hukusujig;
										if (kumijun[a].kougu != kumijun[a + 1].kougu && kumijun[a].kougu != 0)//使用する工具が変更されている時、用いた工具を工具置き場に戻すので工具置き場の位置に合わせる
										{
											A_Objects[1][3 * N + 2 + putting + Jigu + KouguNum].IchiX = A_Kougus[KouguNum].IchiX;//工具の位置を工具置き場にする
											A_Objects[1][3 * N + 2 + putting + Jigu + KouguNum].IchiY = A_Kougus[KouguNum].IchiY;//工具の位置を工具置き場にする
											A_Objects[1][3 * N + 2 + putting + Jigu + KouguNum].IchiZ = A_Kougus[KouguNum].IchiZ;//工具の位置を工具置き場にする
										}
										movenum= Move_decision(kumigo_to_karioki, a);//作成する状態から動作を決定
										kumitatego_to_karioki(kari, a, movenum);
										Tnum++;
										Count++;
									}

									//Make_karioki(a);
									//movenum = Move_decision(kumigo_to_karioki2, a);//作成する状態から動作を決定
									//Make_Joutai(a, movenum);
									//kumitatego_to_karioki(kari, a, movenum);
									//hoziflag = 1;
								}

								//Make_hozi_move(kari, a);
							}
							else if ((kumijun[a].scene_type != oya2ko2 && kumijun[a].tyukan == kumijun[a + 1].oya && kumijun[a].jig != kumijun[a + 1].jig && a != gyousu - 1)//親部品は変わらないが使用する治具が変わる時
								|| (kumijun[a + 2].scene_type == oya1ko2 || kumijun[a + 2].scene_type == oya2ko1) && (kumijun[a].tyukan == kumijun[a + 2].oya || kumijun[a + 1].tyukan == kumijun[a + 2].oya) && (kumijun[a].tyukan == kumijun[a + 3].oya || kumijun[a + 1].tyukan == kumijun[a + 3].oya) && (kumijun[a].jig != kumijun[a + 2].jig || kumijun[a + 1].jig != kumijun[a + 2].jig) && (kumijun[a].jig != kumijun[a + 3].jig || kumijun[a + 1].jig != kumijun[a + 3].jig) && a + 1 != gyousu - 1)
							{
							
								if (kumijun[a].scene_type != tegumi)
								{
									SType = hukusujig;
									if (kumijun[a].kougu != kumijun[a + 1].kougu && kumijun[a].kougu != 0)//使用する工具が変更されている時、用いた工具を工具置き場に戻すので工具置き場の位置に合わせる
									{
										A_Objects[1][3 * N + 2 + putting + Jigu + KouguNum].IchiX = A_Kougus[KouguNum].IchiX;//工具の位置を工具置き場にする
										A_Objects[1][3 * N + 2 + putting + Jigu + KouguNum].IchiY = A_Kougus[KouguNum].IchiY;//工具の位置を工具置き場にする
										A_Objects[1][3 * N + 2 + putting + Jigu + KouguNum].IchiZ = A_Kougus[KouguNum].IchiZ;//工具の位置を工具置き場にする
									}
									movenum = Move_decision(kumigo_to_karioki, a);//作成する状態から動作を決定
									kumitatego_to_karioki(kari, a, movenum);
									Count++;
								}
							}
						
						if (kumijun[a].scene_type == oya1ko2 || kumijun[a].scene_type == oya2ko1 || kumijun[a].scene_type == oya2ko2)
						{
							a++;
						}
					}
					movenum = Move_decision(kumigo_to_saigo, a - 1);//作成する状態から動作を決定
					Make_Joutai(a - 1, movenum);
					Make_finish(a - 1);
					kumitatego_to_finish(kari, a - 1, movenum);
					Count++;
					//Make_kanseioki_move(kari, a-1);

					fclose(kari);

					Step = Num - 1;
					YStep = HNum;
					//if (hyoukamode != 1)
					{
						fp7 = fopen(fname, "w");
						WriteHeader(fp7);
						FileCopy(fp7);
						fclose(fp7);
					}
					//if (hyoukamode != 2)
					{
						fprintf(hyouka, "%d,%d,%d,%d,%.1lf,%.1lf,%.1lf,%d,%d,%.1lf,%.1lf\n", kumihead.KJnum, YStep, PreStep, YStep - PreStep, SKyori, MKyori, HKyori, Oyakaiten, Kaitenkaisu, Oyakaitenkakudo, Skakudo);
						hyoukacount++;
						if (hyoukacount == 1000000)//エクセルには読み込める上限があるので、今回は100万個順序の評価をしたら次のファイルに移す
						{
							fclose(hyouka);
							hyoukabangou++;
							hyoukacount = 0;
							sprintf(WkD, "%s_Hyouka%d.csv", outPath_Hyouka, hyoukabangou);
							hyouka = fopen(WkD, "w");
							if (hyouka == NULL) ShowFinMsg("評価のフルパスが不正です");

							fprintf(hyouka, "組立順序番号,ステップ数,事前ステップ,ステップ数−事前ステップ,手の総移動距離,右手の移動距離,左手の移動距離,親部品の回転回数,総回転回数,親部品の回転角度,総回転角度\n");
						}
					}
					printf("現在開いているファイル %s_網羅_動作付き組立順序%d.csv K %d\r", SEIHIN_Name, kumjunbangou, kumihead.KJnum);
					kari = fopen(inPath_VFDL_KARI, "w");

					Del_Com(temp);//csvファイルはデータごとにカンマがついた形で保存されているので、カンマを消す
					sscanf(temp, "%s%d%d%d", &kumihead.K, &kumihead.KJnum, &kumihead.flag, &kumihead.x);
					//printf("K %d\n",kumihead.KJnum);
					Reset();
					gyousu = 0;
					pre_count = 0;
					tantaibuhinsu = 0;
					not_use_count = 0;
				}
				else//読み込んだ行の中にKが入っていないとき(組立順序の行の途中の時)
				{
					//ファイルの読み込み
					Del_Com(temp);
					if (NewNOS0 == 0)
					{
						sscanf(temp, "%d%d%d%d%s%d%d%d%d", &kumijun[gyousu].kuminum, &kumijun[gyousu].oya, &kumijun[gyousu].ko, &kumijun[gyousu].tyukan, kumijun[gyousu].dir, &kumijun[gyousu].jig, &base, &kumijun[gyousu].scene_type, &kumijun[gyousu].kougu); //組付け番号、部品1、部品2、中間製品の読み込み
					}
					else
					{
						sscanf(temp, "%d%d%d%d%s%s%d%d%d", &kumijun[gyousu].kuminum, &kumijun[gyousu].oya, &kumijun[gyousu].ko, &kumijun[gyousu].tyukan, houkoukariX, houkoukariZ, &kumijun[gyousu].jig, &kumijun[gyousu].kougu, &kumijun[gyousu].scene_type); //組付け番号、部品1、部品2、中間製品の読み込み
						if (strstr(houkoukariX, "上") != NULL)
						{
							kumijun[gyousu].XLineDir = 0;
						}
						else if (strstr(houkoukariX, "下") != NULL)
						{
							kumijun[gyousu].XLineDir = 1;
						}
						else if (strstr(houkoukariX, "右") != NULL)
						{
							kumijun[gyousu].XLineDir = 2;
						}
						else if (strstr(houkoukariX, "左") != NULL)
						{
							kumijun[gyousu].XLineDir = 3;
						}
						else if (strstr(houkoukariX, "奥") != NULL)
						{
							kumijun[gyousu].XLineDir = 4;
						}
						else if (strstr(houkoukariX, "前") != NULL)
						{
							kumijun[gyousu].XLineDir = 5;
						}
						else if (strstr(houkoukariX, "D") != NULL)
						{
							kumijun[gyousu].XLineDir = -1;
						}

						if (strstr(houkoukariZ, "上") != NULL)
						{
							kumijun[gyousu].ZLineDir = 0;
						}
						else if (strstr(houkoukariZ, "下") != NULL)
						{
							kumijun[gyousu].ZLineDir = 1;
						}
						else if (strstr(houkoukariZ, "右") != NULL)
						{
							kumijun[gyousu].ZLineDir = 2;
						}
						else if (strstr(houkoukariZ, "左") != NULL)
						{
							kumijun[gyousu].ZLineDir = 3;
						}
						else if (strstr(houkoukariZ, "奥") != NULL)
						{
							kumijun[gyousu].ZLineDir = 4;
						}
						else if (strstr(houkoukariZ, "前") != NULL)
						{
							kumijun[gyousu].ZLineDir = 5;
						}
						else if (strstr(houkoukariZ, "D") != NULL)
						{
							kumijun[gyousu].ZLineDir = -1;
						}
					}
					if (kumijun[gyousu].scene_type == 0)//特に動作の指定がないときは片手の動作にする
					{
						kumijun[gyousu].scene_type = katate_migi;
					}

					//fprintf(fp2, "%d,%d,%d,%d,%s,%d,%d\n", kumijun[gyousu].kuminum, kumijun[gyousu].oya, kumijun[gyousu].ko, kumijun[gyousu].tyukan, kumijun[gyousu].dir, kumijun[gyousu].jig, kumijun[gyousu].base);
					gyousu++;//組立順序の行数を増やす


					//親部品または子部品が今までの組付けで作製された中間製品かどうかを判定
					for (i = 0; i < gyousu; i++)
					{
						if ((kumijun[gyousu - 1].ko > N0 && kumijun[gyousu - 1].ko == kumijun[i].tyukan) || kumijun[gyousu - 1].ko <= N0)//子部品が単体部品か中間製品で今までに組立られている時
						{
							pre_ko++;
						}
						if ((kumijun[gyousu - 1].oya > N0 && kumijun[gyousu - 1].oya == kumijun[i].tyukan) || kumijun[gyousu - 1].oya <= N0)//親部品が単体部品か中間製品で今までに組立られている時
						{
							pre_oya++;
						}
						if (pre_ko > 0 && pre_oya > 0)//親部品子部品共に単体部品か今までに組み立てられた中間製品であった時点でbreak
						{
							break;
						}
					}
					if (pre_ko == 0)//子部品が一度も作られていない中間製品の時
					{
						pre_assemble[pre_count] = kumijun[gyousu - 1].ko;
						pre_count++;
					}
					if (pre_oya == 0)//親部品が一度も作られていない中間製品の時
					{
						pre_assemble[pre_count] = kumijun[gyousu - 1].oya;
						pre_count++;
					}
					//単体部品の数を数える
					if (kumijun[gyousu - 1].ko <= N0)
					{
						tantaibuhinsu++;
					}
					if (kumijun[gyousu - 1].oya <= N0)
					{
						tantaibuhinsu++;
					}

					pre_ko = 0;
					pre_oya = 0;
				}
			}
			d++;
			if (d == 1) goto onemore;
			fclose(fp6);
		}
	}
	fclose(kari);
	//if (hyoukamode != 2)
	{
		fclose(hyouka);
	}
}

void FileCopy(FILE* fp3) {
	FILE* fp4;
	char temp[FGETS_MAX_LENGTH];


	/*if (RoopN == 1){
		if (fscanf(fp1, "%s", inPath_VFDL_KARI) == EOF) ShowFinMsg("VFDL(仮)が不正です");
	}*/
	if ((fp4 = fopen(inPath_VFDL_KARI, "r")) == NULL) {
		printf("\aコピー元ファイルをオープンできません。\n");
	}
	else {
		while (fgets(temp, FGETS_MAX_LENGTH, fp4) != NULL) {
			fputs(temp, fp3);
		}
	}

	fclose(fp4);

}

void MakingS0() {
	int i, j, h, k = 0, m = 0, flag = 0;
	int Jig = 0, L = 0;

	SType = 0;

	if (N > 0) {
		for (i = 0; i < N; i++) {//単体部品についての情報
			A_Objects[0][i].Id = A_Parts[i].Bnum;
			A_Objects[0][i].Flag = 1;//一人作業で最初に単部品のみのときという前提
			A_Objects[0][i].IchiX = A_Parts[i].IchiX;
			A_Objects[0][i].IchiY = A_Parts[i].IchiY;
			A_Objects[0][i].IchiZ = A_Parts[i].IchiZ;
			A_Objects[0][i].DirX = A_Parts[i].DirX;
			A_Objects[0][i].DirY = A_Parts[i].DirY;
			A_Objects[0][i].DirZ = A_Parts[i].DirZ;
		}
		//for (i = 0; i < N - 1; i++) {//中間製品についての情報
		for (i = 0; i < gyousu; i++) {//中間製品についての情報
			A_Objects[0][i + N].Id = kumijun[i].tyukan;
			A_Objects[0][i + N].Flag = 0;
			A_Objects[0][i + N].IchiX = 0;
			A_Objects[0][i + N].IchiY = 0;
			A_Objects[0][i + N].IchiZ = 0;
			A_Objects[0][i + N].DirX = 0;
			A_Objects[0][i + N].DirY = 0;
			A_Objects[0][i + N].DirZ = 0;
		}
		//予め中間製品を組立てなければいけない場合を追加 次の情報の始まりが部品数の2倍からになっているので特に変える必要なし
		if (pre_count > 0)
		{
			for (i = 0; i < pre_count; i++)
			{
				A_Objects[0][i + N + gyousu].Id = pre_assemble[i];
				A_Objects[0][i + N + gyousu].Flag = 1;
				A_Objects[0][i + N + gyousu].IchiX = 0;
				A_Objects[0][i + N + gyousu].IchiY = 0;
				A_Objects[0][i + N + gyousu].IchiZ = 0;
				A_Objects[0][i + N + gyousu].DirX = 0;
				A_Objects[0][i + N + gyousu].DirY = 0;
				A_Objects[0][i + N + gyousu].DirZ = 0;
			}
		}
	}

	for (i = 0; i < 2; i++) {//手の情報
		A_Objects[0][2 * N - 1 + i].Id = A_Hands[i].Hnum;
		A_Objects[0][2 * N - 1 + i].Flag = 1;
		A_Objects[0][2 * N - 1 + i].IchiX = A_Hands[i].IchiX;
		A_Objects[0][2 * N - 1 + i].IchiY = A_Hands[i].IchiY;
		A_Objects[0][2 * N - 1 + i].IchiZ = A_Hands[i].IchiZ;
		A_Objects[0][2 * N - 1 + i].DirX = A_Hands[i].DirX;
		A_Objects[0][2 * N - 1 + i].DirY = A_Hands[i].DirY;
		A_Objects[0][2 * N - 1 + i].DirZ = A_Hands[i].DirZ;
		//printf("2000");
	}

	for (i = 0; i < Bboxnum; i++) {//部品箱の情報
		A_Objects[0][2 * N + 1 + i].Id = A_Bboxs[i].Bnum;
		A_Objects[0][2 * N + 1 + i].Flag = 1;
		A_Objects[0][2 * N + 1 + i].IchiX = A_Bboxs[i].IchiX;
		A_Objects[0][2 * N + 1 + i].IchiY = A_Bboxs[i].IchiY;
		A_Objects[0][2 * N + 1 + i].IchiZ = A_Bboxs[i].IchiZ;
		A_Objects[0][2 * N + 1 + i].DirX = A_Bboxs[i].DirX;
		A_Objects[0][2 * N + 1 + i].DirY = A_Bboxs[i].DirY;
		A_Objects[0][2 * N + 1 + i].DirZ = A_Bboxs[i].DirZ;
	}

	//printf("2020");

	//for (i = 0; i < N - 2; i++) {
	for (i = 0; i < gyousu - 1; i++) {//仮置きの数
		if ((kumijun[i].tyukan != kumijun[i + 1].oya))
		{
			putting++;

		}
	}



	if (putting > 0) {
		if (Okihanashinum != 0) {//置き放しの指定があるとき
			if (A_Okishitei[0].Bnum != 0) {//置き放しの部品の指定があるとき時(出てくる順番に並べる)
				//for (j = 0; j < N - 2; j++) {
				for (j = 0; j < gyousu - 1; j++) {
					if ((kumijun[j].tyukan != kumijun[j + 1].oya)) {//置き放す中間製品を調べる
						h = 0;
						if ((kumijun[j].tyukan != kumijun[j + 1].ko)) {

							for (i = 0; i < Okihanashinum; i++) {//置き放しの場所と部品を指定している場合

								if (A_Okishitei[i].Bnum == kumijun[j].tyukan) {
									A_Objects[0][3 * N + 2 + k].Id = -400 - k;
									A_Objects[0][3 * N + 2 + k].Flag = 1;
									A_Objects[0][3 * N + 2 + k].IchiX = A_Okishitei[i].IchiX;
									A_Objects[0][3 * N + 2 + k].IchiY = A_Okishitei[i].IchiY;
									A_Objects[0][3 * N + 2 + k].IchiZ = A_Okishitei[i].IchiZ;
									A_Objects[0][3 * N + 2 + k].DirX = 0;
									A_Objects[0][3 * N + 2 + k].DirY = 0;
									A_Objects[0][3 * N + 2 + k].DirZ = 0;
									h = 1;
									k++;
								}
							}
							if (h == 0) {//置き放しの指定はしているものの、指定されてない部品があったとき
								for (m = 0; m < not_use_count; m++)//今後組立に使用しない部品かどうか調べる
								{
									if (kumijun[j].tyukan == not_use[m])//今後組立に使用しない部品だったとき
									{
										A_Objects[0][3 * N + 2 + k].Id = -400 - k;
										A_Objects[0][3 * N + 2 + k].Flag = 1;
										A_Objects[0][3 * N + 2 + k].IchiX = A_Bboxs[Bboxnum - 1].IchiX + A_Bboxs[Bboxnum - 1].SizeX / 2;
										A_Objects[0][3 * N + 2 + k].IchiY = A_Bboxs[Bboxnum - 1].IchiY + A_Bboxs[Bboxnum - 1].SizeY / 2;
										A_Objects[0][3 * N + 2 + k].IchiZ = A_Bboxs[Bboxnum - 1].IchiZ;
										A_Objects[0][3 * N + 2 + k].DirX = 0;
										A_Objects[0][3 * N + 2 + k].DirY = 0;
										A_Objects[0][3 * N + 2 + k].DirZ = 0;
										flag = 1;
										break;
									}
								}
								if (flag == 0)//今後組立に使用する部品であった時
								{
									A_Objects[0][3 * N + 2 + k].Id = -400 - k;
									A_Objects[0][3 * N + 2 + k].Flag = 1;
									A_Objects[0][3 * N + 2 + k].IchiX = 150 + (-1) * i * 50;
									A_Objects[0][3 * N + 2 + k].IchiY = 150;
									A_Objects[0][3 * N + 2 + k].IchiZ = 1040;
									A_Objects[0][3 * N + 2 + k].DirX = 0;
									A_Objects[0][3 * N + 2 + k].DirY = 0;
									A_Objects[0][3 * N + 2 + k].DirZ = 0;
								}

								flag = 0;
								k++;
							}
						}
						else {//NOSがない時の置き放す位置を指定する
							if (KOkihanashinum > 0) {//親子逆の時の置き放し指定があったとき
								i = 0;
								A_Objects[0][3 * N + 2 + k].Id = -400 - k;
								A_Objects[0][3 * N + 2 + k].Flag = 1;
								A_Objects[0][3 * N + 2 + k].IchiX = A_KOkishitei[i].IchiX;
								A_Objects[0][3 * N + 2 + k].IchiY = A_KOkishitei[i].IchiY;
								A_Objects[0][3 * N + 2 + k].IchiZ = A_KOkishitei[i].IchiZ;
								A_Objects[0][3 * N + 2 + k].DirX = 0;
								A_Objects[0][3 * N + 2 + k].DirY = 0;
								A_Objects[0][3 * N + 2 + k].DirZ = 0;
								k++;
							}
							else {//親子逆の時の置き放し指定がなかったとき

								if (NewNOS0 == 0)
								{
									Jig = kumijun[j + 1].jig - 1;
								}
								else
								{
									for (L = 0; L < Jigu; L++)
									{
										if (A_Objects[0][3 * N + 2 + L + putting].Id == kumijun[j + 1].jig)
										{
											Jig = L;
											break;
										}

									}
								}
								A_Objects[0][3 * N + 2 + k].Id = -400 - k;
								A_Objects[0][3 * N + 2 + k].Flag = 1;
								A_Objects[0][3 * N + 2 + k].IchiX = A_Jigus[Jig].H_IchiX - A_Jigus[Jig].SizeX / 2;//複数治具
								A_Objects[0][3 * N + 2 + k].IchiY = (A_Jigus[Jig].H_IchiY - A_Jigus[Jig].SizeY / 2) - 50;
								A_Objects[0][3 * N + 2 + k].IchiZ = A_Jigus[Jig].H_IchiZ - A_Jigus[Jig].SizeZ / 2;
								A_Objects[0][3 * N + 2 + k].DirX = 0;
								A_Objects[0][3 * N + 2 + k].DirY = 0;
								A_Objects[0][3 * N + 2 + k].DirZ = 0;
								k++;
							}

						}


					}
				}


			}
			else if (A_Okishitei[0].Bnum == 0) {//置き放しの部品の指定がないとき時
				//for (j = 0; j < N - 2; j++)
				for (j = 0; j < gyousu - 1; j++)
				{
					if ((kumijun[j].tyukan != kumijun[j + 1].oya) && (kumijun[j].tyukan != kumijun[j + 1].ko))
					{//純粋な置き放し
						for (m = 0; m < not_use_count; m++)//今後組立に使用しない部品かどうか調べる
						{
							if (kumijun[j].tyukan == not_use[m])//今後組立に使用しない部品だったとき
							{
								A_Objects[0][3 * N + 2 + k].Id = -400 - k;
								A_Objects[0][3 * N + 2 + k].Flag = 1;
								A_Objects[0][3 * N + 2 + k].IchiX = A_Bboxs[Bboxnum - 1].IchiX + A_Bboxs[Bboxnum - 1].SizeX / 2;
								A_Objects[0][3 * N + 2 + k].IchiY = A_Bboxs[Bboxnum - 1].IchiY + A_Bboxs[Bboxnum - 1].SizeY / 2;
								A_Objects[0][3 * N + 2 + k].IchiZ = A_Bboxs[Bboxnum - 1].IchiZ;
								A_Objects[0][3 * N + 2 + k].DirX = 0;
								A_Objects[0][3 * N + 2 + k].DirY = 0;
								A_Objects[0][3 * N + 2 + k].DirZ = 0;
								flag = 1;
								break;
							}
						}
						if (flag == 0)//今後組立に使用する部品であった時
						{
							A_Objects[0][3 * N + 2 + k].Id = -400 - k;
							A_Objects[0][3 * N + 2 + k].Flag = 1;
							A_Objects[0][3 * N + 2 + k].IchiX = A_Okishitei[i].IchiX;
							A_Objects[0][3 * N + 2 + k].IchiY = A_Okishitei[i].IchiY;
							A_Objects[0][3 * N + 2 + k].IchiZ = A_Okishitei[i].IchiZ;
							A_Objects[0][3 * N + 2 + k].DirX = 0;
							A_Objects[0][3 * N + 2 + k].DirY = 0;
							A_Objects[0][3 * N + 2 + k].DirZ = 0;
						}
						flag = 0;
						k++;
					}
					else if ((kumijun[j].tyukan != kumijun[j + 1].oya)) {//親子が逆になっているときのやつ
						if (KOkihanashinum > 0) {//親子逆の時の置き放し指定があったとき
							i = 0;
							A_Objects[0][3 * N + 2 + k].Id = -400 - k;
							A_Objects[0][3 * N + 2 + k].Flag = 1;
							A_Objects[0][3 * N + 2 + k].IchiX = A_KOkishitei[i].IchiX;
							A_Objects[0][3 * N + 2 + k].IchiY = A_KOkishitei[i].IchiY;
							A_Objects[0][3 * N + 2 + k].IchiZ = A_KOkishitei[i].IchiZ;
							A_Objects[0][3 * N + 2 + k].DirX = 0;
							A_Objects[0][3 * N + 2 + k].DirY = 0;
							A_Objects[0][3 * N + 2 + k].DirZ = 0;
							k++;
						}
						else {//親子逆の時の置き放し指定がなかったとき
							if (NewNOS0 == 0)
							{
								Jig = kumijun[j + 1].jig - 1;
							}
							else
							{
								for (L = 0; L < Jigu; L++)
								{
									if (A_Objects[0][3 * N + 2 + L + putting].Id == kumijun[j + 1].jig)
									{
										Jig = L;
										break;
									}

								}
							}
							A_Objects[0][3 * N + 2 + k].Id = -400 - k;
							A_Objects[0][3 * N + 2 + k].Flag = 1;
							A_Objects[0][3 * N + 2 + k].IchiX = A_Jigus[Jig].H_IchiX - A_Jigus[Jig].SizeX / 2;//複数治具
							A_Objects[0][3 * N + 2 + k].IchiY = (A_Jigus[Jig].H_IchiY - A_Jigus[Jig].SizeY / 2) - 50;
							A_Objects[0][3 * N + 2 + k].IchiZ = A_Jigus[Jig].H_IchiZ - A_Jigus[Jig].SizeZ / 2;
							A_Objects[0][3 * N + 2 + k].DirX = 0;
							A_Objects[0][3 * N + 2 + k].DirY = 0;
							A_Objects[0][3 * N + 2 + k].DirZ = 0;
							k++;
						}
					}
				}


			}

		}
		else {//置き放しに全く指定がないとき
			//for (j = 0; j < N - 2; j++)
			for (j = 0; j < gyousu - 1; j++) {

				if ((kumijun[j].tyukan != kumijun[j + 1].oya) && (kumijun[j].tyukan != kumijun[j + 1].ko))
				{
					for (m = 0; m < not_use_count; m++)//今後組立に使用しない部品かどうか調べる
					{
						if (kumijun[j].tyukan == not_use[m])//今後組立に使用しない部品だったとき
						{
							A_Objects[0][3 * N + 2 + k].Id = -400 - k;
							A_Objects[0][3 * N + 2 + k].Flag = 1;
							A_Objects[0][3 * N + 2 + k].IchiX = A_Bboxs[Bboxnum - 1].IchiX + A_Bboxs[Bboxnum - 1].SizeX / 2;
							A_Objects[0][3 * N + 2 + k].IchiY = A_Bboxs[Bboxnum - 1].IchiY + A_Bboxs[Bboxnum - 1].SizeY / 2;
							A_Objects[0][3 * N + 2 + k].IchiZ = A_Bboxs[Bboxnum - 1].IchiZ;
							A_Objects[0][3 * N + 2 + k].DirX = 0;
							A_Objects[0][3 * N + 2 + k].DirY = 0;
							A_Objects[0][3 * N + 2 + k].DirZ = 0;
							flag = 1;
							break;
						}
					}
					if (flag == 0)//今後組立に使用する部品であった時
					{
						A_Objects[0][3 * N + 2 + k].Id = -400 - k;
						A_Objects[0][3 * N + 2 + k].Flag = 1;
						A_Objects[0][3 * N + 2 + k].IchiX = 150;
						A_Objects[0][3 * N + 2 + k].IchiY = 150;
						A_Objects[0][3 * N + 2 + k].IchiZ = 1040;
						A_Objects[0][3 * N + 2 + k].DirX = 0;
						A_Objects[0][3 * N + 2 + k].DirY = 0;
						A_Objects[0][3 * N + 2 + k].DirZ = 0;
					}
					flag = 0;
					k++;
				}
				else if ((kumijun[j].tyukan != kumijun[j + 1].oya)) {//親子が逆のやつ
					if (KOkihanashinum > 0) {//親子逆の時の置き放し指定があったとき
						i = 0;
						A_Objects[0][3 * N + 2 + k].Id = -400 - k;
						A_Objects[0][3 * N + 2 + k].Flag = 1;
						A_Objects[0][3 * N + 2 + k].IchiX = A_KOkishitei[i].IchiX;
						A_Objects[0][3 * N + 2 + k].IchiY = A_KOkishitei[i].IchiY;
						A_Objects[0][3 * N + 2 + k].IchiZ = A_KOkishitei[i].IchiZ;
						A_Objects[0][3 * N + 2 + k].DirX = 0;
						A_Objects[0][3 * N + 2 + k].DirY = 0;
						A_Objects[0][3 * N + 2 + k].DirZ = 0;
						k++;
					}
					else {//親子逆の時の置き放し指定がなかったとき
						if (NewNOS0 == 0)
						{
							Jig = kumijun[j + 1].jig - 1;
						}
						else
						{
							for (L = 0; L < Jigu; L++)
							{
								if (A_Objects[0][3 * N + 2 + L + putting].Id == kumijun[j + 1].jig)
								{
									Jig = L;
									break;
								}

							}
						}
						A_Objects[0][3 * N + 2 + k].Id = -400 - k;
						A_Objects[0][3 * N + 2 + k].Flag = 1;
						A_Objects[0][3 * N + 2 + k].IchiX = A_Jigus[Jig].H_IchiX - A_Jigus[Jig].SizeX / 2;//複数治具
						A_Objects[0][3 * N + 2 + k].IchiY = (A_Jigus[Jig].H_IchiY - A_Jigus[Jig].SizeY / 2) - 50;
						A_Objects[0][3 * N + 2 + k].IchiZ = A_Jigus[Jig].H_IchiZ - A_Jigus[Jig].SizeZ / 2;
						A_Objects[0][3 * N + 2 + k].DirX = 0;
						A_Objects[0][3 * N + 2 + k].DirY = 0;
						A_Objects[0][3 * N + 2 + k].DirZ = 0;
						k++;
					}
				}
			}

		}

	}




	if (Jigu > 0) {
		for (i = 0; i < Jigu; i++) {
			A_Objects[0][3 * N + 2 + i + putting].Id = A_Jigus[i].Jnum;
			A_Objects[0][3 * N + 2 + i + putting].Flag = 1;
			A_Objects[0][3 * N + 2 + i + putting].IchiX = A_Jigus[i].H_IchiX - A_Jigus[i].SizeX / 2;
			A_Objects[0][3 * N + 2 + i + putting].IchiY = A_Jigus[i].H_IchiY - A_Jigus[i].SizeY / 2;
			A_Objects[0][3 * N + 2 + i + putting].IchiZ = A_Jigus[i].H_IchiZ + A_Jigus[i].SizeZ / 2;
			A_Objects[0][3 * N + 2 + i + putting].DirX = A_Jigus[i].DirX;
			A_Objects[0][3 * N + 2 + i + putting].DirY = A_Jigus[i].DirY;
			A_Objects[0][3 * N + 2 + i + putting].DirZ = A_Jigus[i].DirZ;
		}
	}

	if (Kougu > 0) {
		for (i = 0; i < Kougu; i++) {
			A_Objects[0][3 * N + 2 + i + putting + Jigu].Id = A_Kougus[i].Bnum;
			A_Objects[0][3 * N + 2 + i + putting + Jigu].Flag = 1;
			A_Objects[0][3 * N + 2 + i + putting + Jigu].IchiX = A_Kougus[i].IchiX;
			A_Objects[0][3 * N + 2 + i + putting + Jigu].IchiY = A_Kougus[i].IchiY;
			A_Objects[0][3 * N + 2 + i + putting + Jigu].IchiZ = A_Kougus[i].IchiZ;
			A_Objects[0][3 * N + 2 + i + putting + Jigu].DirX = A_Kougus[i].DirX;
			A_Objects[0][3 * N + 2 + i + putting + Jigu].DirY = A_Kougus[i].DirY;
			A_Objects[0][3 * N + 2 + i + putting + Jigu].DirZ = A_Kougus[i].DirZ;
		}
	}


	for (i = 0; i < 2; i++) {
		A_Supports[0][i].Id = A_Hands[i].Hnum;
		A_Supports[0][i].Flag = 0;
		A_Supports[0][i].PId[0] = 0;
		A_Supports[0][i].Length = 0;
	}

	//for (i = 0; i < N; i++) //部品箱の支えの関係を作成(部品箱には初めに部品が入っているためフラグを1にする)
	for (i = 0; i < tantaibuhinsu + pre_count; i++) //部品箱の支えの関係を作成(部品箱には初めに部品が入っているためフラグを1にする)
	{
		A_Supports[0][i + 2].Id = A_Bboxs[i].Bnum;
		A_Supports[0][i + 2].Flag = 1;
		A_Supports[0][i + 2].PId[0] = A_Parts[i].Bnum;
		A_Supports[0][i + 2].Length = 1;
	}
	//完成品置き場の作成
	A_Supports[0][2 + tantaibuhinsu + pre_count].Id = A_Bboxs[gyousu + 1].Bnum;
	A_Supports[0][2 + tantaibuhinsu + pre_count].Flag = 0;
	A_Supports[0][2 + tantaibuhinsu + pre_count].PId[0] = 0;
	A_Supports[0][2 + tantaibuhinsu + pre_count].Length = 0;
	/*A_Supports[0][2 + N].Id = A_Bboxs[N].Bnum;
	A_Supports[0][2 + N].Flag = 0;
	A_Supports[0][2 + N].PId = 0;*/


	if (putting > 0)//仮置き場の作成
	{
		for (i = 0; i < putting; i++) {
			A_Supports[0][i + N + 3].Id = A_Objects[0][3 * N + 2 + i].Id;
			A_Supports[0][i + N + 3].Flag = 0;
			A_Supports[0][i + N + 3].PId[0] = 0;
			A_Supports[0][i + N + 3].Length = 0;
		}
	}

	if (Jigu > 0) {
		for (i = 0; i < Jigu; i++) {
			A_Supports[0][i + N + 3 + putting].Id = A_Jigus[i].Jnum;
			A_Supports[0][i + N + 3 + putting].Flag = 0;
			A_Supports[0][i + N + 3 + putting].PId[0] = 0;
			A_Supports[0][i + N + 3 + putting].Length = 0;
		}
	}

	if (Kougu > 0) {
		for (i = 0; i < Kougu; i++) {
			A_Supports[0][i + N + 3 + putting + Jigu].Id = A_Kougus[i].Bnum;
			A_Supports[0][i + N + 3 + putting + Jigu].Flag = 0;
			A_Supports[0][i + N + 3 + putting + Jigu].PId[0] = 0;
			A_Supports[0][i + N + 3 + putting + Jigu].Length = 0;
		}
	}

	/*printf("\n\n");
	for (i = 0; i <3 * N + 2 + putting + Jigu + Kougu; i++){
		printf("%d,%d,%4.2lf,%4.2lf,%4.2lf,%d,%d,%d\n", A_Objects[0][i].Id, A_Objects[0][i].Flag, A_Objects[0][i].IchiX, A_Objects[0][i].IchiY, A_Objects[0][i].IchiZ, A_Objects[0][i].DirX, A_Objects[0][i].DirY, A_Objects[0][i].DirZ);
	}



	for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++){
		printf("%d,%d,%d\n", A_Supports[0][i].Id, A_Supports[0][i].Flag, A_Supports[0][i].PId);
	}*/
}

void Read_movement()
{
	FILE* fp1;
	char* temp, b[50], * si;
	int  i = 0, g = 0, j = 0, count = 0, k = 0, coord = 0/*追加の座標を読み込むときに使う*/, a = 0, end = 0, loop = 0, judge_turn = 1;//turnが1ならばいつでも行う動作-1ならば回転が必要な時だけ必要な動作

	temp = (char*)malloc(FGETS_MAX_LENGTH);

	fp1 = fopen(movement, "r");
	if (fp1 == NULL) ShowFinMsg("変化のパターンリストが不正です");


	while (fgets(temp, FGETS_MAX_LENGTH, fp1) != NULL)//データの最後まで読み込み
	{
		Del_Com(temp);//カンマを消す
		if (strstr(temp, "動作番号") != NULL)//読み込んだcsvファイルの一行に"動作番号"の文字が含まれていたら
		{
			dousasu++;//動作番号0は何もしない動作とする

			loop++;
			si = temp;
			while ((si = strchr(&si[1], ' ')) != NULL)
			{
				if (j == 0)
				{
					//sscanf(si, "%d", &M_pattern[dousasu].num);//動作番号の読み取り
					sscanf(si, "%d", &g);//動作番号の読み取り
					M_pattern[dousasu].num = loop;
				}
				j++;
			}
			j = 0;
		}
		else if (strstr(temp, "右手") != NULL)
		{
			si = temp;
			count = 0;
			while (end != 1)
			{
				if (si[i] == ' ' || si[i] == '\0')
				{
					strncpy(b, si, i); // 空白の前までの文字列をbに移す
					b[i] = '\0';
					if (si[i] != '\0')//読み込みの最後ではないとき
					{
						si = si + i + 1;//空白の後ろからのポインタ(文字列)をsiに保存
					}
					else
					{
						end = 1;
					}

					//作業を行う対象物の読み込み
					M_pattern[dousasu].Move[migite][count][target] = none;
					if (strstr(b, "子部品1") != NULL)//対象物が子部品の場合
					{
						M_pattern[dousasu].Move[migite][count][target] = Ko1;
					}
					else if (strstr(b, "中間製品1") != NULL)
					{
						M_pattern[dousasu].Move[migite][count][target] = Tyukan1;
					}
					else if (strstr(b, "親部品1") != NULL)
					{
						M_pattern[dousasu].Move[migite][count][target] = Oya1;
					}
					else if (strstr(b, "子部品2") != NULL)//対象物が子部品の場合
					{
						M_pattern[dousasu].Move[migite][count][target] = Ko2;
					}
					else if (strstr(b, "中間製品2") != NULL)
					{
						M_pattern[dousasu].Move[migite][count][target] = Tyukan2;
					}
					else if (strstr(b, "親部品2") != NULL)
					{
						M_pattern[dousasu].Move[migite][count][target] = Oya2;
					}
					else if (strstr(b, "子") != NULL)//対象物が子部品の場合
					{
						M_pattern[dousasu].Move[migite][count][target] = Ko;
					}
					else if (strstr(b, "中間") != NULL)
					{
						M_pattern[dousasu].Move[migite][count][target] = Tyukan;
					}
					else if (strstr(b, "親") != NULL)
					{
						M_pattern[dousasu].Move[migite][count][target] = Oya;
					}
					else if (strstr(b, "初期位置") != NULL)
					{
						M_pattern[dousasu].Move[migite][count][target] = Start_P;
					}
					else if (strstr(b, "交換する工具") != NULL)
					{
						M_pattern[dousasu].Move[migite][count][target] = ChangeKOUGU;
					}
					else if (strstr(b, "工具") != NULL)
					{
						M_pattern[dousasu].Move[migite][count][target] = KOUGU;
					}
					else if (strstr(b, "元") != NULL)
					{
						M_pattern[dousasu].Move[migite][count][target] = Original_P;
					}

					//対象物の目的地の読み取り
					if (strstr(b, "治具に") != NULL || strstr(b, "治具から") != NULL)
					{
						M_pattern[dousasu].Move[migite][count][destination] = JIG;
					}
					else if (strstr(b, "交換する工具に") != NULL || strstr(b, "交換する工具から") != NULL)
					{
						M_pattern[dousasu].Move[migite][count][destination] = ChangeKOUGU;
					}
					else if (strstr(b, "工具に") != NULL || strstr(b, "工具から") != NULL)
					{
						M_pattern[dousasu].Move[migite][count][destination] = KOUGU;
					}

					if (strstr(b, "*") != NULL)
					{
						judge_turn = -1;
					}
					else
					{
						judge_turn = 1;
					}

					M_pattern[dousasu].Move[migite][count][move] = none;
					if (strstr(b, "伸ばす追加") != NULL)
					{
						M_pattern[dousasu].Move[migite][count][move] = nobasu_tsuika * judge_turn;

						sscanf(si, "%lf%lf%lf", &M_pattern[dousasu].Move_addition[migite][count][addition1], &M_pattern[dousasu].Move_addition[migite][count][addition2], &M_pattern[dousasu].Move_addition[migite][count][addition3]);
						//printf("%lf %lf %lf\n", M_pattern[dousasu]. Move[migite][count][addition1], M_pattern[dousasu]. Move[migite][count][addition2], M_pattern[dousasu]. Move[migite][count][addition3]);
						while ((si = strchr(&si[1], ' ')) != NULL)//座標を読み込んだ分の文字をsiから消す
						{
							//puts(si);
							//sscanf(si, "%lf", &M_pattern[dousasu]. Move[migite][count][coord]);
							coord++;
							if (coord == 3)
							{
								coord = 0;
								break;
							}
						}

						//printf("%lf %lf %lf\n", M_pattern[dousasu]. Move[migite][count][addition1], M_pattern[dousasu]. Move[migite][count][addition2], M_pattern[dousasu]. Move[migite][count][addition3]);
						si = si + 1;
						//puts(si);

						count++;
					}
					else if (strstr(b, "運ぶ追加") != NULL)
					{
						M_pattern[dousasu].Move[migite][count][move] = hakobu_tsuika * judge_turn;

						sscanf(si, "%lf%lf%lf", &M_pattern[dousasu].Move_addition[migite][count][addition1], &M_pattern[dousasu].Move_addition[migite][count][addition2], &M_pattern[dousasu].Move_addition[migite][count][addition3]);
						//printf("%lf %lf %lf\n", M_pattern[dousasu]. Move[migite][count][addition1], M_pattern[dousasu]. Move[migite][count][addition2], M_pattern[dousasu]. Move[migite][count][addition3]);
						while ((si = strchr(&si[1], ' ')) != NULL)//座標を読み込んだ分の文字をsiから消す
						{
							//puts(si);
							//sscanf(si, "%lf", &M_pattern[dousasu]. Move[migite][count][coord]);
							coord++;
							if (coord == 3)
							{
								coord = 0;
								break;
							}
						}

						//printf("%lf %lf %lf\n", M_pattern[dousasu]. Move[migite][count][addition1], M_pattern[dousasu]. Move[migite][count][addition2], M_pattern[dousasu]. Move[migite][count][addition3]);
						si = si + 1;

						count++;
					}
					else if (strstr(b, "持ち直す追加") != NULL)
					{
						M_pattern[dousasu].Move[migite][count][move] = motinaosu_tsuika * judge_turn;

						sscanf(si, "%lf%lf%lf", &M_pattern[dousasu].Move_addition[migite][count][addition1], &M_pattern[dousasu].Move_addition[migite][count][addition2], &M_pattern[dousasu].Move_addition[migite][count][addition3]);
						//printf("%lf %lf %lf\n", M_pattern[dousasu]. Move[migite][count][addition1], M_pattern[dousasu]. Move[migite][count][addition2], M_pattern[dousasu]. Move[migite][count][addition3]);
						while ((si = strchr(&si[1], ' ')) != NULL)//座標を読み込んだ分の文字をsiから消す
						{
							//puts(si);
							//sscanf(si, "%lf", &M_pattern[dousasu]. Move[migite][count][coord]);
							coord++;
							if (coord == 3)
							{
								coord = 0;
								break;
							}
						}

						//printf("%lf %lf %lf\n", M_pattern[dousasu]. Move[migite][count][addition1], M_pattern[dousasu]. Move[migite][count][addition2], M_pattern[dousasu]. Move[migite][count][addition3]);
						si = si + 1;

						count++;
					}
					else if (strstr(b, "伸ばす") != NULL)
					{
						M_pattern[dousasu].Move[migite][count][move] = nobasu * judge_turn;
						count++;
					}
					else if (strstr(b, "掴み取る") != NULL)
					{
						M_pattern[dousasu].Move[migite][count][move] = tsukamitoru * judge_turn;
						count++;
					}
					else if (strstr(b, "運ぶ") != NULL)
					{
						M_pattern[dousasu].Move[migite][count][move] = hakobu * judge_turn;
						count++;
					}
					else if (strstr(b, "組立移動") != NULL)
					{
						M_pattern[dousasu].Move[migite][count][move] = kumitateidou * judge_turn;
						count++;
					}
					else if (strstr(b, "組立てる") != NULL)
					{
						M_pattern[dousasu].Move[migite][count][move] = kumitateru * judge_turn;
						count++;
					}
					else if (strstr(b, "持ち直す") != NULL)
					{
						M_pattern[dousasu].Move[migite][count][move] = motinaosu * judge_turn;
						count++;
					}
					else if (strstr(b, "付ける") != NULL)
					{
						M_pattern[dousasu].Move[migite][count][move] = tsukeru * judge_turn;
						count++;
					}
					else if (strstr(b, "置き放す") != NULL)
					{
						M_pattern[dousasu].Move[migite][count][move] = okihanasu * judge_turn;
						count++;
					}
					else if (strstr(b, "放す") != NULL)
					{
						M_pattern[dousasu].Move[migite][count][move] = hanasu * judge_turn;
						count++;
					}
					else if (strstr(b, "外す") != NULL)
					{
						M_pattern[dousasu].Move[migite][count][move] = hazusu * judge_turn;
						count++;
					}
					else if (strstr(b, "掴む") != NULL)
					{
						M_pattern[dousasu].Move[migite][count][move] = tsukamu * judge_turn;
						count++;
					}
					else if (strstr(b, "先端") != NULL)
					{
						M_pattern[dousasu].Move[migite][count][move] = sentanhenkou;
						count++;
					}
					else if (strstr(b, "N") != NULL)
					{
						M_pattern[dousasu].Move[migite][count][move] = none;
						count++;
					}
					for (k = 0; k < 50; k++)
					{
						b[k] = '\0';//bをナル文字で初期化
					}
					i = 0;
				}
				i++;
			}

			M_pattern[dousasu].length[migite] = count;//親部品を組み付ける際の動作の数を記録
			end = 0;
		}
		else if (strstr(temp, "左手") != NULL)
		{
			si = temp;
			count = 0;
			while (end != 1)
			{
				if (si[i] == ' ' || si[i] == '\0')
				{
					strncpy(b, si, i); // 空白の前までの文字列をbに移す
					b[i] = '\0';
					if (si[i] != '\0')//読み込みの最後ではないとき
					{
						si = si + i + 1;//空白の後ろからのポインタ(文字列)をsiに保存
					}
					else
					{
						end = 1;
					}

					//作業を行う対象物の読み込み
					M_pattern[dousasu].Move[hidarite][count][target] = none;
					if (strstr(b, "子部品1") != NULL)//対象物が子部品の場合
					{
						M_pattern[dousasu].Move[hidarite][count][target] = Ko1;
					}
					else if (strstr(b, "中間製品1") != NULL)
					{
						M_pattern[dousasu].Move[hidarite][count][target] = Tyukan1;
					}
					else if (strstr(b, "親部品1") != NULL)
					{
						M_pattern[dousasu].Move[hidarite][count][target] = Oya1;
					}
					else if (strstr(b, "子部品2") != NULL)//対象物が子部品の場合
					{
						M_pattern[dousasu].Move[hidarite][count][target] = Ko2;
					}
					else if (strstr(b, "中間製品2") != NULL)
					{
						M_pattern[dousasu].Move[hidarite][count][target] = Tyukan2;
					}
					else if (strstr(b, "親部品2") != NULL)
					{
						M_pattern[dousasu].Move[hidarite][count][target] = Oya2;
					}
					else if (strstr(b, "子") != NULL)//対象物が子部品の場合
					{
						M_pattern[dousasu].Move[hidarite][count][target] = Ko;
					}
					else if (strstr(b, "中間") != NULL)
					{
						M_pattern[dousasu].Move[hidarite][count][target] = Tyukan;
					}
					else if (strstr(b, "親") != NULL)
					{
						M_pattern[dousasu].Move[hidarite][count][target] = Oya;
					}
					else if (strstr(b, "初期位置") != NULL)
					{
						M_pattern[dousasu].Move[hidarite][count][target] = Start_P;
					}
					else if (strstr(b, "交換する工具") != NULL)
					{
						M_pattern[dousasu].Move[hidarite][count][target] = ChangeKOUGU;
					}
					else if (strstr(b, "工具") != NULL)
					{
						M_pattern[dousasu].Move[hidarite][count][target] = KOUGU;
					}
					else if (strstr(b, "元") != NULL)
					{
						M_pattern[dousasu].Move[hidarite][count][target] = Original_P;
					}

					//対象物の目的地の読み取り
					if (strstr(b, "治具に") != NULL)
					{
						M_pattern[dousasu].Move[hidarite][count][destination] = JIG;
					}
					else if (strstr(b, "交換する工具に") != NULL || strstr(b, "交換する工具から") != NULL)
					{
						M_pattern[dousasu].Move[hidarite][count][destination] = ChangeKOUGU;
					}
					else if (strstr(b, "工具に") != NULL)
					{
						M_pattern[dousasu].Move[hidarite][count][destination] = KOUGU;
					}

					if (strstr(b, "*") != NULL)
					{
						judge_turn = -1;
					}
					else
					{
						judge_turn = 1;
					}

					M_pattern[dousasu].Move[hidarite][count][move] = none;
					if (strstr(b, "伸ばす追加") != NULL)
					{
						M_pattern[dousasu].Move[hidarite][count][move] = nobasu_tsuika * judge_turn;

						sscanf(si, "%lf%lf%lf", &M_pattern[dousasu].Move_addition[hidarite][count][addition1], &M_pattern[dousasu].Move_addition[hidarite][count][addition2], &M_pattern[dousasu].Move_addition[hidarite][count][addition3]);
						//printf("%lf %lf %lf\n", M_pattern[dousasu]. Move[hidarite][count][addition1], M_pattern[dousasu]. Move[hidarite][count][addition2], M_pattern[dousasu]. Move[hidarite][count][addition3]);
						while ((si = strchr(&si[1], ' ')) != NULL)//座標を読み込んだ分の文字をsiから消す
						{
							//puts(si);
							//sscanf(si, "%lf", &M_pattern[dousasu]. Move[hidarite][count][coord]);
							coord++;
							if (coord == 3)
							{
								coord = 0;
								break;
							}
						}

						//printf("%lf %lf %lf\n", M_pattern[dousasu]. Move[hidarite][count][addition1], M_pattern[dousasu]. Move[hidarite][count][addition2], M_pattern[dousasu]. Move[hidarite][count][addition3]);
						si = si + 1;
						//puts(si);

						count++;
					}
					else if (strstr(b, "運ぶ追加") != NULL)
					{
						M_pattern[dousasu].Move[hidarite][count][move] = hakobu_tsuika * judge_turn;

						sscanf(si, "%lf%lf%lf", &M_pattern[dousasu].Move_addition[hidarite][count][addition1], &M_pattern[dousasu].Move_addition[hidarite][count][addition2], &M_pattern[dousasu].Move_addition[hidarite][count][addition3]);
						//printf("%lf %lf %lf\n", M_pattern[dousasu]. Move[hidarite][count][addition1], M_pattern[dousasu]. Move[hidarite][count][addition2], M_pattern[dousasu]. Move[hidarite][count][addition3]);
						while ((si = strchr(&si[1], ' ')) != NULL)//座標を読み込んだ分の文字をsiから消す
						{
							//puts(si);
							//sscanf(si, "%lf", &M_pattern[dousasu]. Move[hidarite][count][coord]);
							coord++;
							if (coord == 3)
							{
								coord = 0;
								break;
							}
						}

						//printf("%lf %lf %lf\n", M_pattern[dousasu]. Move[hidarite][count][addition1], M_pattern[dousasu]. Move[hidarite][count][addition2], M_pattern[dousasu]. Move[hidarite][count][addition3]);
						si = si + 1;

						count++;
					}
					else if (strstr(b, "持ち直す追加") != NULL)
					{
						M_pattern[dousasu].Move[hidarite][count][move] = motinaosu_tsuika * judge_turn;

						sscanf(si, "%lf%lf%lf", &M_pattern[dousasu].Move_addition[hidarite][count][addition1], &M_pattern[dousasu].Move_addition[hidarite][count][addition2], &M_pattern[dousasu].Move_addition[hidarite][count][addition3]);
						//printf("%lf %lf %lf\n", M_pattern[dousasu]. Move[hidarite][count][addition1], M_pattern[dousasu]. Move[hidarite][count][addition2], M_pattern[dousasu]. Move[hidarite][count][addition3]);
						while ((si = strchr(&si[1], ' ')) != NULL)//座標を読み込んだ分の文字をsiから消す
						{
							//puts(si);
							//sscanf(si, "%lf", &M_pattern[dousasu]. Move[hidarite][count][coord]);
							coord++;
							if (coord == 3)
							{
								coord = 0;
								break;
							}
						}

						//printf("%lf %lf %lf\n", M_pattern[dousasu]. Move[hidarite][count][addition1], M_pattern[dousasu]. Move[hidarite][count][addition2], M_pattern[dousasu]. Move[hidarite][count][addition3]);
						si = si + 1;

						count++;
					}
					else if (strstr(b, "伸ばす") != NULL)
					{
						M_pattern[dousasu].Move[hidarite][count][move] = nobasu * judge_turn;
						count++;
					}
					else if (strstr(b, "掴み取る") != NULL)
					{
						M_pattern[dousasu].Move[hidarite][count][move] = tsukamitoru * judge_turn;
						count++;
					}
					else if (strstr(b, "運ぶ") != NULL)
					{
						M_pattern[dousasu].Move[hidarite][count][move] = hakobu * judge_turn;
						count++;
					}
					else if (strstr(b, "組立移動") != NULL)
					{
						M_pattern[dousasu].Move[hidarite][count][move] = kumitateidou * judge_turn;
						count++;
					}
					else if (strstr(b, "組立てる") != NULL)
					{
						M_pattern[dousasu].Move[hidarite][count][move] = kumitateru * judge_turn;
						count++;
					}
					else if (strstr(b, "持ち直す") != NULL)
					{
						M_pattern[dousasu].Move[hidarite][count][move] = motinaosu * judge_turn;
						count++;
					}
					else if (strstr(b, "付ける") != NULL)
					{
						M_pattern[dousasu].Move[hidarite][count][move] = tsukeru * judge_turn;
						count++;
					}
					else if (strstr(b, "置き放す") != NULL)
					{
						M_pattern[dousasu].Move[hidarite][count][move] = okihanasu * judge_turn;
						count++;
					}
					else if (strstr(b, "放す") != NULL)
					{
						M_pattern[dousasu].Move[hidarite][count][move] = hanasu * judge_turn;
						count++;
					}
					else if (strstr(b, "外す") != NULL)
					{
						M_pattern[dousasu].Move[hidarite][count][move] = hazusu * judge_turn;
						count++;
					}
					else if (strstr(b, "掴む") != NULL)
					{
						M_pattern[dousasu].Move[hidarite][count][move] = tsukamu * judge_turn;
						count++;
					}
					else if (strstr(b, "先端") != NULL)
					{
						M_pattern[dousasu].Move[hidarite][count][move] = sentanhenkou;
						count++;
					}
					else if (strstr(b, "N") != NULL)
					{
						M_pattern[dousasu].Move[hidarite][count][move] = none;
						count++;
					}

					for (k = 0; k < 50; k++)
					{
						b[k] = '\0';
					}
					i = 0;
				}
				i++;
			}

			M_pattern[dousasu].length[hidarite] = count;//親部品を組み付ける際の動作の数を記録
			end = 0;
		}

	}

	free(temp);
	fclose(fp1);

}

void ReadKumitateichi() {
	FILE* fp1;
	char* temp;
	int  i;

	fp1 = fopen(inPath_Kumitateichi, "r");
	if (fp1 == NULL) ShowFinMsg("組み立て位置情報が不正です");

	temp = (char*)malloc(FGETS_MAX_LENGTH);

	fgets(temp, FGETS_MAX_LENGTH, fp1);//1行読み込み

	fgets(temp, FGETS_MAX_LENGTH, fp1);//接触線数を読み取り
	Del_Com(temp);
	sscanf(temp, "%d", &Sessyokusen);

	for (i = 0; i < Sessyokusen; i++) {
		fgets(temp, FGETS_MAX_LENGTH, fp1);
		Del_Com(temp);//「,」を消すやつ
		sscanf(temp, "%d%d%d%s%lf%lf%lf%lf%lf%lf%lf%lf%lf", &A_Kumitateichi[i].num, &A_Kumitateichi[i].Kparts, &A_Kumitateichi[i].Iparts, &A_Kumitateichi[i].KumitukeDir, &A_Kumitateichi[i].ASP_X, &A_Kumitateichi[i].ASP_Y, &A_Kumitateichi[i].ASP_Z, &A_Kumitateichi[i].Offset_X, &A_Kumitateichi[i].Offset_Y, &A_Kumitateichi[i].Offset_Z, &A_Kumitateichi[i].APP_X, &A_Kumitateichi[i].APP_Y, &A_Kumitateichi[i].APP_Z);
	}


	free(temp);
	fclose(fp1);

}

void ReadKumitsuke() {
	FILE* fp1;
	char* temp, * si;
	int  i = 0, f, j = 0;
	int First = 0;


	fp1 = fopen(inPath_Kumitsuke, "r");
	if (fp1 == NULL) ShowFinMsg("組付け情報が不正です");

	temp = (char*)malloc(FGETS_MAX_LENGTH);

	fgets(temp, FGETS_MAX_LENGTH, fp1);//1行読み込み

	while (fgets(temp, FGETS_MAX_LENGTH, fp1) != NULL) {


		Del_Com(temp);
		si = temp;
		j = 0;
		sscanf(si, "%d", &Kumi[i][j]);//0:組付け番号
		j++;
		while ((si = strchr(&si[1], ' ')) != NULL) {


			if (j == 1) {
				sscanf(si, "%d", &f);//存在フラグは破棄
				//printf("%d,%d\n\n", i, j);
			}

			else if (j > 1) {
				sscanf(si, "%d", &Kumi[i][j - 1]);//1:部品1,2:部品2,3:組み立て部品,4〜3+N:部品1の構成部品,4+N〜3+2N:部品2の構成部品,4+2N〜3+3N:組立部品の構成部品,4+3N〜3+3*N+Sessyokusen:接触線,3+3*N+Sessyokusen+1〜3+3*N+Sessyokusen+2:部品が自立するか(1:する,2:しない)・被締結部品が不安定じゃないか(1:安定,2:不安定)
				//printf("%d,%d\n\n", i, j);
			}

			if (j == 2 || j == 3 || j == 4) {
				if (First == 0) {
					MaxPL = Kumi[i][j - 1];
					First++;
				}
				else {
					if (MaxPL < Kumi[i][j - 1]) {
						MaxPL = Kumi[i][j - 1];
					}
				}
			}
			j++;
		}


		/*if (Kumi[i][3 + 3 * N0 + Sessyokusen + 1] == NULL) {
			printf("部品の自立情報が記入されていません\n自立する場合は1をしない場合は2を入力してください\n工具のパターンは1になります\n");
			//exit(0);
		}
		if (Kumi[i][3 + 3 * N0 + Sessyokusen + 2] == NULL) {
			printf("部品の不安定情報が記入されていません\n安定する場合は1をしない場合は2を入力してください\n工具のパターンは1になります\n");
			//exit(0);
		}*/

		i++;
	}
	KumiN = i;

	free(temp);
	fclose(fp1);

}

void ReadBuhin() {
	FILE* fp1;
	char* temp, * si;
	int  i, f, j;
	char h[50];
	double Sita = 0;
	printf("\n%s\n", inPath_Buhin);
	fp1 = fopen(inPath_Buhin, "r");
	if (fp1 == NULL) ShowFinMsg("部品情報が不正です");

	temp = (char*)malloc(FGETS_MAX_LENGTH);

	fgets(temp, FGETS_MAX_LENGTH, fp1);//1行読み込み
	fgets(temp, FGETS_MAX_LENGTH, fp1);//1行読み込み
	i = 0;

	while (fgets(temp, FGETS_MAX_LENGTH, fp1) != NULL) {

		Del_Com(temp);
		si = temp;

		sscanf(si, "%d%s%s%d%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf%s%s%d%s%s%d%s%d%d", &f, &h, &h, &A_Buhin[i].Buhinnum, &A_Buhin[i].Tyusin_X, &A_Buhin[i].Tyusin_Y, &A_Buhin[i].Tyusin_Z, &A_Buhin[i].Lengrh_X, &A_Buhin[i].Lengrh_Y, &A_Buhin[i].Lengrh_Z, &A_Buhin[i].X_min, &A_Buhin[i].X_max, &A_Buhin[i].Y_min, &A_Buhin[i].Y_max, &A_Buhin[i].Z_min, &A_Buhin[i].Z_max, &h, &h, &A_Buhin[i].Kougu, &h, &h, &A_Buhin[i].KouguType, &h, &A_Buhin[i].Okikata, &A_Buhin[i].Atsukai);//部品番号、中心、長さ、max、minだけ読み取り

		/*for (j = 0; j < 50; j++) {
			h[j] = NULL;
		}

		if (A_Buhin[i].Buhinnum == NULL) {
			printf("部番が記入されていません\n");
			exit(0);
		}

		if (A_Buhin[i].Kougu == NULL && A_Buhin[i].Kougu != 0) {
			printf("工具番号が記入されていません\n工具を使用しない部品のところには0を記入してください\n");
			exit(0);
		}


		if (A_Buhin[i].KouguType == NULL && A_Buhin[i].Kougu != 0) {
			printf("工具タイプが記入されていません\n部品を保持できる工具は1を、出来ない工具は2を、工具を使用しない部品のところには0を記入してください\n工具のパターンは1になります\n");
			//exit(0);
		}

		if (A_Buhin[i].Okikata == NULL && A_Buhin[i].Kougu != 0) {
			printf("部品の保存方法が記入されていません。整列で置かれてる場合は1、そうでない場合は2を入力してください\n工具のパターンは1になります\n");
			//exit(0);
		}

		if (A_Buhin[i].Atsukai == NULL && A_Buhin[i].Kougu != 0) {
			printf("部品の取り扱い情報が記入されていません。取り扱いに注意が必要な場合は2、そうでない場合は1を入力してください\n工具のパターンは1になります\n");
			//exit(0);
		}
		:*/


		if (B_bigX < A_Buhin[i].Lengrh_X) {
			B_bigX = A_Buhin[i].Lengrh_X;
		}
		if (B_bigY < A_Buhin[i].Lengrh_Y) {
			B_bigY = A_Buhin[i].Lengrh_Y;
		}

		i++;
	}
	N0 = i;
	//printf("BuhinDEkita\n\n\n%d\n\n\n", f);
	free(temp);
}

void ReadHeader() {
	char* temp;
	int  i, h, h0, q;
	FILE* fp1;

	fp1 = fopen(inPath_Header, "r");
	if (fp1 == NULL) ShowFinMsg("レイアウト情報が不正です");

	temp = (char*)malloc(FGETS_MAX_LENGTH);

	fgets(temp, FGETS_MAX_LENGTH, fp1);//一行目だけ読み込む
	Del_Com(temp);

	fgets(temp, FGETS_MAX_LENGTH, fp1);//一行ずつ読み込んでます
	Del_Com(temp);
	sscanf(temp, "%d%d%d", &Worknum, &Linenum, &Kounum);

	fgets(temp, FGETS_MAX_LENGTH, fp1);
	Del_Com(temp);
	sscanf(temp, "%d%d%d%d%d", &Step, &YStep, &Soku, &Kcheck, &Scene);

	fgets(temp, FGETS_MAX_LENGTH, fp1);
	Del_Com(temp);
	sscanf(temp, "%d%d%d", &N, &Kougu, &Jigu);

	fgets(temp, FGETS_MAX_LENGTH, fp1);
	Del_Com(temp);
	sscanf(temp, "%d", &TN);

	fgets(temp, FGETS_MAX_LENGTH, fp1);
	Del_Com(temp);
	sscanf(temp, "%d%d%d", &STN, &STnum, &STflg);

	fgets(temp, FGETS_MAX_LENGTH, fp1);
	Del_Com(temp);
	sscanf(temp, "%d%d%d", &Tukunum, &Bboxnum, &Tupointnum);

	if (TN > 0) {//ここは中間部品数で、複数人作業だと二人目や三人目に前の人が作った中間製品を受け渡す時に出てきます。複数人になる可能性もあるかもしれないので、if文で中間部品数がある場合を考えました。
		sscanf(temp, "%d%d%d", &TN, &Tnumber, &Tflg);
	}
	//ここまでで部品の初期値以外の作業者の人数などの情報です

	fgets(temp, FGETS_MAX_LENGTH, fp1);//改行読み込み

	for (i = 0; i < 2; i++) {//手の情報を書き込んでいます。
		fgets(temp, FGETS_MAX_LENGTH, fp1);
		Del_Com(temp);
		sscanf(temp, "%d%lf%lf%lf%d%d%d", &A_Hands[i].Hnum, &A_Hands[i].IchiX, &A_Hands[i].IchiY, &A_Hands[i].IchiZ, &A_Hands[i].DirX, &A_Hands[i].DirY, &A_Hands[i].DirZ);
	}


	if (N > 0) {
		for (i = 0; i < N; i++) {//部品の情報を読み込んでいます。
			fgets(temp, FGETS_MAX_LENGTH, fp1);
			Del_Com(temp);
			sscanf(temp, "%d%lf%lf%lf%d%d%d", &A_Parts[i].Bnum, &A_Parts[i].IchiX, &A_Parts[i].IchiY, &A_Parts[i].IchiZ, &A_Parts[i].DirX, &A_Parts[i].DirY, &A_Parts[i].DirZ);
		}
	}

	if (Kougu > 0) {
		for (i = 0; i < Kougu; i++) {//工具の情報を読み込んでいます。
			fgets(temp, FGETS_MAX_LENGTH, fp1);
			Del_Com(temp);
			sscanf(temp, "%d%lf%lf%lf%d%d%d", &A_Kougus[i].Bnum, &A_Kougus[i].IchiX, &A_Kougus[i].IchiY, &A_Kougus[i].IchiZ, &A_Kougus[i].DirX, &A_Kougus[i].DirY, &A_Kougus[i].DirZ);
		}
	}

	if (N > 0) {
		if (Jigu > 0) {
			for (i = 0; i < Jigu; i++) {//治具の情報を読み込んでいます。
				fgets(temp, FGETS_MAX_LENGTH, fp1);
				Del_Com(temp);
				sscanf(temp, "%d%lf%lf%lf%d%d%d%lf%lf%lf%d%d", &A_Jigus[i].Jnum, &A_Jigus[i].IchiX, &A_Jigus[i].IchiY, &A_Jigus[i].IchiZ, &A_Jigus[i].DirX, &A_Jigus[i].DirY, &A_Jigus[i].DirZ, &A_Jigus[i].SizeX, &A_Jigus[i].SizeY, &A_Jigus[i].SizeZ, &A_Jigus[i].Iro, &A_Jigus[i].SyokiS);
				A_Jigus[i].H_IchiX = A_Jigus[i].IchiX + A_Jigus[i].SizeX / 2;
				A_Jigus[i].H_IchiY = A_Jigus[i].IchiY + A_Jigus[i].SizeY / 2;
				A_Jigus[i].H_IchiZ = A_Jigus[i].IchiZ + A_Jigus[i].SizeZ / 2;
			}
		}

		if (Tukunum > 0) {
			for (i = 0; i < Tukunum; i++) {//机の情報を読み込んでいます。
				fgets(temp, FGETS_MAX_LENGTH, fp1);
				Del_Com(temp);
				sscanf(temp, "%d%lf%lf%lf%lf%d%lf%lf%lf%d", &A_Desks[i].Dnum, &A_Desks[i].SizeX1, &A_Desks[i].SizeX2, &A_Desks[i].SizeY, &A_Desks[i].SizeZ, &A_Desks[i].Iro, &A_Desks[i].IchiX, &A_Desks[i].IchiY, &A_Desks[i].IchiZ, &A_Desks[i].Dir);
			}
		}




		if (Bboxnum >= 1) {

			Total_Box = Bboxnum; //2021.12.11 加藤追加　Total_Box = Bboxnum;

			for (i = 0; i < Bboxnum; i++) {//部品箱の情報を読み込んでいます。
				fgets(temp, FGETS_MAX_LENGTH, fp1);
				Del_Com(temp);
				sscanf(temp, "%d%d%d%d%lf%lf%lf%lf%lf%lf%lf%d%d%d", &A_Bboxs[i].Bnum, &A_Bboxs[i].Oyako, &A_Bboxs[i].Type, &A_Bboxs[i].Iro, &A_Bboxs[i].SizeX, &A_Bboxs[i].SizeY, &A_Bboxs[i].SizeZ, &A_Bboxs[i].Atusa, &A_Bboxs[i].IchiX, &A_Bboxs[i].IchiY, &A_Bboxs[i].IchiZ, &A_Bboxs[i].DirX, &A_Bboxs[i].DirY, &A_Bboxs[i].DirZ);			
			}

		}
		else {/*部品箱を指定しなかったとき*/
					//printf("2020");
			boxflag = 1;
			//for (i = 0; i < N; i++)
			for (i = 0; i < tantaibuhinsu + pre_count; i++)
			{
				A_Bboxs[i].Bnum = 9000 + 1 + i;
				A_Bboxs[i].Oyako = 1;
				A_Bboxs[i].Type = 2;
				A_Bboxs[i].Iro = 20;
				A_Bboxs[i].SizeX = A_Buhin[i].Lengrh_X + 20;
				A_Bboxs[i].SizeY = A_Buhin[i].Lengrh_Y + 20;
				A_Bboxs[i].SizeZ = 20;
				A_Bboxs[i].Atusa = 2;
				A_Bboxs[i].IchiX = A_Parts[i].IchiX - (A_Buhin[i].Lengrh_X + 20) / 2;//部品箱は左下が原点だから調節
				A_Bboxs[i].IchiY = A_Parts[i].IchiY - (A_Buhin[i].Lengrh_Y + 20) / 2;
				A_Bboxs[i].IchiZ = A_Parts[i].IchiZ - A_Buhin[i].Lengrh_Z / 2 - 5;//部品の大きさ読み込むようになったら、Ｚを調節する
				A_Bboxs[i].DirX = 0;
				A_Bboxs[i].DirY = 0;
				A_Bboxs[i].DirZ = 180;

			}

			/*A_Bboxs[N].Bnum = 9000 + N + 1;//完成品箱の読み取り
			A_Bboxs[N].Oyako = 1;
			A_Bboxs[N].Type = 1;
			A_Bboxs[N].Iro = 20;
			A_Bboxs[N].SizeX = B_bigX + 20;
			A_Bboxs[N].SizeY = B_bigY + 20;
			A_Bboxs[N].SizeZ = 20;
			A_Bboxs[N].Atusa = 2;
			A_Bboxs[N].IchiX = 175;
			A_Bboxs[N].IchiY = 50;
			A_Bboxs[N].IchiZ = 1040;
			A_Bboxs[N].DirX = 0;
			A_Bboxs[N].DirY = 0;
			A_Bboxs[N].DirZ = 0;*/
			A_Bboxs[tantaibuhinsu + pre_count].Bnum = 9000 + N + 1;//完成品箱の読み取り
			A_Bboxs[tantaibuhinsu + pre_count].Oyako = 1;
			A_Bboxs[tantaibuhinsu + pre_count].Type = 1;
			A_Bboxs[tantaibuhinsu + pre_count].Iro = 20;
			A_Bboxs[tantaibuhinsu + pre_count].SizeX = B_bigX + 20;
			A_Bboxs[tantaibuhinsu + pre_count].SizeY = B_bigY + 20;
			A_Bboxs[tantaibuhinsu + pre_count].SizeZ = 20;
			A_Bboxs[tantaibuhinsu + pre_count].Atusa = 2;
			A_Bboxs[tantaibuhinsu + pre_count].IchiX = 175;
			A_Bboxs[tantaibuhinsu + pre_count].IchiY = 50;
			A_Bboxs[tantaibuhinsu + pre_count].IchiZ = 1040;
			A_Bboxs[tantaibuhinsu + pre_count].DirX = 0;
			A_Bboxs[tantaibuhinsu + pre_count].DirY = 0;
			A_Bboxs[tantaibuhinsu + pre_count].DirZ = 0;
			Total_Box = Bboxnum = tantaibuhinsu + pre_count + 1;
			//Bboxnum = N + 1;
		}
	}


	fgets(temp, FGETS_MAX_LENGTH, fp1);
	Del_Com(temp);
	sscanf(temp, "%d", &h);

	if (h <= -400) {//仮置き場の指定があるとき
		for (i = 0; i < N - 1; i++) {
			if (h <= -400 && h > -500) {//ノーマルな置き放しの指定があるとき
				//sscanf(temp, "%d%d%lf%lf%lf", &q, &A_Okishitei[i].Bnum, &A_Okishitei[i].IchiX, &A_Okishitei[i].IchiY, &A_Okishitei[i].IchiZ);
				sscanf(temp, "%d%d%lf%lf%lf", &A_Okishitei[i].Okiba_No, &A_Okishitei[i].Bnum, &A_Okishitei[i].IchiX, &A_Okishitei[i].IchiY, &A_Okishitei[i].IchiZ);	//2121.12.13 加藤追加
				q = A_Okishitei[i].Okiba_No;//2121.12.13 加藤追加
				Okihanashinum++;
				fgets(temp, FGETS_MAX_LENGTH, fp1);
				Del_Com(temp);
				sscanf(temp, "%d", &h0);
			}
			else if (h0 <= Jyunjyonum[1] - 500) {//親子逆の置き放し場所の指定があるとき
				i = 0;
				//sscanf(temp, "%d%d%lf%lf%lf", &q, &q, &A_KOkishitei[i].IchiX, &A_KOkishitei[i].IchiY, &A_KOkishitei[i].IchiZ);
				sscanf(temp, "%d%d%lf%lf%lf", &A_KOkishitei[i].Okiba_No, &A_KOkishitei[i].Bnum, &A_KOkishitei[i].IchiX, &A_KOkishitei[i].IchiY, &A_KOkishitei[i].IchiZ);
				q = A_KOkishitei[i].Okiba_No;//2121.12.13 加藤追加
				fgets(temp, FGETS_MAX_LENGTH, fp1);
				Del_Com(temp);
				KOkihanashinum++;
				break;
			}
			if (h0 > -400 || h0 == NULL || q == h0) {//置き放しの指定がなくなったら
				break;
			}

		}
	}
	if (fgets(temp, FGETS_MAX_LENGTH, fp1) == NULL) loop = 1;
	else {
		Del_Com(temp);
		sscanf(temp, "%d", &Jyunjyonum[1]);
	}

	free(temp);

	fclose(fp1);
}

void WriteHeader(FILE* fp2) {
	int  i;

	fprintf(fp2, "%d,%d,%d\n", Worknum, Linenum, Kounum);
	fprintf(fp2, "%d,%d,%d,%d,%d\n", Step, YStep, Soku, Kcheck, Scene);
	fprintf(fp2, "%d,%d,%d\n", N, Kougu, Jigu);
	fprintf(fp2, "%d,%d,%d\n", TN, Tnumber, Tflg);
	fprintf(fp2, "%d,%d,%d\n", STN, STnum, STflg);
	fprintf(fp2, "%d,%d,%d\n\n", Tukunum, Total_Box, Tupointnum);
	//fprintf(fp2, "%d,%d,%d\n\n", Tukunum, Bboxnum, Tupointnum);



	for (i = 0; i < 2; i++) {
		fprintf(fp2, "%d,%4.2lf,%4.2lf,%4.2lf,%d,%d,%d\n", A_Hands[i].Hnum, A_Hands[i].IchiX, A_Hands[i].IchiY, A_Hands[i].IchiZ, A_Hands[i].DirX, A_Hands[i].DirY, A_Hands[i].DirZ);
	}

	if (N > 0) {
		for (i = 0; i < N; i++) {
			fprintf(fp2, "%d,%4.2lf,%4.2lf,%4.2lf,%d,%d,%d\n", A_Parts[i].Bnum, A_Parts[i].IchiX, A_Parts[i].IchiY, A_Parts[i].IchiZ, A_Parts[i].DirX, A_Parts[i].DirY, A_Parts[i].DirZ);
		}
	}

	if (Kougu > 0) {
		for (i = 0; i < Kougu; i++) {
			fprintf(fp2, "%d,%4.2lf,%4.2lf,%4.2lf,%d,%d,%d\n", A_Kougus[i].Bnum, A_Kougus[i].IchiX, A_Kougus[i].IchiY, A_Kougus[i].IchiZ, A_Kougus[i].DirX, A_Kougus[i].DirY, A_Kougus[i].DirZ);
		}
	}

	if (Jigu > 0) {
		for (i = 0; i < Jigu; i++) {
			fprintf(fp2, "%d,%4.2lf,%4.2lf,%4.2lf,%d,%d,%d,%4.2lf,%4.2lf,%4.2lf,%d,%d\n", A_Jigus[i].Jnum, A_Jigus[i].IchiX, A_Jigus[i].IchiY, A_Jigus[i].IchiZ, A_Jigus[i].DirX, A_Jigus[i].DirY, A_Jigus[i].DirZ, A_Jigus[i].SizeX, A_Jigus[i].SizeY, A_Jigus[i].SizeZ, A_Jigus[i].Iro, A_Jigus[i].SyokiS);
		}
	}

	if (Tukunum > 0) {
		for (i = 0; i < Tukunum; i++) {
			fprintf(fp2, "%d,%lf,%lf,%lf,%lf,%d,%4.2lf,%4.2lf,%4.2lf,%d\n", A_Desks[i].Dnum, A_Desks[i].SizeX1, A_Desks[i].SizeX2, A_Desks[i].SizeY, A_Desks[i].SizeZ, A_Desks[i].Iro, A_Desks[i].IchiX, A_Desks[i].IchiY, A_Desks[i].IchiZ, A_Desks[i].Dir);
		}
	}



	//for (i = 0; i < Bboxnum; i++) {
	for (i = 0; i < Total_Box; i++) {
		fprintf(fp2, "%d,%d,%d,%d,%4.2lf,%4.2lf,%4.2lf,%4.2lf,%4.2lf,%4.2lf,%4.2lf,%d,%d,%d\n", A_Bboxs[i].Bnum, A_Bboxs[i].Oyako, A_Bboxs[i].Type, A_Bboxs[i].Iro, A_Bboxs[i].SizeX, A_Bboxs[i].SizeY, A_Bboxs[i].SizeZ, A_Bboxs[i].Atusa, A_Bboxs[i].IchiX, A_Bboxs[i].IchiY, A_Bboxs[i].IchiZ, A_Bboxs[i].DirX, A_Bboxs[i].DirY, A_Bboxs[i].DirZ);
	}

	//fprintf(fp2, "\n");

	/*** 2021.12.13 加藤追加 ***/

	for (i = 0; i < Okihanashinum; i++)
	{
		fprintf(fp2, "%d,%d,%lf,%lf,%lf\n", A_Okishitei[i].Okiba_No, A_Okishitei[i].Bnum, A_Okishitei[i].IchiX, A_Okishitei[i].IchiY, A_Okishitei[i].IchiZ);
	}

	for (i = 0; i < KOkihanashinum; i++)
	{
		fprintf(fp2, "%d,%d,%lf,%lf,%lf\n", A_KOkishitei[i].Okiba_No, A_KOkishitei[i].Bnum, A_KOkishitei[i].IchiX, A_KOkishitei[i].IchiY, A_KOkishitei[i].IchiZ);
	}

	fprintf(fp2, "\n");

	/*** 2021.12.13 加藤追加 ***/
}

int Move_decision(int Stype, int line)
{
	int resultmove = 0, scenetype = 0, before_scenetype = 0 , flag = 0;

	scenetype = kumijun[line].scene_type;
	before_scenetype = kumijun[line - 1].scene_type;

	flag = 0;

	if (Stype == saisyo_to_kumimae)//最初の状態→組立前の状態
	{
		printf("最初の状態→組立前の状態1\n");
		if (scenetype == katate_migi)
		{
			
			resultmove = saisyo_and_karioki_to_kumimae_migi;
		}
		else if (scenetype == tegumi)
		{		
			resultmove = saisyo_and_karioki_to_kumimae_tegumi;
		}
		else if (scenetype == oomono_ko)
		{
			resultmove = saisyo_and_karioki_to_kumimae_oomono_ko;
		}
		else if (scenetype == oomono_oya)
		{
			resultmove = saisyo_and_karioki_to_kumimae_oomono_oya;
		}
		else if (scenetype == oomono_oyako)
		{
			resultmove = saisyo_and_karioki_to_kumimae_oomono_oyako;
		}
		else if (scenetype == youenjo)
		{
			resultmove = saisyo_and_karioki_to_kumimae_youenjo;
		}
		else if (scenetype == oya1ko2)
		{
			resultmove = saisyo_and_karioki_to_kumimae_oya1ko2;
		}
		else if (scenetype == oya2ko1)
		{
			resultmove = saisyo_and_karioki_to_kumimae_oya2ko1;
		}
		else if (scenetype == oya2ko2)
		{
			resultmove = saisyo_and_karioki_to_kumimae_oya2ko2;
		}
		else if (scenetype == kougu2)
		{
			resultmove = saisyo_and_karioki_to_kumimae_kougu2;
		}
		else if (scenetype == kougu1)
		{
			resultmove = saisyo_and_karioki_to_kumimae_kougu2;//応急処置11月20日
		}
	}
	else if (Stype == kumimae_to_kumigo)//組立前の状態→組立後の状態
	{
		printf("組立前の状態→組立後の状態2\n");
		if (scenetype == katate_migi || scenetype == oomono_oya)
		{
			resultmove = kumimae_to_kumigo_migi;
		}
		else if (scenetype == tegumi)
		{
			//printf("b\n");
			resultmove = kumimae_to_kumigo_migi;
		}
		else if (scenetype == oomono_ko || scenetype == oomono_oyako || scenetype == youenjo)
		{
			resultmove = kumimae_to_kumigo_oomono;
		}
		else if (scenetype == oya1ko2)
		{
			resultmove = kumimae_to_kumigo_ryoute2;
		}
		else if (scenetype == oya2ko1)
		{
			resultmove = kumimae_to_kumigo_oya2ko1;
		}
		else if (scenetype == oya2ko2)
		{
			resultmove = kumimae_to_kumigo_ryoute2;
		}
		else if (scenetype == kougu3)
		{
			resultmove = kumimae_to_kumigo_migi;
		}
		else if (scenetype == kougu2)
		{
			resultmove = kumimae_to_kumigo_migi;
		}
		else if (scenetype == kougu1)
		{
			resultmove = kumimae_to_kumigo_migi;
		}
	}
	else if (Stype == kumigo_to_karioki)//組立後の状態→仮置きした状態　中間製品をすべて仮置きするとき 
	{
		printf("組立後の状態→仮置きした状態　中間製品をすべて仮置きするとき3\n");
		if (scenetype == katate_migi || scenetype == youenjo || scenetype == oya1ko2 || scenetype == oya2ko1)
		{
			if (SType == hukusujig)
			{
				resultmove = kumigo_migi_to_karioki_hukusujig_migi;
			}
			else
			{
				resultmove = kumigo_to_karioki_migi;
			}
		}
		else if (scenetype == tegumi)
		{
			//printf("c\n");
			resultmove = kumigo_to_karioki_tegumi;
		}
		else if (scenetype == oomono_ko || scenetype == oomono_oya || scenetype == oomono_oyako)
		{
			resultmove = kumigo_to_karioki_oomono;
		}
		else if (scenetype == oya2ko2)
		{
			if (kariokiflag % 2 == 0 && kariokiflag % 5 == 0 || not_use_flag == 3)
			{
				resultmove = kumigo_oya2ko2_to_karioki_all;
			}
			else if (kariokiflag % 2 != 0 && kariokiflag % 7 != 0)//組立順序の2行目の部品を仮置きする時
			{
				if (A_Objects[0][TyuPnum].IchiX > A_Objects[0][TyuPnum1].IchiX)//右側の部品が仮置きする部品のとき
				{
					resultmove = kumigo_oya2ko2_to_karioki_migi;
				}
				else
				{
					resultmove = kumigo_oya2ko2_to_karioki_hidari;
				}
			}
			else if (kariokiflag % 3 != 0 && kariokiflag % 5 != 0)
			{
				if (A_Objects[0][TyuPnum].IchiX > A_Objects[0][TyuPnum1].IchiX)//左側の部品が仮置きする部品のとき
				{
					resultmove = kumigo_oya2ko2_to_karioki_hidari;
				}
				else
				{
					resultmove = kumigo_oya2ko2_to_karioki_migi;
				}
			}
			else
			{
				resultmove = kumigo_oya2ko2_to_karioki_hukusujig;
			}
		}
		else if (scenetype == kougu3)
		{
			if (SType == hukusujig)
			{
				if (kumijun[line].kougu == kumijun[line + 1].kougu)//同じ工具を用いるとき
				{
					resultmove = kumigo_migi_to_karioki_hukusujig_migi;
				}
				else
				{
					resultmove = kumigo_kougu_to_karioki_hukusujig;
				}
			}
			else
			{
				if (kumijun[line].kougu == kumijun[line + 1].kougu)//同じ工具を用いるとき
				{
					resultmove = kumigo_kougu_to_karioki_samekougu;
				}
				else
				{
					resultmove = kumigo_kougu_to_karioki_kariokikougu;
				}
			}
		}
		else if (scenetype == kougu2)
		{
			if (SType == hukusujig)
			{
				if (kumijun[line].kougu == kumijun[line + 1].kougu)//同じ工具を用いるとき
				{
					resultmove = kumigo_migi_to_karioki_hukusujig_migi;
				}
				else
				{
					resultmove = kumigo_kougu_to_karioki_hukusujig;
				}
			}
			else
			{
				if (kumijun[line].kougu == kumijun[line + 1].kougu)//同じ工具を用いるとき
				{
					resultmove = kumigo_kougu_to_karioki_samekougu;
				}
				else
				{
					resultmove = kumigo_kougu_to_karioki_kariokikougu;
				}
			}
		}
		else if (scenetype == kougu1)
		{
			if (SType == hukusujig)
			{
				if (kumijun[line].kougu == kumijun[line + 1].kougu)//同じ工具を用いるとき
				{
					resultmove = kumigo_migi_to_karioki_hukusujig_migi;
				}
				else
				{
					resultmove = kumigo_kougu_to_karioki_hukusujig;
				}
			}
			else
			{
				if (kumijun[line].kougu == kumijun[line + 1].kougu)//同じ工具を用いるとき
				{
					resultmove = kumigo_kougu_to_karioki_samekougu;
				}
				else
				{
					resultmove = kumigo_kougu_to_karioki_kariokikougu;
				}
			}
		}
	}
	else if (Stype == kumigo_to_karioki2)//組立後の状態→仮置きした状態(できた中間製品が次の組立で子部品のとき)
	{
	printf("組立後の状態→仮置きした状態(できた中間製品が次の組立で子部品のとき)4\n");
		if (scenetype == katate_migi || scenetype == youenjo || scenetype == oya1ko2 || scenetype == oya2ko1)
		{
			resultmove = kumigo_to_karioki_migi;
		}
		else if (scenetype == tegumi)//組立後の状態(手組み)→仮置きした状態(できた中間製品が次の組立で子部品のとき)
		{
			resultmove = none;
		}
		else if (scenetype == oomono_ko || scenetype == oomono_oya || scenetype == oomono_oyako)
		{
			resultmove = kumigo_to_karioki_oomono;
		}
		else if (scenetype == oya2ko2)
		{
			resultmove = kumigo_oya2ko2_to_karioki_all;
		}
		else if (scenetype == kougu2)
		{
			if (kumijun[line].kougu == kumijun[line].kougu)//同じ工具を用いるとき
			{
				resultmove = kumigo_kougu_to_karioki_samekougu;
			}
			else
			{
				resultmove = kumigo_kougu_to_karioki_kariokikougu;
			}
		}
		else if (scenetype == kougu1)
		{
			if (kumijun[line].kougu == kumijun[line].kougu)//同じ工具を用いるとき
			{
				resultmove = kumigo_kougu_to_karioki_samekougu;
			}
			else
			{
				resultmove = kumigo_kougu_to_karioki_kariokikougu;
			}
		}
	}
	else if (Stype == kumigo_to_kumimae)//組立後の状態→組立前の状態
	{
	printf("組立後の状態→組立前の状態5\n");
		if (scenetype == katate_migi)
		{
			if (before_scenetype == tegumi && kumijun[line - 1].tyukan == kumijun[line].oya)//一つ前の状態が手組みでできたそこでできた中間製品が親部品の時
			{
				resultmove = kumigo_tegumi_to_kumimae_migi_oya;
			}
			else if (before_scenetype == tegumi && kumijun[line - 1].tyukan == kumijun[line].ko)//一つ前の状態が手組みでできたそこでできた中間製品が子部品の時
			{
				
				for (int j = 0; j < line; j++)
				{
					if (kumijun[line].jig == kumijun[j].jig)//現在の治具が今までの組付けで出てきたことがある
					{
						flag=1;
					}
				}
				if (flag == 0)
				{
					//printf("古屋学会\n");
					resultmove = kumigo_tegumi_to_kumimae_migi_ko;
				}
				else
				{
					//printf("古屋学会\n");
					resultmove = kumigo_tegumi_to_kumimae_migi_ko_jigukotei;
				}
			}
			else if ((before_scenetype == oomono_ko || before_scenetype == oomono_oya || before_scenetype == oomono_oyako) && kumijun[line - 1].tyukan == kumijun[line].oya)//一つ前の状態が大物組付けでできたそこでできた中間製品が親部品の時
			{
				resultmove = kumigo_to_kumimae_oomono_oya;
			}
			else if (kumijun[line - 1].kougu != 0)//前の組付けで工具を用いている時
			{
				resultmove = kumigo_kougu_to_kumimae_migi;
			}
			else
			{
				resultmove = kumigo_to_kumimae_migi;
				
			}
		}
		else if (scenetype == tegumi)
		{
			if (before_scenetype == tegumi)
			{
				resultmove = kumigo_to_kumimae_tegumi;
			}
			else if (before_scenetype == katate_migi || before_scenetype == youenjo || before_scenetype == oya2ko1 || before_scenetype == oya1ko2)
			{
				resultmove = kumigo_migi_to_kumimae_tegumi;
			}
			else if (kumijun[line - 1].kougu != 0)
			{
				resultmove = kumigo_kougu_to_kumimae_tegumi;
				
			}
		}
		else if (scenetype == oomono_ko)
		{
			if (before_scenetype == katate_migi && kumijun[line - 1].tyukan == kumijun[line].oya)//一つ前の状態が片手の右手で組付けできたそこでできた中間製品が親部品の時
			{
				resultmove = kumigo_migi_to_kumimae_oomono_ko;
			}
			else if (before_scenetype == tegumi && kumijun[line - 1].tyukan == kumijun[line].oya)//一つ前の状態が手組みでできたそこでできた中間製品が親部品の時
			{
				resultmove = kumigo_tegumi_to_kumimae_oomono_ko;
			}
			else if ((before_scenetype == oomono_ko || before_scenetype == oomono_oya || before_scenetype == oomono_oyako) && kumijun[line - 1].tyukan == kumijun[line].oya)//一つ前の状態が大物組付けでできたそこでできた中間製品が親部品の時
			{
				resultmove = kumigo_to_kumimae_oomono_oyako;
			}
			else if (kumijun[line - 1].kougu != 0)
			{
				resultmove = kumigo_kougu_to_kumimae_oomono_ko;
			}
		}
		else if (scenetype == oomono_oya)
		{
			if (kumijun[line - 1].kougu != 0)//前の組付けで工具を用いている時
			{
				resultmove = kumigo_kougu_to_kumimae_oomono_oya;
			}
			else
			{
				resultmove = kumigo_to_kumimae_oomono_oya;
			}
		}
		else if (scenetype == oomono_oyako)
		{
			if (kumijun[line - 1].kougu != 0)//前の組付けで工具を用いている時
			{
				resultmove = kumigo_kougu_to_kumimae_oomono_oyako;
			}
			else
			{
				resultmove = kumigo_to_kumimae_oomono_oyako;
			}
		}
		else if (scenetype == youenjo)
		{
			if (before_scenetype == tegumi && kumijun[line - 1].tyukan == kumijun[line].oya)//一つ前の状態が手組みでできたそこでできた中間製品が親部品の時
			{
				resultmove = kumigo_tegumi_to_kumimae_youenjo_oya;
			}
			else if ((before_scenetype == oomono_ko || before_scenetype == oomono_oya || before_scenetype == oomono_oyako) && kumijun[line - 1].tyukan == kumijun[line].oya)//一つ前の状態が大物組付けでできたそこでできた中間製品が親部品の時
			{
				resultmove = kumigo_oomono_to_kumimae_youenjo;
			}
			else if (kumijun[line - 1].kougu != 0)
			{
				resultmove = kumigo_kougu_to_kumimae_youenjo;
			}
			else
			{
				resultmove = kumigo_to_kumimae_migi;
			}
		}
		else if (scenetype == oya1ko2)
		{
			if (before_scenetype == tegumi && kumijun[line - 1].tyukan == kumijun[line].oya)//一つ前の状態が手組みでできたそこでできた中間製品が親部品の時
			{
				resultmove = kumigo_tegumi_to_kumimae_oya1ko2_oya;
			}
			else if ((before_scenetype == oomono_ko || before_scenetype == oomono_oya || before_scenetype == oomono_oyako) && kumijun[line - 1].tyukan == kumijun[line].oya)//前の組付けが大物で親部品になっているとき
			{
				resultmove = kumigo_oomono_to_kumimae_oya1ko2;
			}
			else if (kumijun[line - 1].kougu != 0)
			{
				resultmove = kumigo_kougu_to_kumimae_oya1ko2;
			}
			else
			{
				resultmove = kumigo_migi_to_kumimae_oya1ko2;
			}
		}
		else if (scenetype == oya2ko1)
		{
			if (Oya2Jigflag == 1)//組立順序の2行のうち前の親部品がすでに治具についているとき
			{
				if (A_Objects[1][OyaPnum].IchiX > A_Objects[1][OyaPnum1].IchiX)//前の親部品が左側にあるとき
				{
					resultmove = kumigo_to_kumimae_oya2ko1_hidari;
				}
				else//前の親部品が左側にあるとき
				{
					resultmove = kumigo_to_kumimae_oya2ko1_migi;
				}
			}
			else if (Oya2Jigflag == 2)//組立順序の2行のうち2行目の親部品がすでに治具についているとき
			{
				if (A_Objects[1][OyaPnum].IchiX > A_Objects[1][OyaPnum1].IchiX)//2行目の親部品が右側にあるとき
				{
					resultmove = kumigo_to_kumimae_oya2ko1_migi;
				}
				else//2行目の親部品が左側にあるとき
				{
					resultmove = kumigo_to_kumimae_oya2ko1_hidari;
				}
			}
			else if (Oya2Jigflag == 3 && kumijun[line - 1].scene_type == oya2ko2 &&
				(kumijun[line - 1].tyukan == kumijun[line].oya || kumijun[line - 1].tyukan == kumijun[line + 1].oya) &&
				(kumijun[line - 2].tyukan == kumijun[line].oya || kumijun[line - 2].tyukan == kumijun[line + 1].oya))//両方とも治具についている時で両方とも直前に親2子2で組立られた部品の時
			{
				resultmove = kumigo_oya2ko2_to_kumimae_oya2ko1;
			}
			else if (Oya2Jigflag == 3)//両方ともに治具についていたとき
			{
				resultmove = kumigo_to_kumimae_oya2ko1_attached;
			}
		}
		else if (scenetype == oya2ko2)
		{
			if (Oya2Jigflag == 1)//組立順序の2行のうち前の親部品がすでに治具についているとき
			{
				if (A_Objects[1][OyaPnum].IchiX > A_Objects[1][OyaPnum1].IchiX)//前の親部品が左側にあるとき
				{
					resultmove = kumigo_to_kumimae_oya2ko2_hidari;
				}
				else//前の親部品が左側にあるとき
				{
					resultmove = kumigo_to_kumimae_oya2ko2_migi;
				}
			}
			else if (Oya2Jigflag == 2)//組立順序の2行のうち2行目の親部品がすでに治具についているとき
			{
				if (A_Objects[1][OyaPnum].IchiX > A_Objects[1][OyaPnum1].IchiX)//2行目の親部品が右側にあるとき
				{
					resultmove = kumigo_to_kumimae_oya2ko2_migi;
				}
				else//2行目の親部品が左側にあるとき
				{
					resultmove = kumigo_to_kumimae_oya2ko2_hidari;
				}
			}
			else if (Oya2Jigflag == 3)//両方ともに治具についていたとき
			{
				resultmove = kumigo_oya2ko2_to_kumimae_oya2ko2_attached;
			}
		}
		else if (scenetype == kougu2)
		{
		//printf("手組みから工具\n");
			if ((kumijun[line - 1].kougu != kumijun[line].kougu)&& (before_scenetype != tegumi))//使用する工具が変更されている時
			{
				if (kumijun[line - 1].scene_type == tegumi && kumijun[line - 1].tyukan == kumijun[line].oya)
				{
					resultmove = kumigo_tegumi_to_kumimae_kougu2_oya;
					
				}
				else if (kumijun[line - 1].scene_type == katate_migi || kumijun[line - 1].scene_type == oya1ko2 || kumijun[line - 1].scene_type == oya2ko1 || kumijun[line - 1].scene_type == youenjo)
				{
					resultmove = kumigo_migi_to_kumimae_kougu2;
					
				}
				else if (before_scenetype == oomono_ko || before_scenetype == oomono_oya || before_scenetype == oomono_oyako)
				{
					resultmove = kumigo_oomono_to_kumimae_kougu2;
					
				}
				else
				{
					resultmove = kumigo_kougu_to_kumimae_changekougu2;
					
				}
				
			}
			else if (before_scenetype == tegumi && kumijun[line - 1].tyukan == kumijun[line].ko)//一つ前の状態が手組みでできたそこでできた中間製品が子部品の時
			{

				for (int j = 0; j < line; j++)
				{
					if (kumijun[line].jig == kumijun[j].jig)//現在の治具が今までの組付けで出てきたことがある
					{
						flag = 1;
					}
				}
				if (flag == 0)
				{
					//printf("古屋学会\n");
					resultmove = kumigo_tegumi_to_kumimae_kougu2_ko;
				}
				else
				{
					//printf("古屋学会\n");
					resultmove = kumigo_tegumi_to_kumimae_kougu2_ko_oyajigu;
					//printf("%d手組みから工具\n", resultmove);
				}
			}
			else//使用する工具が同じ時
			{
				resultmove = kumigo_kougu_to_kumimae_samekougu2;
				
			}
			
		}
		else if (scenetype == kougu1)
		{
			if ((kumijun[line - 1].kougu != kumijun[line].kougu) && (before_scenetype != tegumi))//使用する工具が変更されている時
			{
				if (kumijun[line - 1].scene_type == tegumi && kumijun[line - 1].tyukan == kumijun[line].oya)
				{
					resultmove = kumigo_tegumi_to_kumimae_kougu1_oya;
				}
				else if ((kumijun[line - 1].scene_type == katate_migi || kumijun[line - 1].scene_type == oya1ko2 || kumijun[line - 1].scene_type == oya2ko1 || kumijun[line - 1].scene_type == youenjo)&&(kumijun[line].ko<17))
				{
					resultmove = kumigo_migi_to_kumimae_kougu1;
				}
				else if ((kumijun[line - 1].scene_type == katate_migi || kumijun[line - 1].scene_type == oya1ko2 || kumijun[line - 1].scene_type == oya2ko1 || kumijun[line - 1].scene_type == youenjo) && (kumijun[line].ko >= 17))
				{
					resultmove = kumigo_migi_to_kumimae_kougu2;
				}
				else if (before_scenetype == oomono_ko || before_scenetype == oomono_oya || before_scenetype == oomono_oyako)
				{
					resultmove = kumigo_oomono_to_kumimae_kougu1;
				}
				else
				{
					resultmove = kumigo_kougu_to_kumimae_changekougu1;
				}
			}
			else if (before_scenetype == tegumi && kumijun[line - 1].tyukan == kumijun[line].ko)//一つ前の状態が手組みでできたそこでできた中間製品が子部品の時
			{

				for (int j = 0; j < line; j++)
				{
					if (kumijun[line].jig == kumijun[j].jig)//現在の治具が今までの組付けで出てきたことがある
					{
						flag = 1;
					}
				}
				if (flag == 0)
				{
					//printf("古屋学会\n");
					resultmove = kumigo_tegumi_to_kumimae_kougu2_ko;
				}
				else
				{
					//printf("古屋学会\n");
					resultmove = kumigo_tegumi_to_kumimae_kougu2_ko_oyajigu;
					//printf("%d手組みから工具\n", resultmove);
				}
			}
			else//使用する工具が同じ時
			{
				if (kumijun[line].ko < 17)
				{
					resultmove = kumigo_kougu_to_kumimae_samekougu1;
				}
				else
				{
					resultmove = kumigo_kougu_to_kumimae_samekougu2;
				}
			}
		}
	}
	else if (Stype == kumigo_to_saigo)//組立後の状態→最後の状態
	{
	printf("/組立後の状態→最後の状態6\n");
		if (scenetype == katate_migi)
		{
			resultmove = kumigo_to_saigo_migi;
		}
		else if (scenetype == tegumi)
		{
			resultmove = kumigo_to_saigo_tegumi;
		}
		else if (scenetype == oomono_ko || scenetype == oomono_oya || scenetype == oomono_oyako)
		{
			resultmove = kumigo_to_saigo_oomono;
		}
		else if (scenetype == youenjo)
		{
			resultmove = kumigo_to_saigo_migi;
		}
		else if (scenetype == oya1ko2)
		{
			resultmove = kumigo_to_saigo_migi;
		}
		else if (scenetype == oya2ko1)
		{
			resultmove = kumigo_to_saigo_migi;
		}
		else if (scenetype == oya2ko2)
		{
			resultmove = kumigo_oya2ko2_to_saigo;
		}
		else if (scenetype == kougu2)
		{
			resultmove = kumigo_to_saigo_kougu;
		}
		else if (scenetype == kougu1)
		{
			resultmove = kumigo_to_saigo_kougu;
		}
	}
	else if (Stype == karioki_to_kumimae)//仮置きした状態→組立前の状態
	{
	printf("仮置きした状態→組立前の状態7\n");
		if (scenetype == katate_migi)
		{
			
			if (before_scenetype == tegumi && kumijun[line - 1].tyukan == kumijun[line].ko)//一つ前の状態が手組みでできたそこでできた中間製品が子部品の時
			{
				resultmove = kumigo_tegumi_to_kumimae_migi_ko;
			}
			else
			{
				resultmove = saisyo_and_karioki_to_kumimae_migi;
			}
		}
		else if (scenetype == tegumi)
		{
			
			//printf("a\n");
			resultmove = saisyo_and_karioki_to_kumimae_tegumi;
		}
		else if (scenetype == oomono_ko)
		{
			resultmove = saisyo_and_karioki_to_kumimae_oomono_ko;
		}
		else if (scenetype == oomono_oya)
		{
			resultmove = saisyo_and_karioki_to_kumimae_oomono_oya;
		}
		else if (scenetype == oomono_oyako)
		{
			resultmove = saisyo_and_karioki_to_kumimae_oomono_oyako;
		}
		else if (scenetype == youenjo)
		{
			if (before_scenetype == tegumi && kumijun[line - 1].tyukan == kumijun[line].ko)//一つ前の状態が手組みでできたそこでできた中間製品が子部品の時
			{
				resultmove = kumigo_tegumi_to_kumimae_youenjo_ko;
			}
			else
			{
				resultmove = saisyo_and_karioki_to_kumimae_youenjo;
			}
		}
		else if (scenetype == oya1ko2)
		{
			if (before_scenetype == tegumi)
			{
				if (A_Objects[1][R_KoPnum].Id == kumijun[line - 1].tyukan)//中間製品が次の右手の子部品と一致するとき
				{
					resultmove = kumigo_tegumi_to_kumimae_oya1ko2_ko_migi;
				}
				else if (A_Objects[1][L_KoPnum].Id == kumijun[line - 1].tyukan)//中間製品が次の右手の子部品と一致するとき
				{
					resultmove = kumigo_tegumi_to_kumimae_oya1ko2_ko_hidari;
				}
			}
			else
			{
				resultmove = saisyo_and_karioki_to_kumimae_oya1ko2;
			}
		}
		else if (scenetype == oya2ko1)
		{
			if (Oya2Jigflag == 1)//組立順序の2行のうち前の親部品がすでに治具についているとき
			{
				if (A_Objects[1][OyaPnum].IchiX > A_Objects[1][OyaPnum1].IchiX)//前の親部品が左側にあるとき
				{
					resultmove = kumigo_to_kumimae_oya2ko1_hidari;
				}
				else//前の親部品が左側にあるとき
				{
					resultmove = kumigo_to_kumimae_oya2ko1_migi;
				}
			}
			else if (Oya2Jigflag == 2)//組立順序の2行のうち2行目の親部品がすでに治具についているとき
			{
				if (A_Objects[1][OyaPnum].IchiX > A_Objects[1][OyaPnum1].IchiX)//2行目の親部品が右側にあるとき
				{
					resultmove = kumigo_to_kumimae_oya2ko1_migi;
				}
				else//2行目の親部品が左側にあるとき
				{
					resultmove = kumigo_to_kumimae_oya2ko1_hidari;
				}
			}
			else if (Oya2Jigflag == 3)//両方ともに治具についていたとき
			{
				resultmove = kumigo_to_kumimae_oya2ko1_attached;
			}
			else if (kumijun[line - 1].scene_type == tegumi && (kumijun[line - 1].tyukan == kumijun[line].oya || kumijun[line - 1].tyukan == kumijun[line + 1].oya))
			{
				if (A_Objects[1][OyaPnum].IchiX > A_Objects[1][OyaPnum1].IchiX)//2行目の親部品が右側にあるとき
				{
					if (A_Objects[1][OyaPnum].Id == kumijun[line - 1].tyukan)
					{
						resultmove = kumigo_tegumi_to_kumimae_oya2ko1_migi;
					}
					else if (A_Objects[1][OyaPnum1].Id == kumijun[line - 1].tyukan)
					{
						resultmove = kumigo_tegumi_to_kumimae_oya2ko1_hidari;
					}
				}
				else
				{
					if (A_Objects[1][OyaPnum].Id == kumijun[line - 1].tyukan)
					{
						resultmove = kumigo_tegumi_to_kumimae_oya2ko1_hidari;
					}
					else if (A_Objects[1][OyaPnum1].Id == kumijun[line - 1].tyukan)
					{
						resultmove = kumigo_tegumi_to_kumimae_oya2ko1_migi;
					}
				}
			}
			else
			{
				resultmove = saisyo_and_karioki_to_kumimae_oya2ko1;
			}
		}
		else if (scenetype == oya2ko2)
		{
			if (Oya2Jigflag == 1)//組立順序の2行のうち前の親部品がすでに治具についているとき
			{
				if (A_Objects[1][OyaPnum].IchiX > A_Objects[1][OyaPnum1].IchiX)//前の親部品が左側にあるとき
				{
					resultmove = kumigo_to_kumimae_oya2ko2_hidari;
				}
				else//前の親部品が左側にあるとき
				{
					resultmove = kumigo_to_kumimae_oya2ko2_migi;
				}
			}
			else if (Oya2Jigflag == 2)//組立順序の2行のうち2行目の親部品がすでに治具についているとき
			{
				if (A_Objects[1][OyaPnum].IchiX > A_Objects[1][OyaPnum1].IchiX)//2行目の親部品が右側にあるとき
				{
					resultmove = kumigo_to_kumimae_oya2ko2_migi;
				}
				else//2行目の親部品が左側にあるとき
				{
					resultmove = kumigo_to_kumimae_oya2ko2_hidari;
				}
			}
			else if (Oya2Jigflag == 3)//両方ともに治具についていたとき
			{
				resultmove = kumigo_oya2ko2_to_kumimae_oya2ko2_attached;
			}
			else if (kumijun[line - 1].scene_type == tegumi && (kumijun[line - 1].tyukan == kumijun[line].oya || kumijun[line - 1].tyukan == kumijun[line + 1].oya))
			{
				if (A_Objects[1][OyaPnum].IchiX > A_Objects[1][OyaPnum1].IchiX)//2行目の親部品が右側にあるとき
				{
					if (A_Objects[1][OyaPnum].Id == kumijun[line - 1].tyukan)
					{
						resultmove = kumigo_tegumi_to_kumimae_oya2ko2_tegumi_migi;
					}
					else if (A_Objects[1][OyaPnum1].Id == kumijun[line - 1].tyukan)
					{
						resultmove = kumigo_tegumi_to_kumimae_oya2ko2_tegumi_hidari;
					}
				}
				else
				{
					if (A_Objects[1][OyaPnum].Id == kumijun[line - 1].tyukan)
					{
						resultmove = kumigo_tegumi_to_kumimae_oya2ko2_tegumi_hidari;
					}
					else if (A_Objects[1][OyaPnum1].Id == kumijun[line - 1].tyukan)
					{
						resultmove = kumigo_tegumi_to_kumimae_oya2ko2_tegumi_migi;
					}
				}
			}
			else
			{
				resultmove = saisyo_and_karioki_to_kumimae_oya2ko2;
			}
		}
		else if (scenetype == kougu3)
		{
		//printf("-3工具\n");
			if (kumijun[line - 1].scene_type == tegumi && kumijun[line - 1].tyukan == kumijun[line].ko)
			{
				resultmove = kumigo_tegumi_to_kumimae_kougu2_ko;
			}
			else if (kumijun[line - 1].kougu != kumijun[line].kougu)//使用する工具が変更されている時
			{
				resultmove = saisyo_and_karioki_to_kumimae_kougu3;
			}
			else//使用する工具が同じで部品が違う時
			{
				resultmove = karioki_to_kumimae_samekougu2;
			}
		}
		else if (scenetype == kougu2)
		{
		//printf("-3工具\n");
			if (kumijun[line - 1].scene_type == tegumi && kumijun[line - 1].tyukan == kumijun[line].ko)
			{
				
				resultmove = kumigo_tegumi_to_kumimae_kougu2_ko;
			}
			else if (kumijun[line - 1].kougu != kumijun[line].kougu)//使用する工具が変更されている時
			{
				resultmove = saisyo_and_karioki_to_kumimae_kougu2;
			}
			else//使用する工具が同じで部品が違う時
			{
				resultmove = karioki_to_kumimae_samekougu2;
			}
		}
		else if (scenetype == kougu1)
		{
		//printf("-3工具\n");
			if (kumijun[line - 1].scene_type == tegumi && kumijun[line - 1].tyukan == kumijun[line].ko)
			{
				resultmove = kumigo_tegumi_to_kumimae_kougu2_ko;
			}
			else if (kumijun[line - 1].kougu != kumijun[line].kougu)//使用する工具が変更されている時
			{
				resultmove = saisyo_and_karioki_to_kumimae_kougu2;//応急処置11月20日
			}
			else//使用する工具が同じで部品が違う時
			{
				resultmove = karioki_to_kumimae_samekougu2;//応急処置11月20日
			}
		}
	}
	return resultmove;
}

void Make_kumitatemae(int line)
{
	/*
	〈SType1の作り方〉
	1.組立順序の情報から親部品、子部品の情報を読み込む
	2.組付けから組み付け番号が同じ組み付けの情報を読み取る(各部品の構成、接触線)
	3.接触関係＿組立位置情報から該当する接触線の情報(固定部品、移動部品、組付け方向、APP、ASP、OFFSETただし組付け方向のみの値だけ)
	4.子部品と親部品の部品箱の支えの関係を切る
	5.治具と左手に親部品との支えの関係を作る
	6.右手に子部品との支えの関係を作る
	7.左手と親部品は治具に持っていく
	8.右手と子部品をAPPに持っていく
	9.回転を考慮する
	10.工具を用いるのに必要な支えの関係の変更や、位置の変更を行う
	*/
	int KoPa, OyaPa, Knum, TyuPa, KoPa0, Jig, Jig2;//子部品番号、親部品番号、組付け番号、中間製品,ひとつ前の子部品
	int kuminownum = 0; // この状態で用いる組付けの行数
	int i, j, q, Sessyoku[MaxDN], p;//この状態で用いる接触線の番号,p:現在の状態で用いる接触線の数
	int KIchi[MaxDN][3];//KIchi[3][MaxDN]:今回用いる組立位置情報の情報(接触線番号、固定部品、移動部品)
	char Dir[MaxDN][3], x;//この状態で用いられる組付け方向
	double AAO[MaxDN][3];//AAO[3][MaxDN]:ASP,APP,Offsetの情報(組付け方向の値だけ)
	double KoPaIchi = 0;//子部品の位置を決める際に用いるAPPとOffsetの差分
	double h[MaxDN], v = 0;//接触線が二つ以上あるときの仮のKoPaIhi,仮のKIdo
	double JiguZ = 0, JiguKousei = 0;//治具の組付く位置導出のために用いている、冶具に直接ついている単部品を導出、冶具に直接組付いている単部品と子部品の距離の差
	int dash[2][3];//dash[0][]:ひとつ前の角度の仮、dash[1][]:新しいの角度の仮、dash[][x]:x=1のときx軸、x=2のときy軸、x=3のときz軸
	double rad_x, rad_y, rad_z;//角度
	int z;
	int scenetype = 0;
	int roop = 1, roopcount = 0;//roop何回繰り返すか、roopcount：for文を回すための変数
	int f = 0, supportlength = 0, k = 0;

	int JigPnum = 0;//治具についている部品がオブジェクトでどこにあるか
	int KijunOya = 0;//親部品2つの時の基準となる親部品番号
	int oyanum1 = 0, oyanum2 = 0, oyaBnum1 = 0, oyaBnum2 = 0;
	double OyaJigX = 0, OyaJigY = 0, OyaJigZ = 0;
	int KouguNum = 0, BeforeKouguNum = 0;

	int DisDir = 0, AsmDir = 0;
	double AsmDistanceX = 0, AsmDistanceY = 0, AsmDistanceZ = 0;//子部品の位置を決める際に用いるAPPとOffsetの差分

	Oya2flag = 0;//フラグのリセット
	Oya2Jigflag = 0;
	Oya2hoseiX = Oya2hoseiY = Oya2hoseiZ = 0;

	roop = 1;

	SType = kumitatemae;

	scenetype = kumijun[line].scene_type;

	if (scenetype == oya2ko2 || scenetype == oya2ko1 || scenetype == oya1ko2)
	{
		roop = 2;

		if (scenetype == oya2ko2 || scenetype == oya2ko1)//親部品が2つの時
		{
			/*if (kumijun[line - 1].scene_type == oya2ko2)//前の組立が親2子2の時
			{
				if ((kumijun[line].oya == kumijun[line - 2].tyukan || kumijun[line].oya == kumijun[line - 1].tyukan)//親部品が両方とも治具にすでについている時
					&& (kumijun[line + 1].oya == kumijun[line - 2].tyukan || kumijun[line + 1].oya == kumijun[line - 1].tyukan))
				{
					Oya2flag = 3;
				}
				else if (kumijun[line].oya == kumijun[line - 2].tyukan || kumijun[line].oya == kumijun[line - 1].tyukan)//組順の1行目の部品がすでに治具についているとき
				{
					Oya2flag = 1;
				}
				else if (kumijun[line + 1].oya == kumijun[line - 2].tyukan || kumijun[line + 1].oya == kumijun[line - 1].tyukan)//組順の2行目の部品がすでに治具についているとき
				{
					Oya2flag = 2;
				}
				else//両方とも治具についていないとき
				{
					Oya2flag = 2;
				}
			}
			else//前の組立が親2子2でないとき
			{
				if (kumijun[line].oya == kumijun[line - 1].tyukan)//組順の1行目の部品がすでに治具についているとき
				{
					Oya2flag = 1;
				}
				else if (kumijun[line + 1].oya == kumijun[line - 1].tyukan)//組順の2行目の部品がすでに治具についているとき
				{
					Oya2flag = 2;
				}
				else//両方とも治具についていないとき
				{
					Oya2flag = 2;
				}
			}*/
			if (NewNOS0 == 0)
			{
				Jig = kumijun[line].jig - 1;
			}
			else
			{
				for (i = 0; i < Jigu; i++)
				{
					if (A_Objects[0][3 * N + 2 + i + putting].Id == kumijun[line].jig)
					{
						Jig = i;
						break;
					}

				}
			}
			if (NewNOS0 == 0)
			{
				Jig2 = kumijun[line + 1].jig - 1;
			}
			else
			{
				for (i = 0; i < Jigu; i++)
				{
					if (A_Objects[0][3 * N + 2 + i + putting].Id == kumijun[line + 1].jig)
					{
						Jig2 = i;
						break;
					}

				}
			}
			for (i = 0; i < JigPartssu; i++)
			{
				if (jig_parts[i].num == kumijun[line].oya && jig_parts[i].jignum == Jig)//組立順序の1行目の親部品が現在治具についており、現在部品がついている治具と今回使用する治具が同じ時
				{
					Oya2flag = Oya2flag + 1;
					Oya2Jigflag = Oya2Jigflag + 1;
				}
				else if (jig_parts[i].num == kumijun[line].oya && jig_parts[i].jignum != Jig)//組立順序の1行目の親部品が現在治具についており、現在部品がついている治具と今回使用する治具が異なる時
				{
					ChangeJig = kumijun[line].oya;
				}
				else if (jig_parts[i].num == kumijun[line + 1].oya && jig_parts[i].jignum == Jig2)//組立順序の2行目の親部品が現在治具についており、現在部品がついている治具と今回使用する治具が同じ時
				{
					Oya2flag = Oya2flag + 2;
					Oya2Jigflag = Oya2Jigflag + 2;
				}
				//else if (jig_parts[i].num == kumijun[line + 1].oya && jig_parts[i].jignum == Jig2)//組立順序の2行目の親部品が現在治具についており、現在部品がついている治具と今回使用する治具が異なる時
				else if (jig_parts[i].num == kumijun[line + 1].oya && jig_parts[i].jignum != Jig2)//古屋変更
				{
					ChangeJig2 = kumijun[line + 1].oya;
				}

				if (Oya2flag == 3) break;//親部品2つとも今回使用する治具についていた時点でブレイク
			}

			if (Oya2flag == 0)//両方とも治具についていない時は2行目の親部品を基準とする
			{
				Oya2flag = 2;
			}
		}
	}

	if (line == 0) {
		for (i = 0; i < 3 * N + 2 + Kougu + putting + Jigu; i++) {
			A_Objects[1][i].Id = A_Objects[0][i].Id;
			A_Objects[1][i].Flag = A_Objects[0][i].Flag;
			A_Objects[1][i].IchiX = A_Objects[0][i].IchiX;
			A_Objects[1][i].IchiY = A_Objects[0][i].IchiY;
			A_Objects[1][i].IchiZ = A_Objects[0][i].IchiZ;
			A_Objects[1][i].DirX = A_Objects[0][i].DirX;
			A_Objects[1][i].DirY = A_Objects[0][i].DirY;
			A_Objects[1][i].DirZ = A_Objects[0][i].DirZ;

			
		}
		for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++) {
			A_Supports[1][i].Id = A_Supports[0][i].Id;
			A_Supports[1][i].Flag = A_Supports[0][i].Flag;
			for (supportlength = 0; supportlength < A_Supports[0][i].Length; supportlength++)
			{
				A_Supports[1][i].PId[supportlength] = A_Supports[0][i].PId[supportlength];
			}
			A_Supports[1][i].Length = supportlength;
		}
	}
	else {

		for (i = 0; i < 3 * N + 2 + Kougu + putting + Jigu; i++) {
			A_Objects[0][i].Id = A_Objects[1][i].Id;
			A_Objects[0][i].Flag = A_Objects[1][i].Flag;
			A_Objects[0][i].IchiX = A_Objects[1][i].IchiX;
			A_Objects[0][i].IchiY = A_Objects[1][i].IchiY;
			A_Objects[0][i].IchiZ = A_Objects[1][i].IchiZ;
			A_Objects[0][i].DirX = A_Objects[1][i].DirX;
			A_Objects[0][i].DirY = A_Objects[1][i].DirY;
			A_Objects[0][i].DirZ = A_Objects[1][i].DirZ;
		}
		for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++) {
			A_Supports[0][i].Id = A_Supports[1][i].Id;
			A_Supports[0][i].Flag = A_Supports[1][i].Flag;
			for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
			{
				A_Supports[0][i].PId[supportlength] = A_Supports[1][i].PId[supportlength];
			}
			A_Supports[0][i].Length = supportlength;
		}
	}

	for (roopcount = 0; roopcount < roop; roopcount++)
	{
		Knum = kumijun[line].kuminum;//今の状態の情報を書き込んでいます
		KoPa = kumijun[line].ko;
		KoPa0 = kumijun[line - 1].ko;//ひとつ前の子部品が何か調べる
		OyaPa = kumijun[line].oya;
		TyuPa = kumijun[line].tyukan;

		if (NewNOS0 == 0)
		{
			Jig = kumijun[line].jig - 1;
			KouguNum = kumijun[line].kougu - 1;
			BeforeKouguNum = kumijun[line - 1].kougu - 1;
		}
		else
		{
			for (i = 0; i < Jigu; i++)
			{
				if (A_Objects[0][3 * N + 2 + i + putting].Id == kumijun[line].jig)
				{
					Jig = i;
					break;
				}
			}
			for (i = 0; i < Kougu; i++)
			{
				if (A_Objects[0][3 * N + 2 + i + putting + Jigu].Id == kumijun[line].kougu)
				{
					KouguNum = i;
					break;
				}
			}
			for (i = 0; i < Kougu; i++)
			{
				if (A_Objects[0][3 * N + 2 + i + putting + Jigu].Id == kumijun[line - 1].kougu)
				{
					BeforeKouguNum = i;
					break;
				}
			}
		}


		for (i = 0; i < KumiN; i++) {//組付けの情報を読み込んでいます
			if (Kumi[i][0] == Knum) {//組立順序の組付け番号と一致する組付けを探す
				kuminownum = i;
			}
		}

		j = 0;
		for (i = 0; i < Sessyokusen; i++) {//接触線が何番であるかを読み込んでいます
			if (Kumi[kuminownum][i + 4 + 3 * N] == 1) {
				Sessyoku[j] = i + 1;
				j++;
			}
		}



		p = j;

		for (i = 0; i < 3; i++) {//配列を0にしています
			for (j = 0; j < p; j++) {
				Dir[j][i] = 0;
			}
		}


		for (i = 0; i < p; i++) {//組立位置情報の接触線番号、固定部品、移動部品、組み立て方向を書き込んでいます
			for (j = 0; j < Sessyokusen; j++) {
				if (Sessyoku[i] == A_Kumitateichi[j].num) {//

					KIchi[i][0] = A_Kumitateichi[j].num;
					KIchi[i][1] = A_Kumitateichi[j].Kparts;
					KIchi[i][2] = A_Kumitateichi[j].Iparts;
					for (x = 0; x < 3; x++) {//組付け方向の読み込み
						Dir[i][x] = A_Kumitateichi[j].KumitukeDir[x];
					}

					if (Dir[i][0] == 'X') {//ASP,APP,Offsetを読み込んでいます(組立情報と同じ方向のみ)
						AAO[i][0] = A_Kumitateichi[j].ASP_X;
						AAO[i][1] = A_Kumitateichi[j].APP_X;
						AAO[i][2] = A_Kumitateichi[j].Offset_X;
					}


					else if (Dir[i][0] == 'Y') {
						AAO[i][0] = A_Kumitateichi[j].ASP_Y;
						AAO[i][1] = A_Kumitateichi[j].APP_Y;
						AAO[i][2] = A_Kumitateichi[j].Offset_Y;
					}

					else if (Dir[i][0] == 'Z') {
						AAO[i][0] = A_Kumitateichi[j].ASP_Z;
						AAO[i][1] = A_Kumitateichi[j].APP_Z;
						AAO[i][2] = A_Kumitateichi[j].Offset_Z;
					}
				}
			}
		}



		//動作を作る際に行う

		//for (i = 0; i < N + 1; i++) {//部品箱の支えの関係を切る
		for (i = 0; i < Bboxnum; i++) {//部品箱の支えの関係を切る
			for (k = 0; k < A_Supports[0][i + 2].Length; k++)
			{
				if (A_Supports[0][i + 2].PId[k] == KoPa) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
				   //A_Supports[1][i + 2].Flag = 0;
					for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
					{
						A_Supports[1][i + 2].PId[supportlength] = 0;//配列の初期化
					}
					A_Supports[1][i + 2].Length = 0;//一旦0にする
					for (supportlength = 0; supportlength < A_Supports[0][i + 2].Length; supportlength++)//前の状態で支えている数だけ回す
					{
						if (A_Supports[0][i + 2].PId[supportlength] != KoPa)//一致する子部品は部品箱から取る部品なのでカウントしない
						{
							A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = A_Supports[0][i + 2].PId[supportlength];//一致する子部品以外のデータの移行
							A_Supports[1][i + 2].Length++;//カウントを増やす
						}
					}

					if (A_Supports[1][i + 2].Length == 0)
					{
						A_Supports[1][i + 2].Flag = 0;
					}
					break;
				}
				else if (A_Supports[0][i + 2].PId[k] == OyaPa) {
					//A_Supports[1][i + 2].Flag = 0;
					//A_Supports[1][i + 2].PId = 0;
					for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
					{
						A_Supports[1][i + 2].PId[supportlength] = 0;//配列の初期化
					}
					A_Supports[1][i + 2].Length = 0;//一旦0にする
					for (supportlength = 0; supportlength < A_Supports[0][i + 2].Length; supportlength++)//前の状態で支えている数だけ回す
					{
						if (A_Supports[0][i + 2].PId[supportlength] != OyaPa)//一致する子部品は部品箱から取る部品なのでカウントしない
						{
							A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = A_Supports[0][i + 2].PId[supportlength];//データの移行
							A_Supports[1][i + 2].Length++;//カウントを増やす
						}
					}

					if (A_Supports[1][i + 2].Length == 0)
					{
						A_Supports[1][i + 2].Flag = 0;
					}
					break;
				}
			}
		}

		for (i = 0; i < putting; i++) {//中間製品置き場からとるとき、支えの関係を切る
			for (k = 0; k < A_Supports[0][3 + N + i].Length; k++)
			{
				/*if (A_Supports[0][3 + N + i].PId == KoPa || A_Supports[0][3 + N + i].PId == OyaPa) {
					A_Supports[1][3 + N + i].Flag = 0;
					A_Supports[1][3 + N + i].PId[0] = 0;
				}*/
				if (A_Supports[0][3 + N + i].PId[k] == KoPa) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
				   //A_Supports[1][3 + N + i].Flag = 0;
					for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
					{
						A_Supports[1][3 + N + i].PId[supportlength] = 0;//配列の初期化
					}
					A_Supports[1][3 + N + i].Length = 0;//一旦0にする
					for (supportlength = 0; supportlength < A_Supports[0][3 + N + i].Length; supportlength++)//前の状態で支えている数だけ回す
					{
						if (A_Supports[0][3 + N + i].PId[supportlength] != KoPa)//一致する子部品は部品箱から取る部品なのでカウントしない
						{
							A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = A_Supports[0][3 + N + i].PId[supportlength];//データの移行
							A_Supports[1][3 + N + i].Length++;//カウントを増やす
						}
					}

					if (A_Supports[1][3 + N + i].Length == 0)
					{
						A_Supports[1][3 + N + i].Flag = 0;
					}
					break;
				}
				else if (A_Supports[0][3 + N + i].PId[k] == OyaPa)
				{
					//A_Supports[1][3 + N + i].Flag = 0;
					//A_Supports[1][3 + N + i].PId = 0;
					for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
					{
						A_Supports[1][3 + N + i].PId[supportlength] = 0;//配列の初期化
					}
					A_Supports[1][3 + N + i].Length = 0;//一旦0にする
					for (supportlength = 0; supportlength < A_Supports[0][3 + N + i].Length; supportlength++)//前の状態で支えている数だけ回す
					{
						if (A_Supports[0][3 + N + i].PId[supportlength] != OyaPa)//一致する子部品は部品箱から取る部品なのでカウントしない
						{
							A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = A_Supports[0][3 + N + i].PId[supportlength];//データの移行
							A_Supports[1][3 + N + i].Length++;//カウントを増やす
						}
					}

					if (A_Supports[1][3 + N + i].Length == 0)
					{
						A_Supports[1][3 + N + i].Flag = 0;
					}
					break;
				}
			}
		}

		for (i = 0; i < Jigu; i++)//子部品を治具から取る時に支えの関係を切る
		{
			for (k = 0; k < A_Supports[0][N + 3 + putting + i].Length; k++)
			{
				if (A_Supports[0][N + 3 + putting + i].PId[k] == KoPa) {

					for (supportlength = 0; supportlength < A_Supports[1][N + 3 + putting + i].Length; supportlength++)
					{
						A_Supports[1][N + 3 + putting + i].PId[supportlength] = 0;//配列の初期化
					}
					A_Supports[1][N + 3 + putting + i].Length = 0;//一旦0にする
					for (supportlength = 0; supportlength < A_Supports[0][N + 3 + putting + i].Length; supportlength++)//前の状態で支えている数だけ回す
					{
						if (A_Supports[0][N + 3 + putting + i].PId[supportlength] != KoPa)//一致する子部品は治具から取る部品なのでカウントしない
						{
							A_Supports[1][N + 3 + putting + i].PId[A_Supports[1][N + 3 + putting + i].Length] = A_Supports[0][N + 3 + putting + i].PId[supportlength];//データの移行
							A_Supports[1][N + 3 + putting + i].Length++;//カウントを増やす
						}
					}

					if (A_Supports[1][N + 3 + putting + i].Length == 0)
					{
						A_Supports[1][N + 3 + putting + i].Flag = 0;
					}
					break;
				}
			}
		}


		/*
		A_Supports[1][hidarite].Id = A_Hands[1].Hnum;//親部品と左手の支えの関係をつくる
		A_Supports[1][hidarite].Flag = 1;
		A_Supports[1][hidarite].PId[0] = OyaPa;

		A_Supports[1][migite].Id = A_Hands[0].Hnum;//子部品と右手の支えの関係をつくる
		A_Supports[1][migite].Flag = 1;
		A_Supports[1][migite].PId[0] = KoPa;

		A_Supports[1][3 + N + putting + Jig].Id = A_Jigus[Jig].Jnum;//	治具と親部品の支えの関係をつくる
		A_Supports[1][3 + N + putting + Jig].Flag = 1;
		A_Supports[1][3 + N + putting + Jig].PId[0] = OyaPa;
		*/


		/*回転を考える*/

		for (i = 0; i < 3 * N + 2 + Kougu + putting + Jigu; i++) {
			if (A_Objects[1][i].Id == OyaPa) {
				OyaPnum = i;
			}
			else if (A_Objects[1][i].Id == KoPa) {//子部品と右手の位置を決める
				if (i == 42)
				{
					//printf("***%d\n", A_Objects[1][i].Id);
				}
				KoPnum = i;
			}
		}

		/*移動部品・固定部品と親部品・子部品を紐づける*/
		/*if (Kumi[kuminownum][1] == OyaPa) {//親部品が部品1であるとき
			for (i = 0; i < N; i++) {
				if (Kumi[kuminownum][i + 4] != 0) {
					if (Kumi[kuminownum][i + 4] == KIchi[0][1]) {//親部品＝固定部品
						if (Dir[0][0] == 'X') {
							if (Dir[0][1] == '-') {
								A_Objects[1][KoPnum].DirX = 0;
								A_Objects[1][OyaPnum].DirX = 0;
								A_Objects[1][KoPnum].DirY = 90;
								A_Objects[1][OyaPnum].DirY = 90;
								A_Objects[1][KoPnum].DirZ = 0;
								A_Objects[1][OyaPnum].DirZ = 0;
							}
							else if (Dir[0][1] == '+') {
								A_Objects[1][KoPnum].DirX = 0;
								A_Objects[1][OyaPnum].DirX = 0;
								A_Objects[1][KoPnum].DirY = -90;
								A_Objects[1][OyaPnum].DirY = -90;
								A_Objects[1][KoPnum].DirZ = 0;
								A_Objects[1][OyaPnum].DirZ = 0;
							}
						}
						else if (Dir[0][0] == 'Y') {
							if (Dir[0][1] == '-') {
								A_Objects[1][KoPnum].DirX = -90;
								A_Objects[1][OyaPnum].DirX = -90;
								A_Objects[1][KoPnum].DirY = 0;
								A_Objects[1][OyaPnum].DirY = 0;
								A_Objects[1][KoPnum].DirZ = 0;
								A_Objects[1][OyaPnum].DirZ = 0;
							}
							else if (Dir[0][1] == '+') {
								A_Objects[1][KoPnum].DirX = 90;
								A_Objects[1][OyaPnum].DirX = 90;
								A_Objects[1][KoPnum].DirY = 0;
								A_Objects[1][OyaPnum].DirY = 0;
								A_Objects[1][KoPnum].DirZ = 0;
								A_Objects[1][OyaPnum].DirZ = 0;
							}
						}
						else if (Dir[0][0] == 'Z') {
							if (Dir[0][1] == '-') {
								A_Objects[1][KoPnum].DirX = 180;
								A_Objects[1][OyaPnum].DirX = 180;
								A_Objects[1][KoPnum].DirY = 0;
								A_Objects[1][OyaPnum].DirY = 0;
								A_Objects[1][KoPnum].DirZ = 0;
								A_Objects[1][OyaPnum].DirZ = 0;
							}
							else if (Dir[0][1] == '+') {
								A_Objects[1][KoPnum].DirX = 0;
								A_Objects[1][OyaPnum].DirX = 0;
								A_Objects[1][KoPnum].DirY = 0;
								A_Objects[1][OyaPnum].DirY = 0;
								A_Objects[1][KoPnum].DirZ = 0;
								A_Objects[1][OyaPnum].DirZ = 0;
							}
						}
					}
					else if (Kumi[kuminownum][i + 4] == KIchi[0][2]) {//親部品＝移動部品
						if (Dir[0][0] == 'X') {
							if (Dir[0][1] == '-') {
								A_Objects[1][KoPnum].DirX = 0;
								A_Objects[1][OyaPnum].DirX = 0;
								A_Objects[1][KoPnum].DirY = -90;
								A_Objects[1][OyaPnum].DirY = -90;
								A_Objects[1][KoPnum].DirZ = 0;
								A_Objects[1][OyaPnum].DirZ = 0;
							}
							else if (Dir[0][1] == '+') {
								A_Objects[1][KoPnum].DirX = 0;
								A_Objects[1][OyaPnum].DirX = 0;
								A_Objects[1][KoPnum].DirY = 90;
								A_Objects[1][OyaPnum].DirY = 90;
								A_Objects[1][KoPnum].DirZ = 0;
								A_Objects[1][OyaPnum].DirZ = 0;
							}
						}
						else if (Dir[0][0] == 'Y') {
							if (Dir[0][1] == '-') {
								A_Objects[1][KoPnum].DirX = 90;
								A_Objects[1][OyaPnum].DirX = 90;
								A_Objects[1][KoPnum].DirY = 0;
								A_Objects[1][OyaPnum].DirY = 0;
								A_Objects[1][KoPnum].DirZ = 0;
								A_Objects[1][OyaPnum].DirZ = 0;
							}
							else if (Dir[0][1] == '+') {
								A_Objects[1][KoPnum].DirX = -90;
								A_Objects[1][OyaPnum].DirX = -90;
								A_Objects[1][KoPnum].DirY = 0;
								A_Objects[1][OyaPnum].DirY = 0;
								A_Objects[1][KoPnum].DirZ = 0;
								A_Objects[1][OyaPnum].DirZ = 0;
							}
						}
						else if (Dir[0][0] == 'Z') {
							if (Dir[0][1] == '-') {
								A_Objects[1][KoPnum].DirX = 0;
								A_Objects[1][OyaPnum].DirX = 0;
								A_Objects[1][KoPnum].DirY = 0;
								A_Objects[1][OyaPnum].DirY = 0;
								A_Objects[1][KoPnum].DirZ = 0;
								A_Objects[1][OyaPnum].DirZ = 0;
							}
							else if (Dir[0][1] == '+') {
								A_Objects[1][KoPnum].DirX = 180;
								A_Objects[1][OyaPnum].DirX = 180;
								A_Objects[1][KoPnum].DirY = 0;
								A_Objects[1][OyaPnum].DirY = 0;
								A_Objects[1][KoPnum].DirZ = 0;
								A_Objects[1][OyaPnum].DirZ = 0;
							}
						}
					}
				}
			}
		}
		else if (Kumi[kuminownum][1] != OyaPa) {//親部品が部品1でないとき
			for (i = 0; i < N; i++) {
				if (Kumi[kuminownum][i + 4 + N] != 0) {
					if (Kumi[kuminownum][i + 4 + N] == KIchi[0][1]) {//親部品＝固定部品
						if (Dir[0][0] == 'X') {
							if (Dir[0][1] == '-') {
								A_Objects[1][KoPnum].DirX = 0;
								A_Objects[1][OyaPnum].DirX = 0;
								A_Objects[1][KoPnum].DirY = 90;
								A_Objects[1][OyaPnum].DirY = 90;
								A_Objects[1][KoPnum].DirZ = 0;
								A_Objects[1][OyaPnum].DirZ = 0;
							}
							else if (Dir[0][1] == '+') {
								A_Objects[1][KoPnum].DirX = 0;
								A_Objects[1][OyaPnum].DirX = 0;
								A_Objects[1][KoPnum].DirY = -90;
								A_Objects[1][OyaPnum].DirY = -90;
								A_Objects[1][KoPnum].DirZ = 0;
								A_Objects[1][OyaPnum].DirZ = 0;
							}
						}
						else if (Dir[0][0] == 'Y') {
							if (Dir[0][1] == '-') {
								A_Objects[1][KoPnum].DirX = -90;
								A_Objects[1][OyaPnum].DirX = -90;
								A_Objects[1][KoPnum].DirY = 0;
								A_Objects[1][OyaPnum].DirY = 0;
								A_Objects[1][KoPnum].DirZ = 0;
								A_Objects[1][OyaPnum].DirZ = 0;
							}
							else if (Dir[0][1] == '+') {
								A_Objects[1][KoPnum].DirX = 90;
								A_Objects[1][OyaPnum].DirX = 90;
								A_Objects[1][KoPnum].DirY = 0;
								A_Objects[1][OyaPnum].DirY = 0;
								A_Objects[1][KoPnum].DirZ = 0;
								A_Objects[1][OyaPnum].DirZ = 0;
							}
						}
						else if (Dir[0][0] == 'Z') {
							if (Dir[0][1] == '-') {
								A_Objects[1][KoPnum].DirX = 180;
								A_Objects[1][OyaPnum].DirX = 180;
								A_Objects[1][KoPnum].DirY = 0;
								A_Objects[1][OyaPnum].DirY = 0;
								A_Objects[1][KoPnum].DirZ = 0;
								A_Objects[1][OyaPnum].DirZ = 0;
							}
							else if (Dir[0][1] == '+') {
								A_Objects[1][KoPnum].DirX = 0;
								A_Objects[1][OyaPnum].DirX = 0;
								A_Objects[1][KoPnum].DirY = 0;
								A_Objects[1][OyaPnum].DirY = 0;
								A_Objects[1][KoPnum].DirZ = 0;
								A_Objects[1][OyaPnum].DirZ = 0;
							}
						}
					}
					else if (Kumi[kuminownum][i + 4 + N] == KIchi[0][2]) {//親部品＝移動部品
						if (Dir[0][0] == 'X') {
							if (Dir[0][1] == '-') {
								A_Objects[1][KoPnum].DirX = 0;
								A_Objects[1][OyaPnum].DirX = 0;
								A_Objects[1][KoPnum].DirY = -90;
								A_Objects[1][OyaPnum].DirY = -90;
								A_Objects[1][KoPnum].DirZ = 0;
								A_Objects[1][OyaPnum].DirZ = 0;
							}
							else if (Dir[0][1] == '+') {
								A_Objects[1][KoPnum].DirX = 0;
								A_Objects[1][OyaPnum].DirX = 0;
								A_Objects[1][KoPnum].DirY = 90;
								A_Objects[1][OyaPnum].DirY = 90;
								A_Objects[1][KoPnum].DirZ = 0;
								A_Objects[1][OyaPnum].DirZ = 0;
							}
						}
						else if (Dir[0][0] == 'Y') {
							if (Dir[0][1] == '-') {
								A_Objects[1][KoPnum].DirX = 90;
								A_Objects[1][OyaPnum].DirX = 90;
								A_Objects[1][KoPnum].DirY = 0;
								A_Objects[1][OyaPnum].DirY = 0;
								A_Objects[1][KoPnum].DirZ = 0;
								A_Objects[1][OyaPnum].DirZ = 0;
							}
							else if (Dir[0][1] == '+') {
								A_Objects[1][KoPnum].DirX = -90;
								A_Objects[1][OyaPnum].DirX = -90;
								A_Objects[1][KoPnum].DirY = 0;
								A_Objects[1][OyaPnum].DirY = 0;
								A_Objects[1][KoPnum].DirZ = 0;
								A_Objects[1][OyaPnum].DirZ = 0;
							}
						}
						else if (Dir[0][0] == 'Z') {
							if (Dir[0][1] == '-') {
								A_Objects[1][KoPnum].DirX = 0;
								A_Objects[1][OyaPnum].DirX = 0;
								A_Objects[1][KoPnum].DirY = 0;
								A_Objects[1][OyaPnum].DirY = 0;
								A_Objects[1][KoPnum].DirZ = 0;
								A_Objects[1][OyaPnum].DirZ = 0;
							}
							else if (Dir[0][1] == '+') {
								A_Objects[1][KoPnum].DirX = 180;
								A_Objects[1][OyaPnum].DirX = 180;
								A_Objects[1][KoPnum].DirY = 0;
								A_Objects[1][OyaPnum].DirY = 0;
								A_Objects[1][KoPnum].DirZ = 0;
								A_Objects[1][OyaPnum].DirZ = 0;
							}
						}
					}
				}
			}
		}
		*/

		if (Kumi[kuminownum][1] == OyaPa) {//親部品が部品1であるとき
			for (i = 0; i < N; i++) {
				if (Kumi[kuminownum][i + 4] != 0) {
					if (Kumi[kuminownum][i + 4] == KIchi[0][1])
					{//親部品＝固定部品
						break;
					}
					else if (Kumi[kuminownum][i + 4] == KIchi[0][2]) {//親部品＝移動部品
						if (Dir[0][0] == 'X') {
							if (Dir[0][1] == '-')
							{
								Dir[0][1] = '+';
								break;
							}
							else if (Dir[0][1] == '+')
							{
								Dir[0][1] = '-';
								break;
							}
						}
						else if (Dir[0][0] == 'Y') {
							if (Dir[0][1] == '-')
							{
								Dir[0][1] = '+';
								break;
							}
							else if (Dir[0][1] == '+')
							{
								Dir[0][1] = '-';
								break;
							}
						}
						else if (Dir[0][0] == 'Z') {
							if (Dir[0][1] == '-')
							{
								Dir[0][1] = '+';
								break;
							}
							else if (Dir[0][1] == '+')
							{
								Dir[0][1] = '-';
								break;
							}
						}
					}
				}
			}
		}
		else if (Kumi[kuminownum][1] != OyaPa) {//親部品が部品1でないとき
			for (i = 0; i < N; i++) {
				if (Kumi[kuminownum][i + 4 + N] != 0) {
					if (Kumi[kuminownum][i + 4 + N] == KIchi[0][1])
					{//親部品＝固定部品
						break;
					}
					else if (Kumi[kuminownum][i + 4 + N] == KIchi[0][2]) {//親部品＝移動部品
						if (Dir[0][0] == 'X') {
							if (Dir[0][1] == '-')
							{
								Dir[0][1] = '+';
								break;
							}
							else if (Dir[0][1] == '+')
							{
								Dir[0][1] = '-';
								break;
							}
						}
						else if (Dir[0][0] == 'Y') {
							if (Dir[0][1] == '-')
							{
								Dir[0][1] = '+';
								break;
							}
							else if (Dir[0][1] == '+')
							{
								Dir[0][1] = '-';
								break;
							}
						}
						else if (Dir[0][0] == 'Z') {
							if (Dir[0][1] == '-')
							{
								Dir[0][1] = '+';
								break;
							}
							else if (Dir[0][1] == '+')
							{
								Dir[0][1] = '-';
								break;
							}
						}
					}
				}
			}
		}


		if (Dir[0][0] == 'Z' && Dir[0][1] == '+')DisDir = 0;
		else if (Dir[0][0] == 'Z' && Dir[0][1] == '-')DisDir = 1;
		else if (Dir[0][0] == 'X' && Dir[0][1] == '+')DisDir = 2;
		else if (Dir[0][0] == 'X' && Dir[0][1] == '-')DisDir = 3;
		else if (Dir[0][0] == 'Y' && Dir[0][1] == '+')DisDir = 4;
		else if (Dir[0][0] == 'Y' && Dir[0][1] == '-')DisDir = 5;

		if (NewNOS0 == 0 || (NewNOS0 == 1 && kumijun[line].ZLineDir == -1 && kumijun[line].XLineDir == -1))//古いNOS0の時と新しいNOS0で両方にDが入っている時
		{
			if (strstr(kumijun[line].dir, "上") != NULL || (NewNOS0 == 1 && kumijun[line].ZLineDir == -1 && kumijun[line].XLineDir == -1))//組付け方向が上の時,新しいNOS0で両方にDが入っている時は上からにする
			{
				if (DisDir == 0)//Z+
				{
					kumijun[line].ZLineDir = 0;//Z上
					kumijun[line].XLineDir = 2;//X右
				}
				else if (DisDir == 1)//Z-
				{
					kumijun[line].ZLineDir = 1;//Z下
					kumijun[line].XLineDir = 2;//X右
				}
				else if (DisDir == 2)//X+
				{
					kumijun[line].ZLineDir = 3;//Z左
					kumijun[line].XLineDir = 0;//X上
				}
				else if (DisDir == 3)//X-
				{
					kumijun[line].ZLineDir = 2;//Z右
					kumijun[line].XLineDir = 1;//X下
				}
				else if (DisDir == 4)//Y+
				{
					kumijun[line].ZLineDir = 5;//Z前
					kumijun[line].XLineDir = 2;//X右
				}
				else if (DisDir == 5)//Y-
				{
					kumijun[line].ZLineDir = 4;//Z奥
					kumijun[line].XLineDir = 2;//X右
				}
			}
			else if (strstr(kumijun[line].dir, "下") != NULL)//組付け方向が下の時
			{
				if (DisDir == 0)//Z+
				{
					kumijun[line].ZLineDir = 1;//Z下
					kumijun[line].XLineDir = 2;//X右
				}
				else if (DisDir == 1)//Z-
				{
					kumijun[line].ZLineDir = 0;//Z上
					kumijun[line].XLineDir = 2;//X右
				}
				else if (DisDir == 2)//X+
				{
					kumijun[line].ZLineDir = 2;//Z右
					kumijun[line].XLineDir = 1;//X下
				}
				else if (DisDir == 3)//X-
				{
					kumijun[line].ZLineDir = 3;//Z左
					kumijun[line].XLineDir = 0;//X上
				}
				else if (DisDir == 4)//Y+
				{
					kumijun[line].ZLineDir = 4;//Z奥
					kumijun[line].XLineDir = 2;//X右
				}
				else if (DisDir == 5)//Y-
				{
					kumijun[line].ZLineDir = 5;//Z前
					kumijun[line].XLineDir = 2;//X右
				}
			}
			else if (strstr(kumijun[line].dir, "左") != NULL)//組付け方向が左の時
			{
				if (DisDir == 0)//Z+
				{
					kumijun[line].ZLineDir = 3;//Z左
					kumijun[line].XLineDir = 0;//X上
				}
				else if (DisDir == 1)//Z-
				{
					kumijun[line].ZLineDir = 2;//Z右
					kumijun[line].XLineDir = 1;//X下
				}
				else if (DisDir == 2)//X+
				{
					kumijun[line].ZLineDir = 0;//Z上
					kumijun[line].XLineDir = 3;//X左
				}
				else if (DisDir == 3)//X-
				{
					kumijun[line].ZLineDir = 0;//Z上
					kumijun[line].XLineDir = 2;//X右
				}
				else if (DisDir == 4)//Y+
				{
					kumijun[line].ZLineDir = 0;//Z上
					kumijun[line].XLineDir = 4;//X奥
				}
				else if (DisDir == 5)//Y-
				{
					kumijun[line].ZLineDir = 0;//Z上
					kumijun[line].XLineDir = 5;//X前
				}
			}
			else if (strstr(kumijun[line].dir, "右") != NULL)//組付け方向が右の時
			{
				if (DisDir == 0)//Z+
				{
					kumijun[line].ZLineDir = 2;//Z右
					kumijun[line].XLineDir = 1;//X下
				}
				else if (DisDir == 1)//Z-
				{
					kumijun[line].ZLineDir = 3;//Z左
					kumijun[line].XLineDir = 0;//X上
				}
				else if (DisDir == 2)//X+
				{
					kumijun[line].ZLineDir = 0;//Z上
					kumijun[line].XLineDir = 2;//X右
				}
				else if (DisDir == 3)//X-
				{
					kumijun[line].ZLineDir = 0;//Z上
					kumijun[line].XLineDir = 3;//X左
				}
				else if (DisDir == 4)//Y+
				{
					kumijun[line].ZLineDir = 0;//Z上
					kumijun[line].XLineDir = 5;//X前
				}
				else if (DisDir == 5)//Y-
				{
					kumijun[line].ZLineDir = 0;//Z上
					kumijun[line].XLineDir = 4;//X奥
				}
			}
			else if (strstr(kumijun[line].dir, "前") != NULL)//組付け方向が前の時
			{
				if (DisDir == 0)//Z+
				{
					kumijun[line].ZLineDir = 5;//Z前
					kumijun[line].XLineDir = 2;//X右
				}
				else if (DisDir == 1)//Z-
				{
					kumijun[line].ZLineDir = 4;//Z奥
					kumijun[line].XLineDir = 2;//X右
				}
				else if (DisDir == 2)//X+
				{
					kumijun[line].ZLineDir = 0;//Z上
					kumijun[line].XLineDir = 5;//X前
				}
				else if (DisDir == 3)//X-
				{
					kumijun[line].ZLineDir = 0;//Z上
					kumijun[line].XLineDir = 4;//X奥
				}
				else if (DisDir == 4)//Y+
				{
					kumijun[line].ZLineDir = 0;//Z上
					kumijun[line].XLineDir = 3;//X左
				}
				else if (DisDir == 5)//Y-
				{
					kumijun[line].ZLineDir = 0;//Z上
					kumijun[line].XLineDir = 2;//X右
				}
			}
			else if (strstr(kumijun[line].dir, "奥") != NULL)//組付け方向が奥の時
			{
				if (DisDir == 0)//Z+
				{
					kumijun[line].ZLineDir = 4;//Z奥
					kumijun[line].XLineDir = 2;//X右
				}
				else if (DisDir == 1)//Z-
				{
					kumijun[line].ZLineDir = 5;//Z前
					kumijun[line].XLineDir = 2;//X右
				}
				else if (DisDir == 2)//X+
				{
					kumijun[line].ZLineDir = 0;//Z上
					kumijun[line].XLineDir = 4;//X
				}
				else if (DisDir == 3)//X-
				{
					kumijun[line].ZLineDir = 0;//Z上
					kumijun[line].XLineDir = 5;//X前
				}
				else if (DisDir == 4)//Y+
				{
					kumijun[line].ZLineDir = 0;//Z上
					kumijun[line].XLineDir = 2;//X右
				}
				else if (DisDir == 5)//Y-
				{
					kumijun[line].ZLineDir = 0;//Z上
					kumijun[line].XLineDir = 3;//X左
				}
			}
		}

		//Z上
		if (kumijun[line].ZLineDir == 0) {
			//X右
			if (kumijun[line].XLineDir == 2) {
				DirDecision(0, 0, 0);
				kumijun[line].YLineDir = 4;
			}
			//X前
			else if (kumijun[line].XLineDir == 5) {
				DirDecision(0, 0, -90);
				kumijun[line].YLineDir = 2;
			}
			//X左
			else if (kumijun[line].XLineDir == 3) {
				DirDecision(0, 0, -180);
				kumijun[line].YLineDir = 5;
			}
			//X奥
			else if (kumijun[line].XLineDir == 4) {
				DirDecision(0, 0, 90);
				kumijun[line].YLineDir = 3;
			}
		}
		//Z右
		else if (kumijun[line].ZLineDir == 2) {
			//X下
			if (kumijun[line].XLineDir == 1) {
				DirDecision(0, 90, 0);
				kumijun[line].YLineDir = 4;
			}
			//X奥
			else if (kumijun[line].XLineDir == 4) {
				DirDecision(90, 0, 90);
				kumijun[line].YLineDir = 0;
			}
			//X上
			else if (kumijun[line].XLineDir == 0) {
				DirDecision(0, -90, 180);
				kumijun[line].YLineDir = 5;
			}
			//X前
			else if (kumijun[line].XLineDir == 5) {
				DirDecision(-90, 0, -90);
				kumijun[line].YLineDir = 1;
			}

		}
		//Z左
		else if (kumijun[line].ZLineDir == 3) {
			//X上
			if (kumijun[line].XLineDir == 0) {
				DirDecision(0, -90, 0);
				kumijun[line].YLineDir = 4;
			}
			//X前
			else if (kumijun[line].XLineDir == 5) {
				DirDecision(90, 0, -90);
				kumijun[line].YLineDir = 0;
			}
			//X下
			else if (kumijun[line].XLineDir == 1) {
				DirDecision(180, 90, 0);
				kumijun[line].YLineDir = 5;
			}
			//X奥
			else if (kumijun[line].XLineDir == 4) {
				DirDecision(-90, 0, 90);
				kumijun[line].YLineDir = 1;
			}
		}
		//Z前
		else if (kumijun[line].ZLineDir == 5) {
			//X右
			if (kumijun[line].XLineDir == 2) {
				DirDecision(90, 0, 0);
				kumijun[line].YLineDir = 0;
			}
			//X下
			else if (kumijun[line].XLineDir == 1) {
				DirDecision(90, 90, 0);
				kumijun[line].YLineDir = 2;
			}
			//X左
			else if (kumijun[line].XLineDir == 3) {
				DirDecision(90, -180, 0);
				kumijun[line].YLineDir = 1;
			}
			//X上
			else if (kumijun[line].XLineDir == 0) {
				DirDecision(90, -90, 0);
				kumijun[line].YLineDir = 3;
			}
		}
		//Z奥
		else if (kumijun[line].ZLineDir == 4) {
			//X右
			if (kumijun[line].XLineDir == 2) {
				DirDecision(-90, 0, 0);
				kumijun[line].YLineDir = 1;
			}
			//X下
			else if (kumijun[line].XLineDir == 1) {
				DirDecision(-90, 90, 0);
				kumijun[line].YLineDir = 3;
			}
			//X左
			else if (kumijun[line].XLineDir == 3) {
				DirDecision(-90, -180, 0);
				kumijun[line].YLineDir = 0;
			}
			//X上
			else if (kumijun[line].XLineDir == 0) {
				DirDecision(-90, -90, 0);
				kumijun[line].YLineDir = 2;
			}
		}
		//Z下
		else if (kumijun[line].ZLineDir == 1) {
			//X右
			if (kumijun[line].XLineDir == 2) {
				DirDecision(180, 0, 0);
				kumijun[line].YLineDir = 5;
			}
			//X前
			else if (kumijun[line].XLineDir == 5) {
				DirDecision(180, 0, -90);
				kumijun[line].YLineDir = 3;
			}
			//X左
			else if (kumijun[line].XLineDir == 3) {
				DirDecision(180, 0, -180);
				kumijun[line].YLineDir = 4;
			}
			//X奥
			else if (kumijun[line].XLineDir == 4) {
				DirDecision(180, 0, 90);
				kumijun[line].YLineDir = 2;
			}
		}

		//分解方向が軸の向いている向きの場合、組付け方向は軸の向いている向きと同一
		if (DisDir == 2)AsmDir = kumijun[line].XLineDir;     //分解方向右
		else if (DisDir == 4)AsmDir = kumijun[line].YLineDir;//分解方向奥
		else if (DisDir == 0)AsmDir = kumijun[line].ZLineDir;//分解方向上
		//分解方向が軸の向いている向きと逆向きの場合、組付け方向は軸の向いている向きと逆向き
		//分解方向左
		else if (DisDir == 3) {
			if (kumijun[line].XLineDir == 0)AsmDir = 1;
			else if (kumijun[line].XLineDir == 1)AsmDir = 0;
			else if (kumijun[line].XLineDir == 2)AsmDir = 3;
			else if (kumijun[line].XLineDir == 3)AsmDir = 2;
			else if (kumijun[line].XLineDir == 4)AsmDir = 5;
			else if (kumijun[line].XLineDir == 5)AsmDir = 4;
		}
		//分解方向前
		else if (DisDir == 5) {
			if (kumijun[line].YLineDir == 0)AsmDir = 1;
			else if (kumijun[line].YLineDir == 1)AsmDir = 0;
			else if (kumijun[line].YLineDir == 2)AsmDir = 3;
			else if (kumijun[line].YLineDir == 3)AsmDir = 2;
			else if (kumijun[line].YLineDir == 4)AsmDir = 5;
			else if (kumijun[line].YLineDir == 5)AsmDir = 4;
		}
		//分解方向下
		else if (DisDir == 1) {
			if (kumijun[line].ZLineDir == 0)AsmDir = 1;
			else if (kumijun[line].ZLineDir == 1)AsmDir = 0;
			else if (kumijun[line].ZLineDir == 2)AsmDir = 3;
			else if (kumijun[line].ZLineDir == 3)AsmDir = 2;
			else if (kumijun[line].ZLineDir == 4)AsmDir = 5;
			else if (kumijun[line].ZLineDir == 5)AsmDir = 4;
		}

		if (OyaPa > N) {
			for (i = 0; i < e; i++) {//親部品の構成部品を調べる
				if (A_Tyukantyusin[i].TyukanNum == OyaPa) {
					JiguKousei = A_Tyukantyusin[i].Tyusin;
				}
			}

			for (i = 0; i < N; i++) {//治具の組付け暫定的な位置
				if (A_Buhin[i].Buhinnum == JiguKousei) {
					JiguZ = A_Buhin[i].Lengrh_Z / 2;
					for (j = 0; j < N; j++) {

					}
				}
			}

		}

		for (i = 0; i < N; i++) {//治具の組付け暫定的な位置
			if (A_Buhin[i].Buhinnum == OyaPa) {
				JiguZ = A_Buhin[i].Lengrh_Z / 2;
				//Sa = 0;
			}
		}

		MaikingOffset(line, &OyaJigX, &OyaJigY, &OyaJigZ);

		//親部品の位置を決める
		for (i = 0; i < 3 * N + 2 + Kougu + putting + Jigu; i++) {
			if (A_Objects[1][i].Id == OyaPa) {//左手と親部品の位置を治具と同じ位置にする
				A_Objects[1][i].IchiX = OyaJigX;//親部品
				A_Objects[1][i].IchiY = OyaJigY;
				A_Objects[1][i].IchiZ = OyaJigZ;
				/*A_Objects[1][i].IchiX = A_Objects[1][3 * N + 2 + putting + Jig].IchiX;//親部品
				A_Objects[1][i].IchiY = A_Objects[1][3 * N + 2 + putting + Jig].IchiY;
				A_Objects[1][i].IchiZ = A_Objects[1][3 * N + 2 + putting + Jig].IchiZ + JiguZ;*/
				//A_Objects[1][2 * N].IchiX = A_Objects[1][3 * N + 2 + putting].IchiX;//左手
				//A_Objects[1][2 * N].IchiY = A_Objects[1][3 * N + 2 + putting].IchiY;
				//A_Objects[1][2 * N].IchiZ = A_Objects[1][3 * N + 2 + putting].IchiZ + JiguZ;
				OyaPnum = i;
			}

			else if (A_Objects[1][i].Id == KoPa)
				//if (A_Objects[1][i].Id == KoPa)
			{//子部品と右手の位置を決める
				KoPnum = i;
				if (p == 1) {//用いる接触線が一つの時はそのAPPとOffsetの値はそれに依存するので場合分け
					if (Dir[0][0] == 'X') {
						if (Dir[0][1] == '-') {
							KoPaIchi = AAO[0][0] - AAO[0][1];//ASPからAPPを引いてます

						}
						else if (Dir[0][1] == '+') {
							KoPaIchi = AAO[0][1] - AAO[0][0];//APPからASPを引いてます
						}
					}
					else if (Dir[0][0] == 'Y') {
						if (Dir[0][1] == '-') {
							KoPaIchi = AAO[0][0] - AAO[0][1];
						}
						else if (Dir[0][1] == '+') {
							KoPaIchi = AAO[0][1] - AAO[0][0];
						}
					}
					else if (Dir[0][0] == 'Z') {
						if (Dir[0][1] == '-') {
							KoPaIchi = AAO[0][0] - AAO[0][1];
						}
						else if (Dir[0][1] == '+') {
							KoPaIchi = AAO[0][1] - AAO[0][0];
						}
					}

				}

				else {//接触線が二つ以上あるとき
					j = 0;
					for (q = 0; q < p; q++) {
						if (Dir[q][0] == 'X') {
							if (Dir[q][1] == '-') {
								h[j] = AAO[q][0] - AAO[q][1];
							}
							else if (Dir[q][1] == '+') {
								h[j] = AAO[q][1] - AAO[q][0];
							}
						}
						else if (Dir[q][0] == 'Y') {
							if (Dir[q][1] == '-') {
								h[j] = AAO[q][0] - AAO[q][1];
							}
							else if (Dir[q][1] == '+') {
								h[j] = AAO[q][1] - AAO[q][0];
							}
						}
						else if (Dir[q][0] == 'Z') {
							if (Dir[q][1] == '-') {
								h[j] = AAO[q][0] - AAO[q][1];
							}
							else if (Dir[q][1] == '+') {
								h[j] = AAO[q][1] - AAO[q][0];
							}
						}
						if (j == 0) {
							KoPaIchi = h[j];
						}
						if (h[j] > h[j - 1]) {
							KoPaIchi = h[j];
						}
						j++;

					}

				}

				//printf("%lf\n",KoPaIchi);

				//組付ける方向が左、前、下の場合、符号は負
				if (AsmDir == 1 || AsmDir == 3 || AsmDir == 5)KoPaIchi = -fabs(KoPaIchi);
				//組付ける方向が上、右、奥の場合、符号は正
				else KoPaIchi = fabs(KoPaIchi);
				//組付ける方向が上か下
				if (AsmDir == 0 || AsmDir == 1) {

					AsmDistanceZ = KoPaIchi;
				}
				//組付ける方向が右か左
				else if (AsmDir == 2 || AsmDir == 3) {
					AsmDistanceX = KoPaIchi;
				}
				//組付ける方向が奥か前
				else if (AsmDir == 4 || AsmDir == 5) {
					AsmDistanceY = KoPaIchi;
				}

				A_Objects[1][i].IchiX = KIdo_X + AsmDistanceX;//子部品
				A_Objects[1][i].IchiY = KIdo_Y + AsmDistanceY;
				A_Objects[1][i].IchiZ = KIdo_Z + AsmDistanceZ;
				//A_Objects[1][2 * N - 1].IchiX = KIdo_X;//右手
				//A_Objects[1][2 * N - 1].IchiY = KIdo_Y;
				//A_Objects[1][2 * N - 1].IchiZ = KIdo_Z + KoPaIchi;
			}
		}

		//中間製品の中心点になる部品を記録します
		if (e == 0) {
			A_Tyukantyusin[e].TyukanNum = TyuPa;
			A_Tyukantyusin[e].Tyusin = OyaPa;
		}
		else {
			if (OyaPa <= N) {
				A_Tyukantyusin[e].TyukanNum = TyuPa;
				A_Tyukantyusin[e].Tyusin = OyaPa;
			}
			else {
				A_Tyukantyusin[e].TyukanNum = TyuPa;
				for (f = 0; f < e; f++) {
					if (OyaPa == A_Tyukantyusin[f].TyukanNum) {
						A_Tyukantyusin[e].Tyusin = A_Tyukantyusin[f].Tyusin;
					}
				}
			}
		}
		e++;

		//KouguFlag = 0;//とりあえず、工具のフラグは0にしておく

		////工具を用いるか調べる////
		if (kumijun[line].kougu != 0)//工具を用いる時
		{
			A_Objects[1][3 * N + 2 + putting + Jigu + KouguNum].IchiX = A_Objects[1][KoPnum].IchiX;//工具と子部品の位置を合わせる
			A_Objects[1][3 * N + 2 + putting + Jigu + KouguNum].IchiY = A_Objects[1][KoPnum].IchiY;//工具と子部品の位置を合わせる
			A_Objects[1][3 * N + 2 + putting + Jigu + KouguNum].IchiZ = A_Objects[1][KoPnum].IchiZ;//工具と子部品の位置を合わせる
		}

		if (kumijun[line - 1].kougu != kumijun[line].kougu && line != 0 && kumijun[line - 1].kougu != 0)//組立順序の最初でなく使用する工具が変更されている時、前の組立で用いた工具を工具置き場に戻すので工具置き場の位置に合わせる
		{
			A_Objects[1][3 * N + 2 + putting + Jigu + BeforeKouguNum].IchiX = A_Kougus[BeforeKouguNum].IchiX;//工具の位置を工具置き場にする
			A_Objects[1][3 * N + 2 + putting + Jigu + BeforeKouguNum].IchiY = A_Kougus[BeforeKouguNum].IchiY;//工具の位置を工具置き場にする
			A_Objects[1][3 * N + 2 + putting + Jigu + BeforeKouguNum].IchiZ = A_Kougus[BeforeKouguNum].IchiZ;//工具の位置を工具置き場にする
		}
		/*if (Jyunjyo[line][4] != 0) {//工具を用いているとき

			if (line == 0) {//一回目の組付けの時
				KouguFlag = 1;//一回目の組付けで工具を持ってくるとき

				KPRenzoku = KouguPnum[Rcount][1];

				for (j = 0; j < Kougu; j++) {
					if (A_Kougus[j].Bnum == KouguPnum[Rcount][2]) {//持ってくる工具が工具の構造体の何番目にあるか特定
						Kougunum = j;
					}
				}
				Rcount++;

				if (Jyunjyo[line][4] == 1) {//工具のパターンが1のとき
					A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiX = KIdo_X;//工具の位置を子部品を同じにする
					A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiY = KIdo_Y;
					A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = KIdo_Z + KoPaIchi;
					A_Supports[1][Kougunum + N + 3 + putting + Jigu].Flag = 1;//子部品と工具の支えの関係を作る
					A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId = KoPa;
				}
				else if (Jyunjyo[line][4] == 2) {//工具のパターンが2のとき
					A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiX = KIdo_X;//工具の位置を子部品を同じにする
					A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiY = KIdo_Y;
					A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = KIdo_Z + KoPaIchi;
					A_Supports[1][Kougunum + N + 3 + putting + Jigu].Flag = 1;//子部品と工具の支えの関係を作る
					A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId = KoPa;
				}
				else if (Jyunjyo[line][4] == 4) {//工具のパターンが4のとき
					for (i = 1; i < KPRenzoku; i++) {//連続する分のネジを左手と同じ位置にする
						for (j = 0; j < N; j++) {
							if (A_Objects[1][j].Id == Jyunjyo[line + i][Ko]) {//連続する分の子部品の状態の行を探す
								A_Objects[1][j].IchiX = A_Objects[1][2 * N - 1].IchiX;
								A_Objects[1][j].IchiY = A_Objects[1][2 * N - 1].IchiY;
								A_Objects[1][j].IchiZ = A_Objects[1][2 * N - 1].IchiZ + 100;
								A_Objects[1][j].DirX = A_Objects[1][KoPnum].DirX;
								A_Objects[1][j].DirY = A_Objects[1][KoPnum].DirY;
								A_Objects[1][j].DirZ = A_Objects[1][KoPnum].DirZ;
							}
						}

					}

					A_Objects[1][2 * N].IchiX = A_Objects[1][2 * N - 1].IchiX;//左手の位置を最初の組付け位置の上にする
					A_Objects[1][2 * N].IchiY = A_Objects[1][2 * N - 1].IchiY;
					A_Objects[1][2 * N].IchiZ = A_Objects[1][2 * N - 1].IchiZ + 100;



					A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiX = KIdo_X;//工具の位置を子部品を同じにする
					A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiY = KIdo_Y;
					A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = KIdo_Z + KoPaIchi;
					A_Supports[1][Kougunum + N + 3 + putting + Jigu].Flag = 1;//子部品と工具の支えの関係を作る
					A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId = KoPa;
				}
				else if (Jyunjyo[line][4] == 3) {//工具のパターンが3のとき

					A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiX = KIdo_X;//工具の位置を子部品を同じにする
					A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiY = KIdo_Y;
					A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = KIdo_Z + KoPaIchi;
					A_Supports[1][Kougunum + N + 3 + putting + Jigu].Flag = 1;//子部品と工具の支えの関係を作る
					A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId = KoPa;


					for (i = 0; i < KPRenzoku; i++) {//連続する分のネジを組付け前の位置と同じにする

						KP4MaikingOffset(Jyunjyo[line + i][Ko]);//その後の子部品の位置を計算する関数

						for (j = 0; j < N; j++) {
							if (A_Objects[1][j].Id == Jyunjyo[line + i][Ko]) {//連続する分の子部品の状態の行を探す
								A_Objects[1][j].IchiX = KKIdo_X;
								A_Objects[1][j].IchiY = KKIdo_Y;
								A_Objects[1][j].IchiZ = KKIdo_Z + KoPaIchi;
							}
						}

					}
				}
				else if (Jyunjyo[line][4] == 5) {//工具のパターンが5のとき
					A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiX = KIdo_X;//工具の位置を子部品を同じにする
					A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiY = KIdo_Y;
					A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = KIdo_Z + KoPaIchi;
					A_Supports[1][Kougunum + N + 3 + putting + Jigu].Flag = 1;//子部品と工具の支えの関係を作る
					A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId = KoPa;




					for (i = 1; i < KPRenzoku; i++) {//連続する分のネジを組付け前の位置と同じにする

						KP4MaikingOffset(Jyunjyo[line + i][Ko]);//その後の子部品の位置を計算する関数

						for (j = 0; j < N; j++) {
							if (A_Objects[1][j].Id == Jyunjyo[line + i][Ko]) {//連続する分の子部品の状態の行を探す
								A_Objects[1][j].IchiX = KKIdo_X;
								A_Objects[1][j].IchiY = KKIdo_Y;
								A_Objects[1][j].IchiZ = KKIdo_Z + KoPaIchi;
								A_Objects[1][j].DirX = A_Objects[1][KoPnum].DirX;
								A_Objects[1][j].DirY = A_Objects[1][KoPnum].DirY;
								A_Objects[1][j].DirZ = A_Objects[1][KoPnum].DirZ;
							}
						}

					}
				}

			}
			else {//二回目以降の組付け
				if (KPRenzoku == 0) {//連続の残数が残り0だったとき(工具を持ってくる必要あるとき、工具のパターンが変わるとき)



					KPRenzoku = KouguPnum[Rcount][1];


					for (j = 0; j < Kougu; j++) {
						if (A_Kougus[j].Bnum == KouguPnum[Rcount - 1][2]) {//戻す工具が工具の構造体の何番目にあるか特定
							Kougunum0 = j;
						}
						if (A_Kougus[j].Bnum == KouguPnum[Rcount][2]) {//持ってくる工具が工具の構造体の何番目にあるか特定
							Kougunum = j;
						}
					}

					Rcount++;

					if (Jyunjyo[line - 1][4] != 0) {//工具を戻す必要があるとき

						A_Objects[1][3 * N + 2 + Kougunum0 + putting + Jigu].IchiX = A_Kougus[Kougunum0].IchiX;//工具は元の位置にある
						A_Objects[1][3 * N + 2 + Kougunum0 + putting + Jigu].IchiY = A_Kougus[Kougunum0].IchiY;
						A_Objects[1][3 * N + 2 + Kougunum0 + putting + Jigu].IchiZ = A_Kougus[Kougunum0].IchiZ;
						KouguFlag = 4;//使う工具が前回と今回で変わるとき



						if (Jyunjyo[line][4] == 1) {//工具のパターンが1のとき
							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiX = KIdo_X;//工具の位置を子部品を同じにする
							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiY = KIdo_Y;
							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = KIdo_Z + KoPaIchi;
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].Flag = 1;//子部品と工具の支えの関係を作る
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId = KoPa;
						}
						else if (Jyunjyo[line][4] == 2) {//工具のパターンが2のとき
							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiX = KIdo_X;//工具の位置を子部品を同じにする
							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiY = KIdo_Y;
							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = KIdo_Z + KoPaIchi;
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].Flag = 1;//子部品と工具の支えの関係を作る
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId = KoPa;
						}
						else if (Jyunjyo[line][4] == 4) {//工具のパターンが4のとき
							for (i = 1; i < KPRenzoku; i++) {//連続する分のネジを左手と同じ位置にする
								for (j = 0; j < N; j++) {
									if (A_Objects[1][j].Id == Jyunjyo[line + i][Ko]) {//連続する分の子部品の状態の行を探す
										A_Objects[1][j].IchiX = A_Objects[1][2 * N - 1].IchiX;
										A_Objects[1][j].IchiY = A_Objects[1][2 * N - 1].IchiY;
										A_Objects[1][j].IchiZ = A_Objects[1][2 * N - 1].IchiZ + 100;
										A_Objects[1][j].DirX = A_Objects[1][KoPnum].DirX;
										A_Objects[1][j].DirY = A_Objects[1][KoPnum].DirY;
										A_Objects[1][j].DirZ = A_Objects[1][KoPnum].DirZ;
									}
								}

							}
							A_Objects[1][2 * N].IchiX = A_Objects[1][2 * N - 1].IchiX;//左手の位置を最初の組付け位置の上にする
							A_Objects[1][2 * N].IchiY = A_Objects[1][2 * N - 1].IchiY;
							A_Objects[1][2 * N].IchiZ = A_Objects[1][2 * N - 1].IchiZ + 100;


							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiX = KIdo_X;//工具の位置を子部品を同じにする
							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiY = KIdo_Y;
							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = KIdo_Z + KoPaIchi;
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].Flag = 1;//子部品と工具の支えの関係を作る
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId = KoPa;
						}
						else if (Jyunjyo[line][4] == 3) {//工具のパターンが3のとき

							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiX = KIdo_X;//工具の位置を子部品を同じにする
							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiY = KIdo_Y;
							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = KIdo_Z + KoPaIchi;
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].Flag = 1;//子部品と工具の支えの関係を作る
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId = KoPa;


							for (i = 0; i < KPRenzoku; i++) {//連続する分のネジを組付け前の位置と同じにする

								KP4MaikingOffset(Jyunjyo[line + i][Ko]);//その後の子部品の位置を計算する関数

								for (j = 0; j < N; j++) {
									if (A_Objects[1][j].Id == Jyunjyo[line + i][Ko]) {//連続する分の子部品の状態の行を探す
										A_Objects[1][j].IchiX = KKIdo_X;
										A_Objects[1][j].IchiY = KKIdo_Y;
										A_Objects[1][j].IchiZ = KKIdo_Z + KoPaIchi;
									}
								}

							}
						}
						else if (Jyunjyo[line][4] == 5) {//工具のパターンが5のとき
							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiX = KIdo_X;//工具の位置を子部品を同じにする
							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiY = KIdo_Y;
							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = KIdo_Z + KoPaIchi;
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].Flag = 1;//子部品と工具の支えの関係を作る
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId = KoPa;


							for (i = 1; i < KPRenzoku; i++) {//連続する分のネジを組付け前の位置と同じにする

								KP4MaikingOffset(Jyunjyo[line + i][Ko]);//その後の子部品の位置を計算する関数

								for (j = 0; j < N; j++) {
									if (A_Objects[1][j].Id == Jyunjyo[line + i][Ko]) {//連続する分の子部品の状態の行を探す
										A_Objects[1][j].IchiX = KKIdo_X;
										A_Objects[1][j].IchiY = KKIdo_Y;
										A_Objects[1][j].IchiZ = KKIdo_Z + KoPaIchi;
										A_Objects[1][j].DirX = A_Objects[1][KoPnum].DirX;
										A_Objects[1][j].DirY = A_Objects[1][KoPnum].DirY;
										A_Objects[1][j].DirZ = A_Objects[1][KoPnum].DirZ;
									}
								}

							}
						}
					}
					else {//工具を戻す必要がないとき
						KouguFlag = 1;//工具を前回は使っていなくて、今回は使うとき

						if (Jyunjyo[line][4] == 1) {//工具のパターンが1のとき
							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiX = KIdo_X;//工具の位置を子部品を同じにする
							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiY = KIdo_Y;
							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = KIdo_Z + KoPaIchi;
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].Flag = 1;//子部品と工具の支えの関係を作る
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId = KoPa;
						}
						else if (Jyunjyo[line][4] == 2) {//工具のパターンが2のとき
							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiX = KIdo_X;//工具の位置を子部品を同じにする
							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiY = KIdo_Y;
							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = KIdo_Z + KoPaIchi;
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].Flag = 1;//子部品と工具の支えの関係を作る
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId = KoPa;
						}
						else if (Jyunjyo[line][4] == 4) {//工具のパターンが4のとき
							for (i = 1; i < KPRenzoku;i++) {//連続する分のネジを左手と同じ位置にする
								for (j = 0; j < N; j++) {
									if (A_Objects[1][j].Id == Jyunjyo[line + i][Ko]) {//連続する分の子部品の状態の行を探す
										A_Objects[1][j].IchiX = A_Objects[1][2 * N - 1].IchiX;
										A_Objects[1][j].IchiY = A_Objects[1][2 * N - 1].IchiY;
										A_Objects[1][j].IchiZ = A_Objects[1][2 * N - 1].IchiZ + 100;
										A_Objects[1][j].DirX = A_Objects[1][KoPnum].DirX;
										A_Objects[1][j].DirY = A_Objects[1][KoPnum].DirY;
										A_Objects[1][j].DirZ = A_Objects[1][KoPnum].DirZ;
									}
								}

							}
							A_Objects[1][2 * N].IchiX = A_Objects[1][2 * N - 1].IchiX;//左手の位置を最初の組付け位置の上にする
							A_Objects[1][2 * N].IchiY = A_Objects[1][2 * N - 1].IchiY;
							A_Objects[1][2 * N].IchiZ = A_Objects[1][2 * N - 1].IchiZ + 100;


							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiX = KIdo_X;//工具の位置を子部品を同じにする
							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiY = KIdo_Y;
							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = KIdo_Z + KoPaIchi;
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].Flag = 1;//子部品と工具の支えの関係を作る
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId = KoPa;
						}
						else if (Jyunjyo[line][4] == 3) {//工具のパターンが3のとき

							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiX = KIdo_X;//工具の位置を子部品を同じにする
							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiY = KIdo_Y;
							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = KIdo_Z + KoPaIchi;
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].Flag = 1;//子部品と工具の支えの関係を作る
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId = KoPa;


							for (i = 0; i < KPRenzoku; i++) {//連続する分のネジを組付け前の位置と同じにする

								KP4MaikingOffset(Jyunjyo[line + i][Ko]);//その後の子部品の位置を計算する関数

								for (j = 0; j < N; j++) {
									if (A_Objects[1][j].Id == Jyunjyo[line + i][Ko]) {//連続する分の子部品の状態の行を探す
										A_Objects[1][j].IchiX = KKIdo_X;
										A_Objects[1][j].IchiY = KKIdo_Y;
										A_Objects[1][j].IchiZ = KKIdo_Z + KoPaIchi;
									}
								}

							}
						}
						else if (Jyunjyo[line][4] == 5) {//工具のパターンが5のとき
							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiX = KIdo_X;//工具の位置を子部品を同じにする
							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiY = KIdo_Y;
							A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = KIdo_Z + KoPaIchi;
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].Flag = 1;//子部品と工具の支えの関係を作る
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId = KoPa;


							for (i = 1; i < KPRenzoku; i++) {//連続する分のネジを組付け前の位置と同じにする

								KP4MaikingOffset(Jyunjyo[line + i][Ko]);//その後の子部品の位置を計算する関数

								for (j = 0; j < N; j++) {
									if (A_Objects[1][j].Id == Jyunjyo[line + i][Ko]) {//連続する分の子部品の状態の行を探す
										A_Objects[1][j].IchiX = KKIdo_X;
										A_Objects[1][j].IchiY = KKIdo_Y;
										A_Objects[1][j].IchiZ = KKIdo_Z + KoPaIchi;
										A_Objects[1][j].DirX = A_Objects[1][KoPnum].DirX;
										A_Objects[1][j].DirY = A_Objects[1][KoPnum].DirY;
										A_Objects[1][j].DirZ = A_Objects[1][KoPnum].DirZ;
									}
								}

							}
						}


					}
				}
				else {//二本目以降の場合(工具をそのまま使うとき)
					KouguFlag = 3;//工具をそのまま使うとき
					if (Jyunjyo[line][4] == 4) {//工具のパターンが4のとき
						A_Objects[1][2 * N].IchiX = A_Objects[1][2 * N - 1].IchiX;//左手の位置を最初の組付け位置の上にする
						A_Objects[1][2 * N].IchiY = A_Objects[1][2 * N - 1].IchiY;
						A_Objects[1][2 * N].IchiZ = A_Objects[1][2 * N - 1].IchiZ + 100;

						A_Objects[1][2 * N].IchiX = A_Objects[0][2 * N].IchiX;//左手の位置を最初の組付け位置の上にする
						A_Objects[1][2 * N].IchiY = A_Objects[0][2 * N].IchiY;
						A_Objects[1][2 * N].IchiZ = A_Objects[0][2 * N].IchiZ;
					}
					if (Jyunjyo[line][4] == 5) {//工具のパターンが5のとき
						A_Objects[1][2 * N - 1].IchiX = KIdo_X;//右手の位置を子部品と同じにする
						A_Objects[1][2 * N - 1].IchiY = KIdo_Y;
						A_Objects[1][2 * N - 1].IchiZ = KIdo_Z + KoPaIchi;
					}


					A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiX = KIdo_X;//工具の位置を子部品を同じにする
					A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiY = KIdo_Y;
					A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = KIdo_Z + KoPaIchi;

					A_Supports[1][Kougunum + N + 3 + putting + Jigu].Flag = 1;//子部品と工具の支えの関係を作る
					A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId = KoPa;
				}


			}



		}
		else {//工具を用いていないとき
			if (Jyunjyo[line - 1][4] != 0) {//ひとつ前の組付けで工具を用いているとき
				KouguFlag = 2;//工具を前回は使ったけど、今回は使わないとき



				for (j = 0; j < Kougu; j++) {
					if (A_Kougus[j].Bnum == KouguPnum[Rcount - 1][2]) {//戻す工具が工具の構造体の何番目にあるか特定
						Kougunum0 = j;
					}
				}




				A_Objects[1][3 * N + 2 + Kougunum0 + putting + Jigu].IchiX = A_Kougus[Kougunum0].IchiX;//工具は元の位置にある
				A_Objects[1][3 * N + 2 + Kougunum0 + putting + Jigu].IchiY = A_Kougus[Kougunum0].IchiY;
				A_Objects[1][3 * N + 2 + Kougunum0 + putting + Jigu].IchiZ = A_Kougus[Kougunum0].IchiZ;

				KPRenzoku = 0;
			}

		}*/

		//if ((scenetype == oya2ko2 || scenetype == oya2ko2 || scenetype == oya1ko2) && roopcount == 0)
		if (roopcount == 0 && roop == 2)//組立順序2行分組立を行うときで、一行目の組立の状態を作り終わった時
		{
			if (Oya2Jigflag != 3)//両方とも治具についている時でないとき
			{
				for (i = 0; i < e; i++)//親部品の中心になっている単体部品を探す(中間製品の時)
				{
					if (kumijun[line].oya == A_Tyukantyusin[i].TyukanNum)
					{
						oyanum1 = A_Tyukantyusin[i].Tyusin;
					}
					else if (kumijun[line + 1].oya == A_Tyukantyusin[i].TyukanNum)
					{
						oyanum2 = A_Tyukantyusin[i].Tyusin;
					}
				}
				for (i = 0; i < N; i++)//親部品の中心の単体部品がA_Buhinでどこにあるか
				{
					if (A_Buhin[i].Buhinnum == oyanum1 || A_Buhin[i].Buhinnum == kumijun[line].oya)
					{
						oyaBnum1 = i;
					}
					else if (A_Buhin[i].Buhinnum == oyanum2 || A_Buhin[i].Buhinnum == kumijun[line + 1].oya)
					{
						oyaBnum2 = i;
					}
				}

				//親部品同士の間隔を見る時は回転は考慮しなくても大丈夫
				if (Oya2flag == 1 && kumijun[a].jig == kumijun[a + 1].jig)//使用する治具が同じで基準部品が親部品1の時、親部品2の中心の子部品から親部品1の中心の子部品の座標を引き、差を求める
				{
					Oya2hoseiX = A_Buhin[oyaBnum2].Tyusin_X - A_Buhin[oyaBnum1].Tyusin_X;
					Oya2hoseiY = A_Buhin[oyaBnum2].Tyusin_Y - A_Buhin[oyaBnum1].Tyusin_Y;
					Oya2hoseiZ = A_Buhin[oyaBnum2].Tyusin_Z - A_Buhin[oyaBnum1].Tyusin_Z;
				}
				else if (Oya2flag == 2 && kumijun[a].jig == kumijun[a + 1].jig)//使用する治具が同じで基準部品が親部品2の時、親部品2の中心の子部品から親部品2の中心の子部品の座標を引き、差を求める
				{
					Oya2hoseiX = A_Buhin[oyaBnum1].Tyusin_X - A_Buhin[oyaBnum2].Tyusin_X;
					Oya2hoseiY = A_Buhin[oyaBnum1].Tyusin_Y - A_Buhin[oyaBnum2].Tyusin_Y;
					Oya2hoseiZ = A_Buhin[oyaBnum1].Tyusin_Z - A_Buhin[oyaBnum2].Tyusin_Z;
				}

			}

			line++;

			//両手組付けのためにAPPの位置を取っておく
			KIdo_X1 = KIdo_X;
			KIdo_Y1 = KIdo_Y;
			KIdo_Z1 = KIdo_Z;
			//1回目の組立の情報を保管
			KoPnum1 = KoPnum;
			OyaPnum1 = OyaPnum;
			TyuPnum1 = TyuPnum;

			if (kumijun[line - 1].tyukan == kumijun[line].oya)//もし組立順序で2行分の組立を両手で行うとき、１行目でできた中間製品が２行目の親部品になっている時、治具についている１行目の親部品が中間製品になるので値を変えておく(親１子2の時のみ)
			{
				for (i = 0; i < JigPartssu; i++)
				{
					if (jig_parts[i].num == kumijun[line - 1].oya)
					{
						jig_parts[i].num = kumijun[line].oya;
						break;
					}
				}
			}
		}
	}

	if (Oya2flag == 1)//基準部品が親部品1の時、親部品2の座標を補正する
	{
		A_Objects[1][OyaPnum].IchiX = A_Objects[1][OyaPnum].IchiX + Oya2hoseiX;
		A_Objects[1][OyaPnum].IchiY = A_Objects[1][OyaPnum].IchiY + Oya2hoseiY;
		A_Objects[1][OyaPnum].IchiZ = A_Objects[1][OyaPnum].IchiZ + Oya2hoseiZ;
		//A_Objects[1][KoPnum].IchiX = A_Objects[1][KoPnum].IchiX + Oya2hoseiX;
		//A_Objects[1][KoPnum].IchiY = A_Objects[1][KoPnum].IchiY + Oya2hoseiY;

		/*A_Objects[1][KoPnum].IchiX = A_Objects[1][KoPnum].IchiX + Oya2hoseiX - KIdo_X + KIdo_X1;
		A_Objects[1][KoPnum].IchiY = A_Objects[1][KoPnum].IchiY + Oya2hoseiY - KIdo_Y + KIdo_Y1;
		A_Objects[1][KoPnum].IchiZ = A_Objects[1][KoPnum].IchiZ + Oya2hoseiZ - KIdo_Z + KIdo_Z1;*/

		A_Objects[1][KoPnum].IchiX = A_Objects[1][KoPnum].IchiX + Oya2hoseiX;
		A_Objects[1][KoPnum].IchiY = A_Objects[1][KoPnum].IchiY + Oya2hoseiY;
		A_Objects[1][KoPnum].IchiZ = A_Objects[1][KoPnum].IchiZ + Oya2hoseiZ;

		KIdo_X = KIdo_X + Oya2hoseiX;
		KIdo_Y = KIdo_Y + Oya2hoseiY;
		KIdo_Z = KIdo_Z + Oya2hoseiZ;

		if (kumijun[line].scene_type == oya2ko1)
		{
			for (i = 0; i < JigPartssu; i++)//一番最初に組立てた部品が基準部品になる。親2子1のとき、1行目の組立を行った後に2行目の組立を行うことになる。この時、一番最初に組立てた部品は2行目の親部品の位置になるため子の組立でできる中間製品の位置は2行目の親部品の位置になる
			{
				if (jig_parts[i].num == kumijun[line].oya)//すでにlineはプラスされているのでこれで2行目になる
				{
					jig_parts[i].IchiX = A_Objects[1][OyaPnum].IchiX;
					jig_parts[i].IchiX = A_Objects[1][OyaPnum].IchiX;
					jig_parts[i].IchiX = A_Objects[1][OyaPnum].IchiX;
					break;
				}
			}
		}
		else if (kumijun[line].scene_type == oya2ko2)
		{
			for (i = 0; i < JigPartssu; i++)
			{
				if (jig_parts[i].num == kumijun[line].oya)//基準とする部品が1行目の部品なので2行目の部品の座標を変更
				{
					jig_parts[i].IchiX = A_Objects[1][OyaPnum].IchiX;
					jig_parts[i].IchiX = A_Objects[1][OyaPnum].IchiX;
					jig_parts[i].IchiX = A_Objects[1][OyaPnum].IchiX;
					break;
				}
			}
		}
	}
	else if (Oya2flag == 2)//基準部品が親部品2の時、親部品1の座標を補正する
	{
		A_Objects[1][OyaPnum1].IchiX = A_Objects[1][OyaPnum1].IchiX + Oya2hoseiX;
		A_Objects[1][OyaPnum1].IchiY = A_Objects[1][OyaPnum1].IchiY + Oya2hoseiY;
		A_Objects[1][OyaPnum1].IchiZ = A_Objects[1][OyaPnum1].IchiZ + Oya2hoseiZ;
		//A_Objects[1][KoPnum].IchiX = A_Objects[1][KoPnum1].IchiX + Oya2hoseiX;
		//A_Objects[1][KoPnum].IchiY = A_Objects[1][KoPnum1].IchiY + Oya2hoseiY;

		/*A_Objects[1][KoPnum1].IchiX = A_Objects[1][KoPnum1].IchiX + Oya2hoseiX - KIdo_X1 + KIdo_X;
		A_Objects[1][KoPnum1].IchiY = A_Objects[1][KoPnum1].IchiY + Oya2hoseiY - KIdo_Y1 + KIdo_Y;
		A_Objects[1][KoPnum1].IchiZ = A_Objects[1][KoPnum1].IchiZ + Oya2hoseiZ - KIdo_Z1 + KIdo_Z;*/
		A_Objects[1][KoPnum1].IchiX = A_Objects[1][KoPnum1].IchiX + Oya2hoseiX;
		A_Objects[1][KoPnum1].IchiY = A_Objects[1][KoPnum1].IchiY + Oya2hoseiY;
		A_Objects[1][KoPnum1].IchiZ = A_Objects[1][KoPnum1].IchiZ + Oya2hoseiZ;

		KIdo_X1 = KIdo_X1 + Oya2hoseiX;
		KIdo_Y1 = KIdo_Y1 + Oya2hoseiY;
		KIdo_Z1 = KIdo_Z1 + Oya2hoseiZ;

		if (kumijun[line].scene_type == oya2ko1)
		{
			//組立順序2行目の子部品の位置を一行目と同じにする(親2子1の場合2回目の組立の子部品は1回目の組立でできた中間製品になる。子部品の中間製品の座標は1回目の組立での親部品の座標になるため、2回目の組立座標は1回目の親部品と2回目の親部品との差の座標になるため、1回目の子部品と2回目の親部品との佐野座標にはなっていない。そのため1回目の座標を補正した値を用いる)
			A_Objects[1][KoPnum].IchiX = A_Objects[1][KoPnum1].IchiX;
			A_Objects[1][KoPnum].IchiY = A_Objects[1][KoPnum1].IchiY;
			A_Objects[1][KoPnum].IchiZ = A_Objects[1][KoPnum1].IchiZ;

			for (i = 0; i < JigPartssu; i++)
			{
				if (jig_parts[i].num == kumijun[line].oya)//一番最初に組立てた部品が基準部品になる。親2子1のとき、1行目の組立を行った後に2行目の組立を行うことになる。この時、一番最初に組立てた部品は2行目の親部品の位置になるため子の組立でできる中間製品の位置は2行目の親部品の位置になる
				{
					jig_parts[i].IchiX = A_Objects[1][OyaPnum].IchiX;
					jig_parts[i].IchiX = A_Objects[1][OyaPnum].IchiX;
					jig_parts[i].IchiX = A_Objects[1][OyaPnum].IchiX;
					break;
				}
			}
		}
		else if (kumijun[line].scene_type == oya2ko2)
		{
			for (i = 0; i < JigPartssu; i++)
			{
				if (jig_parts[i].num == kumijun[line - 1].oya)//基準とする部品が2行目の部品なので1行目の部品の座標を変更
				{
					jig_parts[i].IchiX = A_Objects[1][OyaPnum1].IchiX;
					jig_parts[i].IchiX = A_Objects[1][OyaPnum1].IchiX;
					jig_parts[i].IchiX = A_Objects[1][OyaPnum1].IchiX;
					break;
				}
			}
		}

	}
	else if (Oya2flag == 3)
	{
		if (kumijun[line].scene_type == oya2ko1)
		{
			for (i = 0; i < JigPartssu; i++)
			{
				if (jig_parts[i].num == kumijun[line].oya)//一番最初に組立てた部品が基準部品になる。親2子1のとき、1行目の組立を行った後に2行目の組立を行うことになる。この時、一番最初に組立てた部品は2行目の親部品の位置になるため子の組立でできる中間製品の位置は2行目の親部品の位置になる
				{
					jig_parts[i].IchiX = A_Objects[1][OyaPnum].IchiX;
					jig_parts[i].IchiX = A_Objects[1][OyaPnum].IchiX;
					jig_parts[i].IchiX = A_Objects[1][OyaPnum].IchiX;
					break;
				}
			}
		}
	}

	if (scenetype == oya1ko2)//親1子2の時
	{
		if (A_Objects[1][KoPnum].IchiX > A_Objects[1][KoPnum1].IchiX)//右手左手でどの子部品を扱うのかの判定
		{
			R_KoPnum = KoPnum;
			L_KoPnum = KoPnum1;
		}
		else
		{
			R_KoPnum = KoPnum1;
			L_KoPnum = KoPnum;
		}
	}
	else if (scenetype == oya2ko1)//親2子1の時
	{
		if (A_Objects[1][OyaPnum].IchiX > A_Objects[1][OyaPnum1].IchiX)//右手左手でどの親部品を扱うのかの判定
		{
			R_OyaPnum = OyaPnum;
			L_OyaPnum = OyaPnum1;
		}
		else
		{
			R_OyaPnum = OyaPnum1;
			L_OyaPnum = OyaPnum;
		}
		//親2子1の時は最初に組立てる子部品をR_KoPnumに2回目に組立てる部品をL_KoPnumに入れておく
		R_KoPnum = KoPnum1;
		L_KoPnum = KoPnum;
	}
	else if (scenetype == oya2ko2)
	{
		if (A_Objects[1][KoPnum].IchiX > A_Objects[1][KoPnum1].IchiX)//右手左手でどの子部品,親部品を扱うのかの判定
		{
			R_KoPnum = KoPnum;
			L_KoPnum = KoPnum1;

			R_OyaPnum = OyaPnum;
			L_OyaPnum = OyaPnum1;
		}
		else
		{
			R_KoPnum = KoPnum1;
			L_KoPnum = KoPnum;

			R_OyaPnum = OyaPnum1;
			L_OyaPnum = OyaPnum;
		}

	}
}

void Make_kumitatego(int line)
{
	/*
	SType2の手順
	1.順序から、子部品・親部品・中間製品を読み取る
	2.親部品・子部品のフラグを0にする
	3.中間製品のフラグ1にする
	4.中間製品の位置・角度を親部品の情報からコピーする
	5.親部品・子部品の支えの関係を切る
	6.中間製品と右手・左手・冶具の支えの関係を作る
	*/

	int OyaPa, KoPa, TyuPa;//親部品,子部品,中間製品
	int i;
	int Oyanum = 0;//親部品が何番目にあるか
	int scenetype = 0;
	int roop = 1, roopcount = 0;//roop何回繰り返すか、roopcount：for文を回すための変数
	int supportlength = 0, k = 0;
	double temp_ichi[MaxN / 2][3], temp_num[MaxN / 2][2];
	int count = 0;

	SType = kumitatego;

	scenetype = kumijun[line].scene_type;

	if (scenetype == oya2ko2 || scenetype == oya2ko1 || scenetype == oya1ko2)
	{
		roop = 2;
	}

	for (i = 0; i < 3 * N + 2 + Kougu + putting + Jigu; i++) {
		A_Objects[0][i].Id = A_Objects[1][i].Id;
		A_Objects[0][i].Flag = A_Objects[1][i].Flag;
		A_Objects[0][i].IchiX = A_Objects[1][i].IchiX;
		A_Objects[0][i].IchiY = A_Objects[1][i].IchiY;
		A_Objects[0][i].IchiZ = A_Objects[1][i].IchiZ;
		A_Objects[0][i].DirX = A_Objects[1][i].DirX;
		A_Objects[0][i].DirY = A_Objects[1][i].DirY;
		A_Objects[0][i].DirZ = A_Objects[1][i].DirZ;
	}
	for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++) {
		A_Supports[0][i].Id = A_Supports[1][i].Id;
		A_Supports[0][i].Flag = A_Supports[1][i].Flag;
		for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
		{
			A_Supports[0][i].PId[supportlength] = A_Supports[1][i].PId[supportlength];
		}
		A_Supports[0][i].Length = supportlength;
	}

	for (roopcount = 0; roopcount < roop; roopcount++)
	{
		KoPa = kumijun[line].ko;//順序から、子部品・親部品・中間製品を読み取る
		OyaPa = kumijun[line].oya;
		TyuPa = kumijun[line].tyukan;

		for (i = 0; i < 3 * N + 2 + Kougu + putting + Jigu; i++) {//親部品・子部品のフラグを0にする
			if (A_Objects[1][i].Id == KoPa || A_Objects[1][i].Id == OyaPa) {
				A_Objects[1][i].Flag = 0;
				if (A_Objects[1][i].Id == OyaPa) {
					Oyanum = i;
				}
			}

			else if (A_Objects[1][i].Id == TyuPa) {//中間製品のフラグ1にする
				A_Objects[1][i].Flag = 1;
				A_Objects[1][i].IchiX = A_Objects[0][Oyanum].IchiX;//中間製品の位置・角度を親部品の情報からコピーする
				A_Objects[1][i].IchiY = A_Objects[0][Oyanum].IchiY;
				A_Objects[1][i].IchiZ = A_Objects[0][Oyanum].IchiZ;
				A_Objects[1][i].DirX = A_Objects[0][Oyanum].DirX;
				A_Objects[1][i].DirY = A_Objects[0][Oyanum].DirY;
				A_Objects[1][i].DirZ = A_Objects[0][Oyanum].DirZ;

			}

		}


		for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
		{//親部品・子部品の支えの関係を切る,中間製品と右手・左手・冶具の支えの関係を作る
			for (k = 0; k < A_Supports[1][i].Length; k++)
			{
				if (A_Supports[1][i].PId[k] == KoPa || A_Supports[1][i].PId[k] == OyaPa)
				{
					A_Supports[1][i].PId[k] = TyuPa;
				}
			}
		}

		for (i = 0; i < JigPartssu; i++)//治具についている部品の番号を親部品から中間製品に変更
		{
			if (jig_parts[i].num == kumijun[line].oya)
			{
				jig_parts[i].num = kumijun[line].tyukan;
			}
		}

		for (i = 0; i < JigPartssu; i++)
		{
			if (KoPa == jig_parts[i].num)
			{
				for (k = 0; k < JigPartssu; k++)//治具についている部品を入れ替え
				{
					temp_num[k][0] = jig_parts[k].num;
					temp_num[k][1] = jig_parts[k].jignum;
					temp_ichi[k][0] = jig_parts[k].IchiX;
					temp_ichi[k][1] = jig_parts[k].IchiY;
					temp_ichi[k][2] = jig_parts[k].IchiZ;
					jig_parts[k].num = 0;
					jig_parts[k].jignum = 0;
					jig_parts[k].IchiX = 0;
					jig_parts[k].IchiY = 0;
					jig_parts[k].IchiZ = 0;
				}

				for (k = 0; k < JigPartssu; k++)
				{
					if (temp_num[k][0] != KoPa)//子部品と部品番号が一致した部品は治具からはなくなる部品なので一致しない部品だけを保存する
					{
						jig_parts[count].num = temp_num[k][0];
						jig_parts[count].jignum = temp_num[k][1];
						jig_parts[count].IchiX = temp_ichi[k][0];
						jig_parts[count].IchiY = temp_ichi[k][1];
						jig_parts[count].IchiZ = temp_ichi[k][2];
						count++;
					}
				}
				JigPartssu = count;
				count = 0;
				break;
			}
		}

		if (roopcount == 0 && roop == 2)//両手作業の時に2回目の組立の計算を行うためにlineの数を増やしてからもう一度位置の計算
		{
			line++;
			//1回目の組立の情報を保管
			KoPnum1 = KoPnum;
			OyaPnum1 = OyaPnum;
			TyuPnum1 = TyuPnum;
		}
	}
}

void Make_karioki(int line)
{
	int KoPa, OyaPa, Knum, TyuPa, KoPa0;//子部品番号、親部品番号、組付け番号、中間製品,ひとつ前の子部品
	int i = 0, j = 0;
	int scenetype = 0;
	int roop = 1, roopcount = 0;//roop何回繰り返すか、roopcount：for文を回すための変数
	int supportlength = 0, k = 0;
	int count = 0;
	double temp_ichi[MaxN / 2][3], temp_num[MaxN / 2][2];
	double X_max = 0, X_min = 0, Y_max = 0, Y_min = 0, Z_max = 0, Z_min = 0, Tyusin_X, Tyusin_Y, Tyusin_Z;
	double KanseiTyusin_X = 0, KanseiTyusin_Y = 0, KanseiTyusin_Z = 0;
	int KanseiTyusin = 0;//完成品の中心の部品番号
	int KouguNum = 0, BeforeKouguNum = 0, Jig = 0;

	roop = 1;

	scenetype = kumijun[line].scene_type;

	SType = karioki;

	/*if ((scenetype == oya2ko2&&kumijun[line+2].scene_type!=oya2ko2 && kumijun[line+2].oya != kumijun[line].tyukan&&kumijun[line+2].tyukan != kumijun[line + 1].tyukan)||//現在の組付けが親2子2で次の組立が親2子2でなく次の組立でできた中間製品2つとも使わないとき
		(scenetype == oya2ko2&& kumijun[line + 2].scene_type == oya2ko2&&kumijun[line].tyukan!= kumijun[line + 2].oya&&kumijun[line].tyukan != kumijun[line + 3].oya&&kumijun[line+1].tyukan != kumijun[line + 2].oya&&kumijun[line+1].tyukan != kumijun[line + 3].oya))
	{
		roop = 2;
	}*/
	for (i = 0; i < 3 * N + 2 + Kougu + putting + Jigu; i++) {
		A_Objects[0][i].Id = A_Objects[1][i].Id;
		A_Objects[0][i].Flag = A_Objects[1][i].Flag;
		A_Objects[0][i].IchiX = A_Objects[1][i].IchiX;
		A_Objects[0][i].IchiY = A_Objects[1][i].IchiY;
		A_Objects[0][i].IchiZ = A_Objects[1][i].IchiZ;
		A_Objects[0][i].DirX = A_Objects[1][i].DirX;
		A_Objects[0][i].DirY = A_Objects[1][i].DirY;
		A_Objects[0][i].DirZ = A_Objects[1][i].DirZ;
	}
	for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++) {
		A_Supports[0][i].Id = A_Supports[1][i].Id;
		A_Supports[0][i].Flag = A_Supports[1][i].Flag;
		for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
		{
			A_Supports[0][i].PId[supportlength] = A_Supports[1][i].PId[supportlength];
		}
		A_Supports[0][i].Length = supportlength;
	}

	if ((kariokiflag % 2 == 0 && kariokiflag % 5 == 0) || (not_use_flag == 3))
	{
		roop = 2;
	}

	for (roopcount = 0; roopcount < roop; roopcount++)
	{
		Knum = kumijun[line].kuminum;//今の状態の情報を書き込んでいます
		KoPa = kumijun[line].ko;
		//KoPa0 = kumijun[line - 1].ko;//ひとつ前の子部品が何か調べる
		OyaPa = kumijun[line].oya;
		TyuPa = kumijun[line].tyukan;

		//工具と治具がobjectsでどこにあるか調べる
		if (NewNOS0 == 0)
		{
			Jig = kumijun[line].jig - 1;
			KouguNum = kumijun[line].kougu - 1;
			BeforeKouguNum = kumijun[line - 1].kougu - 1;
		}
		else
		{
			for (i = 0; i < Jigu; i++)
			{
				if (A_Objects[0][3 * N + 2 + i + putting].Id == kumijun[line].jig)
				{
					Jig = i;
					break;
				}
			}
			for (i = 0; i < Kougu; i++)
			{
				if (A_Objects[0][3 * N + 2 + i + putting + Jigu].Id == kumijun[line].kougu)
				{
					KouguNum = i;
					break;
				}
			}
			for (i = 0; i < Kougu; i++)
			{
				if (A_Objects[0][3 * N + 2 + i + putting + Jigu].Id == kumijun[line - 1].kougu)
				{
					BeforeKouguNum = i;
					break;
				}
			}
		}

		if (kumijun[line].scene_type == tegumi && kumijun[line + 1].scene_type != oya2ko2 && kumijun[line + 1].scene_type != oya2ko1 && kumijun[line].tyukan == kumijun[line + 1].ko)
		{
			//手組みした部品が次の組立の子部品になる場合は仮置きしない
		}
		else
		{
			for (i = 0; i < 3 * N + 2 + Kougu + putting + Jigu; i++) {//中間部品置き場に中間製品と左手を持っていく
				if (A_Objects[1][i].Id == TyuPa)
				{
					if ((roopcount == 1 && not_use_flag == 2) || (roopcount == 0 && not_use_flag == 1) || (roopcount == 0 && not_use_flag == 2) || not_use_flag == 3)
					{
						for (j = 0; j < e; j++) {
							if (A_Tyukantyusin[j].TyukanNum == TyuPa) {
								KanseiTyusin = A_Tyukantyusin[j].Tyusin;
							}
						}
						for (j = 0; j < N; j++)
						{
							//完成品の本来の中心点を出しています
							if (j == 0)//暫定の各軸の最大値、最小値を決める
							{
								X_max = A_Buhin[j].Tyusin_X + A_Buhin[j].X_max;
								X_min = A_Buhin[j].Tyusin_X + A_Buhin[j].X_min;
								Y_max = A_Buhin[j].Tyusin_Y + A_Buhin[j].Y_max;
								Y_min = A_Buhin[j].Tyusin_Y + A_Buhin[j].Y_min;
								Z_max = A_Buhin[j].Tyusin_Z + A_Buhin[j].Z_max;
								Z_min = A_Buhin[j].Tyusin_Z + A_Buhin[j].Z_min;
							}
							if (X_max < (A_Buhin[j].Tyusin_X + A_Buhin[j].X_max)) {
								X_max = A_Buhin[j].Tyusin_X + A_Buhin[j].X_max;
							}
							if (X_min > (A_Buhin[j].Tyusin_X + A_Buhin[j].X_min)) {
								X_min = A_Buhin[j].Tyusin_X + A_Buhin[j].X_min;
							}
							if (Y_max < (A_Buhin[j].Tyusin_Y + A_Buhin[j].Y_max)) {
								Y_max = A_Buhin[j].Tyusin_Y + A_Buhin[j].Y_max;
							}
							if (Y_min > (A_Buhin[j].Tyusin_Y + A_Buhin[j].Y_min)) {
								Y_min = A_Buhin[j].Tyusin_Y + A_Buhin[j].Y_min;
							}
							if (Z_max < (A_Buhin[j].Tyusin_Z + A_Buhin[j].Z_max)) {
								Z_max = A_Buhin[j].Tyusin_Z + A_Buhin[j].Z_max;
							}
							if (Z_min > (A_Buhin[j].Tyusin_Z + A_Buhin[j].Z_min)) {
								Z_min = A_Buhin[j].Tyusin_Z + A_Buhin[j].Z_min;
							}
							if (A_Buhin[j].Buhinnum == KanseiTyusin)
							{
								KanseiTyusin_X = A_Buhin[j].Tyusin_X;//完成品のMAYA上での中心点を出しています
								KanseiTyusin_Y = A_Buhin[j].Tyusin_Y;
								KanseiTyusin_Z = A_Buhin[j].Tyusin_Z;
							}
						}

						Tyusin_X = (X_max + X_min) / 2;
						Tyusin_Y = (Y_max + Y_min) / 2;
						Tyusin_Z = (Z_max + Z_min) / 2;

						A_Objects[1][i].IchiX = A_Objects[1][2 * N + Bboxnum].IchiX - (Tyusin_X - KanseiTyusin_X) + A_Bboxs[Bboxnum - 1].SizeX / 2;//完成品を完成品箱に持っていく
						A_Objects[1][i].IchiY = A_Objects[1][2 * N + Bboxnum].IchiY - (Tyusin_Y - KanseiTyusin_Y) + A_Bboxs[Bboxnum - 1].SizeY / 2;
						A_Objects[1][i].IchiZ = A_Objects[1][2 * N + Bboxnum].IchiZ + (KanseiTyusin_Z - Z_min);
						A_Objects[1][i].DirX = 0;
						A_Objects[1][i].DirY = 0;
						A_Objects[1][i].DirZ = 0;
					}
					else
					{
						//小峯変更（仮置き場に座標を合わせる処理、最初の3行）
						A_Objects[1][i].IchiX = A_Objects[1][3 * N + 2 + Tnum].IchiX;
						A_Objects[1][i].IchiY = A_Objects[1][3 * N + 2 + Tnum].IchiY;
						A_Objects[1][i].IchiZ = A_Objects[1][3 * N + 2 + Tnum].IchiZ;
						//A_Objects[1][2 * N].IchiX = A_Objects[1][3 * N + 2 + Tnum].IchiX;
						//A_Objects[1][2 * N].IchiY = A_Objects[1][3 * N + 2 + Tnum].IchiY;
						//A_Objects[1][2 * N].IchiZ = A_Objects[1][3 * N + 2 + Tnum].IchiZ;
					}
					TyuPnum = i;
				}
			}
			for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
			{//左手、右手、冶具の支えの関係を切る
				for (k = 0; k < A_Supports[0][i].Length; k++)
				{
					if (A_Supports[0][i].PId[k] == TyuPa)
					{
						for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
						{
							A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
						}
						A_Supports[1][i].Length = 0;//一旦0にする
						for (supportlength = 0; supportlength < A_Supports[0][i].Length; supportlength++)//前の状態で支えている数だけ回す
						{
							if (A_Supports[0][i].PId[supportlength] != TyuPa)//一致する中間製品は部品箱から取る部品なのでカウントしない
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = A_Supports[0][i].PId[supportlength];//一致する子部品以外のデータの移行
								A_Supports[1][i].Length++;//カウントを増やす
							}
						}

						if (A_Supports[1][i + 2].Length == 0)
						{
							A_Supports[1][i + 2].Flag = 0;
						}
						break;
					}
				}
			}
		}


		if (kumijun[line].kougu != kumijun[line + 1].kougu && kumijun[line].kougu != 0)//使用する工具が変更されている時、用いた工具を工具置き場に戻すので工具置き場の位置に合わせる
		{
			A_Objects[1][3 * N + 2 + putting + Jigu + KouguNum].IchiX = A_Kougus[KouguNum].IchiX;//工具の位置を工具置き場にする
			A_Objects[1][3 * N + 2 + putting + Jigu + KouguNum].IchiY = A_Kougus[KouguNum].IchiY;//工具の位置を工具置き場にする
			A_Objects[1][3 * N + 2 + putting + Jigu + KouguNum].IchiZ = A_Kougus[KouguNum].IchiZ;//工具の位置を工具置き場にする
		}
		Tnum++;//親2子2の時は要検討

		for (i = 0; i < JigPartssu; i++)//治具についている部品を仮置きするために
		{
			temp_num[i][0] = jig_parts[i].num;
			temp_num[i][1] = jig_parts[i].jignum;
			temp_ichi[i][0] = jig_parts[i].IchiX;
			temp_ichi[i][1] = jig_parts[i].IchiY;
			temp_ichi[i][2] = jig_parts[i].IchiZ;
			jig_parts[i].num = 0;
			jig_parts[i].jignum = 0;
			jig_parts[i].IchiX = 0;
			jig_parts[i].IchiY = 0;
			jig_parts[i].IchiZ = 0;
		}

		for (i = 0; i < JigPartssu; i++)
		{
			if (temp_num[i][0] != kumijun[line].tyukan)//仮置きする中間製品と部品番号が一致した部品は仮置きする部品なので一致しない部品だけを保存する
			{
				jig_parts[i].num = temp_num[i][0];
				jig_parts[i].jignum = temp_num[i][1];
				jig_parts[i].IchiX = temp_ichi[i][0];
				jig_parts[i].IchiY = temp_ichi[i][1];
				jig_parts[i].IchiZ = temp_ichi[i][2];
				count++;
			}
		}

		JigPartssu = count;
		count = 0;
		if (roopcount == 0 && roop == 2)//両手作業の時に2回目の組立の計算を行うためにlineの数を増やしてからもう一度位置の計算
		{
			line++;

			//1回目の組立の情報を保管

			TyuPnum1 = TyuPnum;
		}
	}

	if (scenetype == oya2ko2 && roop == 1)//親2子2の組付けで片方の部品のみ仮置きする時は一回しかループしないので2つの中間製品が分からないため2つの中間製品を探す
	{
		for (i = 0; i < 3 * N + 2 + Kougu + putting + Jigu; i++)
		{
			if (kumijun[a].tyukan == A_Objects[1][i].Id)
			{
				TyuPnum = i;
			}
			else if (kumijun[a + 1].tyukan == A_Objects[1][i].Id)
			{
				TyuPnum1 = i;
			}
		}
	}

	if (scenetype == oya2ko2)
	{
		if (A_Objects[0][TyuPnum].IchiX > A_Objects[0][TyuPnum1].IchiX)//右手左手でどの中間製品を扱うのかの判定
		{
			R_TyuPnum = TyuPnum;
			L_TyuPnum = TyuPnum1;
		}
		else
		{
			R_TyuPnum = TyuPnum1;
			L_TyuPnum = TyuPnum;
		}
	}
}

void DirDecision(double DirX, double DirY, double DirZ)
{
	A_Objects[1][KoPnum].DirX = DirX;
	A_Objects[1][OyaPnum].DirX = DirX;
	A_Objects[1][KoPnum].DirY = DirY;
	A_Objects[1][OyaPnum].DirY = DirY;
	A_Objects[1][KoPnum].DirZ = DirZ;
	A_Objects[1][OyaPnum].DirZ = DirZ;
}

void start_to_kumitatemae(FILE* fp2, int line, int movetype)
{
	int i = 0, R_length = 0, L_length = 0, length = 0, /*movetype = 0,*/ Te = 0, nowmove = 0, Jig = 0;
	int OyaPa, KoPa, TyuPa, Jigbangou = 0;//親部品番号,子部品番号,中間製品
	double IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Turn0X, Turn0Y, Turn0Z, Turn1X, Turn1Y, Turn1Z;
	int Oyanum = 0;//親部品が何番目にあるか
	int use_parts = 0/*使用する部品番号*/, use_object = 0/*使用する部品がobjectでどこにあるか*/;
	int R_use_parts = 0/*右手で使用する部品番号*/, R_use_object = 0;/*右手で使用する部品がobjectでどこにあるか*/
	int L_use_parts = 0/*左手で使用する部品番号*/, L_use_object = 0;/*左手で使用する部品がobjectでどこにあるか*/
	double R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2, R_Turn0X, R_Turn0Y, R_Turn0Z, R_Turn1X, R_Turn1Y, R_Turn1Z;
	double L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, L_Turn0X, L_Turn0Y, L_Turn0Z, L_Turn1X, L_Turn1Y, L_Turn1Z;
	int temp[MaxSupport], templength = 0;

	int R_Jig = 0, L_Jig = 0, R_Jigbangou = 0, L_Jigbangou = 0, R_TyuPa = 0, L_TyuPa = 0, TyuPa2 = 0, R_line = 0/*両手の時右手の組付けが一行目か二行目かどうかを保管*/, L_line = 0/*両手の時右手の組付けが一行目か二行目かどうかを保管*/;
	int supportlength = 0, k = 0, supportflug = 0, f = 0;
	int KouguBnum = 0, Kougunum = 0, KouguPnum = 0;//KouguBnum：レイアウト情報での工具の番号、Kougunum：工具番号,KouguPnum：工具がobjectsでどこにあるか
	int ChangeKouguBnum = 0, ChangeKougunum = 0, ChangeKouguPnum = 0;//ChangeKouguBnum：レイアウト情報での交換する工具の番号、ChangeKougunum：交換する工具番号,ChangeKouguPnum：交換する工具がobjectsでどこにあるか
	int TempKougunum = 0;
	int BeforeJig = 0;
	int BeforeJigR = 0, BeforeJigL = 0;

	TyuPa2 = kumijun[line + 1].tyukan;
	R_length = M_pattern[movetype].length[migite];
	L_length = M_pattern[movetype].length[hidarite];
	KoPa = kumijun[line].ko;
	OyaPa = kumijun[line].oya;
	TyuPa = kumijun[line].tyukan;
	if (NewNOS0 == 0)
	{
		Jig = kumijun[line].jig - 1;
		Kougunum = kumijun[line].kougu - 1;
		ChangeKougunum = kumijun[line - 1].kougu - 1;
	}
	else
	{
		for (i = 0; i < Jigu; i++)
		{
			if (A_Objects[0][3 * N + 2 + i + putting].Id == kumijun[line].jig)
			{
				
				Jig = i;
				break;
			}
		}
		for (i = 0; i < Kougu; i++)
		{
			if (A_Objects[0][3 * N + 2 + i + putting + Jigu].Id == kumijun[line].kougu)
			{
				Kougunum = i;
				break;
			}
		}
		for (i = 0; i < Kougu; i++)
		{
			if (A_Objects[0][3 * N + 2 + i + putting + Jigu].Id == kumijun[line - 1].kougu)
			{
				ChangeKougunum = i;
				break;
			}
		}
	}
	Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
	//printf("%d--%d--%d\n", Jigbangou, Jig, kumijun[line].jig);
	//Kougunum = kumijun[line].kougu;
	KouguBnum = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].Id;
	//ChangeKougunum = kumijun[line-1].kougu;
	ChangeKouguBnum = A_Objects[0][3 * N + 2 + ChangeKougunum + putting + Jigu].Id;

	if (R_length > L_length)
	{
		length = R_length;
	}
	else
	{
		length = L_length;
	}

	for (nowmove = 0; nowmove <= length; nowmove++)
	{
		if (M_pattern[movetype].Move[migite][nowmove][move] != none && M_pattern[movetype].Move[hidarite][nowmove][move] != none)//右手左手両方に同時に動作がある時
		{
			Te = ryoute;
		}
		else if (M_pattern[movetype].Move[migite][nowmove][move] != none)//右手に作業がある時
		{
			Te = migite;
		}
		else if (M_pattern[movetype].Move[hidarite][nowmove][move] != none)//左手に動作がある時
		{
			Te = hidarite;
		}

		//どの部品を対象とするかを調べる
		if (Te == migite || Te == hidarite)//両手で同時に作業をしない時
		{
			if (M_pattern[movetype].Move[Te][nowmove][target] == Oya)//対象製品が親部品
			{
				if (Oya2flag == 1)//基準部品が最初の部品の時
				{//2番目の部品が対象の部品になる
					use_parts = kumijun[line + 1].oya;
					use_object = OyaPnum;
				}
				else if (Oya2flag == 2)//基準部品が2番目の部品の時
				{//最初の部品が対象の部品になる
					use_parts = kumijun[line].oya;
					use_object = OyaPnum1;
				}
				else
				{
					use_parts = OyaPa;
					if (kumijun[line].scene_type == oya1ko2)
					{
						use_object = OyaPnum1;
					}
					else
					{
						use_object = OyaPnum;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Ko)//対象製品が子部品
			{
				use_parts = KoPa;
				use_object = KoPnum;
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Tyukan)//対象製品が中間製品
			{
				use_parts = TyuPa;
				use_object = TyuPnum;
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Start_P)//手を初期位置に戻すとき、対象製品は使用する手
			{
				use_object = 2 * N - 1 + Te;
			}

			else if (M_pattern[movetype].Move[Te][nowmove][target] == Ko1)//両手2部品の時の右手で扱う子部品
			{
				use_parts = A_Objects[0][R_KoPnum].Id;
				use_object = R_KoPnum;
				if (Oya2flag == 2)
				{
					use_object = KoPnum1;
				}
				else if (Oya2flag == 1)
				{
					use_object = KoPnum1;
				}
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].ko == R_use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						OyaPa = kumijun[i].oya;
						KoPa = kumijun[i].ko;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Oya1)//両手2部品の時の右手で扱う親部品
			{
				use_parts = A_Objects[0][R_OyaPnum].Id;
				use_object = R_OyaPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].oya == R_use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Tyukan1)//両手2部品の時の右手で扱う中間製品部品
			{
				use_parts = A_Objects[0][R_TyuPnum].Id;
				use_object = R_TyuPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].tyukan == use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Ko2)//両手2部品の時の左手で扱う子部品
			{
				use_parts = A_Objects[0][L_KoPnum].Id;
				use_object = L_KoPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].ko == use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						OyaPa = kumijun[i].oya;
						KoPa = kumijun[i].ko;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[line].jig - 1;
						}
						else
						{
							for (i = 0; i < Jigu; i++)
							{
								if (A_Objects[0][3 * N + 2 + i + putting].Id == kumijun[line].jig)
								{
									Jig = i;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Oya2)//両手2部品の時の左手で扱う親部品
			{
				use_parts = A_Objects[0][L_OyaPnum].Id;
				use_object = L_OyaPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].oya == use_parts)
					{
						OyaPa = kumijun[i].oya;
						KoPa = kumijun[line].ko;
						TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Tyukan2)//両手2部品の時の左手で扱う中間製品部品
			{
				use_parts = A_Objects[0][L_TyuPnum].Id;
				use_object = L_TyuPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].tyukan == L_use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)
			{
				use_parts = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].Id;
				use_object = 3 * N + 2 + Kougunum + putting + Jigu;

			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == ChangeKOUGU)
			{
				use_parts = A_Objects[0][3 * N + 2 + ChangeKougunum + putting + Jigu].Id;
				use_object = 3 * N + 2 + ChangeKougunum + putting + Jigu;
			}

			if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == nobasu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{//Te = M_pattern[movetype].kobuhin[nowmove][Hand];
				//もともと治具に付いている部品(親部品)に手を伸ばす
					IchiX1 = A_Objects[0][2 * N - 1 + Te].IchiX;//使用する手の現在の位置
					IchiY1 = A_Objects[0][2 * N - 1 + Te].IchiY;
					IchiZ1 = A_Objects[0][2 * N - 1 + Te].IchiZ;
					if (M_pattern[movetype].Move[Te][nowmove][target] == Start_P)
					{
						IchiX2 = A_Objects[1][use_object].IchiX;
						IchiY2 = A_Objects[1][use_object].IchiY;
						IchiZ2 = A_Objects[1][use_object].IchiZ;
					}
					else
					{
						IchiX2 = A_Objects[0][use_object].IchiX;
						IchiY2 = A_Objects[0][use_object].IchiY;
						IchiZ2 = A_Objects[0][use_object].IchiZ;
					}
					/*IchiX2 = A_Objects[0][OyaPnum].IchiX;
					IchiY2 = A_Objects[0][OyaPnum].IchiY;
					IchiZ2 = A_Objects[0][OyaPnum].IchiZ;*/

					Reach(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);

					//printf("%lf,%lf,%lf||||%lf,%lf,%lf\n", IchiX2, IchiY2, IchiZ2, IchiX1, IchiY1, IchiZ1);//古屋工具
					A_Objects[0][2 * N - 1 + Te].IchiX = IchiX2;//手の座標を更新
					A_Objects[0][2 * N - 1 + Te].IchiY = IchiY2;
					A_Objects[0][2 * N - 1 + Te].IchiZ = IchiZ2;
				
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == tsukamu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = Te;//部品を持っている手を記録
					if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)//対象が工具の時は工具を使用していることを記録しておく
					{
						Kouguflag = KouguBnum;
					}
					Gripping(fp2, use_parts, Te);//掴む
					//Gripping(fp2, TyuPa, Te);//掴む
					if (A_Supports[1][Te].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][Te].Id = A_Hands[Te].Hnum;//部品と手の支えの関係をつくる
						A_Supports[1][Te].Flag = 1;
						A_Supports[1][Te].PId[0] = use_parts;
						A_Supports[1][Te].Length++;
					}
					else
					{
						A_Supports[1][Te].Id = A_Hands[Te].Hnum;
						A_Supports[1][Te].Flag = 1;
						for (k = 0; k < A_Supports[1][Te].Length; k++)
						{
							//A_Supports[0][Te].PId = use_parts;
							if (A_Supports[1][Te].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][Te].PId[A_Supports[1][Te].Length] = use_parts;//部品と手の支えの関係をつくる
							A_Supports[1][Te].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
					//A_Supports[1][Te].PId = TyuPa;
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == tsukamitoru)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = Te;//部品を持っている手を記録
					if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)//対象が工具の時は工具を使用していることを記録しておく
					{
						Kouguflag = KouguBnum;
					}

					if (JigKobuhin == use_parts || JigKobuhin2 == use_parts || ChangeJig == use_parts || ChangeJig2 == use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == use_parts)
								{
									BeforeJig = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					//部品箱の支えの関係を切る
					for (i = 0; i < Bboxnum; i++)
					{
						for (k = 0; k < A_Supports[1][i + 2].Length; k++)
						{
							if (A_Supports[1][i + 2].PId[k] == use_parts) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
							   //A_Supports[1][i + 2].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i + 2].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i + 2].Length;
								A_Supports[1][i + 2].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i + 2].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i + 2].Length == 0)
								{
									A_Supports[1][i + 2].Flag = 0;
								}
								break;
							}
						}
					}
					for (i = 0; i < putting; i++)
					{//中間製品置き場からとるとき、支えの関係を切る
						//if (A_Supports[0][3 + N + i].PId == OyaPa)
						/*if (A_Supports[0][3 + N + i].PId == use_parts)
						{
							A_Supports[1][3 + N + i].Flag = 0;
							A_Supports[1][3 + N + i].PId = 0;
						}*/
						for (k = 0; k < A_Supports[1][3 + N + i].Length; k++)
						{
							if (A_Supports[1][3 + N + i].PId[k] == use_parts) {//A_Supports[][0],A_Supports[][1]には
							   //A_Supports[1][3 + N + i].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][3 + N + i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][3 + N + i].Length;
								A_Supports[1][3 + N + i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = temp[supportlength];//データの移行
										A_Supports[1][3 + N + i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][3 + N + i].Length == 0)
								{
									A_Supports[1][3 + N + i].Flag = 0;
								}
								break;
							}
						}
					}

					if (A_Supports[1][Te].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][Te].Id = A_Hands[Te].Hnum;//部品と手の支えの関係をつくる
						A_Supports[1][Te].Flag = 1;
						A_Supports[1][Te].PId[0] = use_parts;
						A_Supports[1][Te].Length++;
					}
					else
					{
						A_Supports[1][Te].Id = A_Hands[Te].Hnum;
						A_Supports[1][Te].Flag = 1;
						for (k = 0; k < A_Supports[1][Te].Length; k++)
						{
							//A_Supports[0][Te].PId = use_parts;
							if (A_Supports[1][Te].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][Te].PId[A_Supports[1][Te].Length] = use_parts;//部品と手の支えの関係をつくる
							A_Supports[1][Te].Length++;
						}
						else
						{
							supportflug = 0;
						}

					}
					//A_Supports[0][Te].PId = OyaPa;

					Grip(fp2, use_parts, BeforeJig, Te);//掴み取る grip
					//Grip(fp2, OyaPa, Te);//掴み取る grip
					BeforeJig = 0;
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == hakobu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					//Te = M_pattern[movetype].kobuhin[nowmove][Hand];

					IchiX1 = A_Objects[0][2 * N - 1 + Te].IchiX;
					IchiY1 = A_Objects[0][2 * N - 1 + Te].IchiY;
					IchiZ1 = A_Objects[0][2 * N - 1 + Te].IchiZ;
					IchiX2 = A_Objects[1][use_object].IchiX;
					IchiY2 = A_Objects[1][use_object].IchiY;
					IchiZ2 = A_Objects[1][use_object].IchiZ;
					/*IchiX2 = A_Objects[1][TyuPnum].IchiX;
					IchiY2 = A_Objects[1][TyuPnum].IchiY;
					IchiZ2 = A_Objects[1][TyuPnum].IchiZ;*/

					Carry(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);//左手で運ぶ carry

					A_Objects[0][2 * N - 1 + Te].IchiX = IchiX2;//手の座標を更新
					A_Objects[0][2 * N - 1 + Te].IchiY = IchiY2;
					A_Objects[0][2 * N - 1 + Te].IchiZ = IchiZ2;

					A_Objects[0][use_object].IchiX = IchiX2;//部品の座標を更新
					A_Objects[0][use_object].IchiY = IchiY2;
					A_Objects[0][use_object].IchiZ = IchiZ2;

					if ((abs(M_pattern[movetype].Move[Te][nowmove+2][move]) != kumitateidou)&&((Kouguflag != 0 && M_pattern[movetype].Move[Te][nowmove][target] == Ko) || M_pattern[movetype].Move[Te][nowmove][target] == KOUGU || M_pattern[movetype].Move[Te][nowmove][target] == ChangeKOUGU))//工具を用いて部品を運ぶ場合は工具の座標も変更+仮組付けの工具組付けの場合は工具の位置を変更しない
					{
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiX = IchiX2;//工具の座標を更新
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY = IchiY2;
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = IchiZ2;
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == okihanasu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = -1;//部品を持っている手がないことを記録
					if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)//対象が工具の時は工具を使用していないのでフラグを0に戻す
					{
						Kouguflag = 0;
					}

					for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
					{//左手、右手、冶具の支えの関係を切る
						//if (A_Supports[1][i].PId == TyuPa)
						f = A_Supports[1][i].Length;//支えている数を保存
						for (k = 0; k < f; k++)
						{
							/*if (A_Supports[1][i].PId == use_parts)
							{
								A_Supports[1][i].Flag = 0;
								A_Supports[1][i].PId = 0;
							}*/
							if (A_Supports[1][i].PId[k] == use_parts)//組立後に部品を支えていてはいけないのでA_Supports[1][i].PId
							{
								for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i].Length;
								A_Supports[1][i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != use_parts)//一致する部品は支えない部品なのでカウントしない
									{
										A_Supports[1][i].PId[A_Supports[1][i].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i].Length == 0)
								{
									A_Supports[1][i].Flag = 0;
								}
								break;
							}
						}

						if (i == Tnum - 1 + N + 3)
						{//中間製品置き場と中間製品の支えの関係を作る
							A_Supports[1][i].Flag = 1;
							//A_Supports[1][i].PId = use_parts;
							//A_Supports[1][i].PId = TyuPa;
							for (k = 0; k < A_Supports[1][i].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][i].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = 1;
									break;
								}
							}
							if (supportflug == 0)//まだ支えられていない時
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = use_parts;//親部品と手の支えの関係をつくる
								A_Supports[1][i].Length++;
							}
							else
							{
								supportflug = 0;
							}
						}
					}

					leave(fp2, use_parts, Te);//置き放す leave
					//leave(fp2, TyuPa, Te);//置き放す leave
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == tsukeru)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = Te;//部品を持っている手を記録

					if (M_pattern[movetype].Move[Te][nowmove][destination] == KOUGU)//付ける対象が工具の時は工具に付ける
					{
						Fix(fp2, KouguBnum, use_parts, Te);//付ける fix
						//Fix(fp2, Jigbangou, OyaPa, Te);//付ける fix

						//工具と親部品の支えの関係をつくる
						A_Supports[1][N + 3 + putting + Jigu + Kougunum].Id = A_Kougus[Kougunum].Bnum;
						A_Supports[1][N + 3 + putting + Jigu + Kougunum].Flag = 1;

						if (A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length == 0)
						{
							A_Supports[1][N + 3 + putting + Jigu + Kougunum].PId[A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length] = use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length++;
						}
						else
						{
							for (k = 0; k < A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][N + 3 + putting + Jigu + Kougunum].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = 1;
									break;
								}

								if (supportflug == 0)//まだ支えられていない時
								{
									A_Supports[1][N + 3 + putting + Jigu + Kougunum].PId[A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length] = use_parts;//親部品と手の支えの関係をつくる
									A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length++;
									break;
								}
								else
								{
									supportflug = 0;
								}
							}
						}
					}
					else
					{
						Fix(fp2, Jigbangou, use_parts, Te);//付ける fix
					   //Fix(fp2, Jigbangou, OyaPa, Te);//付ける fix

					   //治具と親部品の支えの関係をつくる
						A_Supports[1][3 + N + putting + Jig].Id = A_Jigus[Jig].Jnum;
						A_Supports[1][3 + N + putting + Jig].Flag = 1;
						//A_Supports[1][3 + N + putting + Jig].PId = use_parts;
						//A_Supports[1][3 + N + putting + Jig].PId = OyaPa;

						if (A_Supports[1][3 + N + putting + Jig].Length == 0)
						{
							A_Supports[1][3 + N + putting + Jig].PId[A_Supports[1][3 + N + putting + Jig].Length] = use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + Jig].Length++;
						}
						else
						{
							for (k = 0; k < A_Supports[1][3 + N + putting + Jig].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][3 + N + putting + Jig].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = 1;
									break;
								}

								if (supportflug == 0)//まだ支えられていない時
								{
									A_Supports[1][3 + N + putting + Jig].PId[A_Supports[1][3 + N + putting + Jig].Length] = use_parts;//親部品と手の支えの関係をつくる
									A_Supports[1][3 + N + putting + Jig].Length++;
									break;
								}
								else
								{
									supportflug = 0;
								}
							}
						}
						oya_hoji = A_Jigus[Jig].Jnum;
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == hazusu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					if (M_pattern[movetype].Move[Te][nowmove][destination] == KOUGU || M_pattern[movetype].Move[Te][nowmove][destination] == ChangeKOUGU)
					{
						if (M_pattern[movetype].Move[Te][nowmove][destination] == ChangeKOUGU)
						{
							TempKougunum = ChangeKougunum;
						}
						else
						{
							TempKougunum = Kougunum;
						}

						Remove(fp2, A_Objects[0][3 * N + 2 + TempKougunum + putting + Jigu].Id, use_parts, Te);//外す remove
						//Remove(fp2, Jigbangou, TyuPa, Te);//外す remove
						//治具と親部品の支えの関係を切る
						//A_Supports[1][3 + N + putting + Jig].PId = 0;

						for (supportlength = 0; supportlength < A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length; supportlength++)
						{
							temp[supportlength] = 0;//配列の初期化
							temp[supportlength] = A_Supports[1][N + 3 + putting + Jigu + TempKougunum].PId[supportlength];//値を移す
							A_Supports[1][N + 3 + putting + Jigu + TempKougunum].PId[supportlength] = 0;//配列の初期化
						}
						templength = 0;
						templength = A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length;
						A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length = 0;//一旦0にする
						for (k = 0; k < templength; k++)
						{
							if (temp[k] != use_parts)
							{
								A_Supports[1][N + 3 + putting + Jigu + TempKougunum].PId[A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length] = temp[k];
								A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length++;
							}
						}
						if (A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length == 0)
						{
							A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Flag = 0;
						}
					}
					else
					{
						Remove(fp2, Jigbangou, use_parts, Te);//外す remove
						//Remove(fp2, Jigbangou, TyuPa, Te);//外す remove
						//治具と親部品の支えの関係を切る
						//A_Supports[1][3 + N + putting + Jig].PId = 0;

						for (supportlength = 0; supportlength < A_Supports[1][3 + N + putting + Jig].Length; supportlength++)
						{
							temp[supportlength] = 0;//配列の初期化
							temp[supportlength] = A_Supports[1][3 + N + putting + Jig].PId[supportlength];//値を移す
							A_Supports[1][3 + N + putting + Jig].PId[supportlength] = 0;//配列の初期化
						}
						templength = 0;
						templength = A_Supports[1][3 + N + putting + Jig].Length;
						A_Supports[1][3 + N + putting + Jig].Length = 0;//一旦0にする
						for (k = 0; k < templength; k++)
						{
							if (temp[k] != use_parts)
							{
								A_Supports[1][3 + N + putting + Jig].PId[A_Supports[1][3 + N + putting + Jig].Length] = temp[k];
								A_Supports[1][3 + N + putting + Jig].Length++;
							}
						}
						if (A_Supports[1][3 + N + putting + Jig].Length == 0)
						{
							A_Supports[1][3 + N + putting + Jig].Flag = 0;
						}
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == hanasu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = -1;//部品を持っている手がないことを記録
					if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)//対象が工具の時は工具を使用していないのでフラグを0に戻す
					{
						Kouguflag = 0;
					}
					Release(fp2, use_parts, Te);//放すrelease
					//Release(fp2, OyaPa, Te);//放すrelease
					//親部品と手の支えの関係を切る
					//A_Supports[0][Te].Flag = 0;
					//A_Supports[0][Te].PId = 0;
					for (supportlength = 0; supportlength < A_Supports[1][Te].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][Te].PId[supportlength];//値を移す
						A_Supports[1][Te].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][Te].Length;
					A_Supports[1][Te].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != use_parts)
						{
							A_Supports[1][Te].PId[A_Supports[1][Te].Length] = temp[k];
							A_Supports[1][Te].Length++;
						}
					}
					if (A_Supports[1][Te].Length == 0)
					{
						A_Supports[1][Te].Flag = 0;
					}

					if (Kouguflag != 0)
					{
						for (supportlength = 0; supportlength < A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length; supportlength++)
						{
							temp[supportlength] = 0;//配列の初期化
							temp[supportlength] = A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId[supportlength];//値を移す
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId[supportlength] = 0;//配列の初期化
						}
						templength = 0;
						templength = A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length;
						A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length = 0;//一旦0にする
						for (k = 0; k < templength; k++)
						{
							if (temp[k] != use_parts)
							{
								A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId[A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length] = temp[k];
								A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length++;
							}
						}
						if (A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length == 0)
						{
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].Flag = 0;
						}
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == motinaosu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					Turn0X = A_Objects[0][use_object].DirX;
					Turn1X = A_Objects[1][use_object].DirX;
					Turn0Y = A_Objects[0][use_object].DirY;
					Turn1Y = A_Objects[1][use_object].DirY;
					Turn0Z = A_Objects[0][use_object].DirZ;
					Turn1Z = A_Objects[1][use_object].DirZ;

					Turn(fp2, use_parts, Turn0X, Turn0Y, Turn0Z, Turn1X, Turn1Y, Turn1Z, Te);//左手で回転させるturn
					if (M_pattern[movetype].Move[Te][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(Turn0X - Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(Turn0Y - Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(Turn0Z - Turn1Z) + Oyakaitenkakudo;
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == kumitateidou)
			{
			//printf("組立移動\n");
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = Te;//部品を持っている手を記録
					/*IchiX1 = A_Objects[1][KoPnum].IchiX;
					IchiY1 = A_Objects[1][KoPnum].IchiY;
					IchiZ1 = A_Objects[1][KoPnum].IchiZ;*/
					IchiX1 = A_Objects[0][2 * N - 1 + Te].IchiX;
					IchiY1 = A_Objects[0][2 * N - 1 + Te].IchiY;
					IchiZ1 = A_Objects[0][2 * N - 1 + Te].IchiZ;

					if (kumijun[line].scene_type == oya2ko1)
					{
						/*if (Oya2flag == 1 || Oya2flag == 3)
						{
							IchiX2 = KIdo_X1;
							IchiY2 = KIdo_Y1;
							IchiZ2 = KIdo_Z1;
						}
						else if (Oya2flag == 2)
						{
							IchiX2 = KIdo_X;
							IchiY2 = KIdo_Y;
							IchiZ2 = KIdo_Z;
						}*/
						IchiX2 = KIdo_X1;
						IchiY2 = KIdo_Y1;
						IchiZ2 = KIdo_Z1;
					}
					else
					{
						IchiX2 = KIdo_X;
						IchiY2 = KIdo_Y;
						IchiZ2 = KIdo_Z;
					}

					Kumimove(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);//組立移動Kumimove

					A_Objects[0][2 * N - 1 + Te].IchiX = IchiX2;//手の座標を更新
					A_Objects[0][2 * N - 1 + Te].IchiY = IchiY2;
					A_Objects[0][2 * N - 1 + Te].IchiZ = IchiZ2;

					A_Objects[0][use_object].IchiX = IchiX2;//部品の座標を更新
					A_Objects[0][use_object].IchiY = IchiY2;
					A_Objects[0][use_object].IchiZ = IchiZ2;

					A_Objects[1][use_object].IchiX = IchiX2;//部品の座標を更新
					A_Objects[1][use_object].IchiY = IchiY2;
					A_Objects[1][use_object].IchiZ = IchiZ2;

					if ((Kouguflag != 0 && M_pattern[movetype].Move[Te][nowmove][target] == Ko) || M_pattern[movetype].Move[Te][nowmove][target] == KOUGU || M_pattern[movetype].Move[Te][nowmove][target] == ChangeKOUGU)//工具を用いて部品を運ぶ場合は工具の座標も変更
					{
						//printf("%lf  %lf  %lf  %d\n", IchiX2, IchiY2, IchiZ2, Kouguflag);
						//A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiX = IchiX2;//部品の座標を更新
						//A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY = IchiY2;
						//A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = IchiZ2;
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == kumitateru)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					//Te = M_pattern[movetype].kobuhin[nowmove][Hand];
					/*if (kumijun[line].scene_type == oya2ko1)
					{
						Kumitate(fp2, A_Supports[0][N + putting + 3 + kumijun[line].jig - 1].Id, kumijun[line].tyukan, kumijun[line].oya, kumijun[line].ko, Te);//右手で組立Kumitate
						Kumitate(fp2, A_Supports[0][N + putting + 3 + kumijun[line + 1].jig - 1].Id, kumijun[line + 1].tyukan, kumijun[line + 1].oya, kumijun[line + 1].ko, Te);//右手で組立Kumitate
					}*/
					if (kumijun[line].kougu != 0)//工具を用いて組立を行う時
					{
						KouguKumi(fp2, Jigbangou, KouguBnum, TyuPa, OyaPa, KoPa);
					}
					else
					{
						Kumitate(fp2, Jigbangou, TyuPa, OyaPa, KoPa, Te);//組立Kumitate
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == sentanhenkou)
			{
				Tipmove(fp2, line, M_pattern[movetype].Move[Te][nowmove][target], Te);
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == hakobu_tsuika)
			{
				IchiX1 = A_Objects[0][2 * N - 1 + Te].IchiX;
				IchiY1 = A_Objects[0][2 * N - 1 + Te].IchiY;
				IchiZ1 = A_Objects[0][2 * N - 1 + Te].IchiZ;
				IchiX2 = A_Objects[1][use_object].IchiX + M_pattern[movetype].Move_addition[Te][nowmove][0];
				IchiY2 = A_Objects[1][use_object].IchiY + M_pattern[movetype].Move_addition[Te][nowmove][1];
				IchiZ2 = A_Objects[1][use_object].IchiZ + M_pattern[movetype].Move_addition[Te][nowmove][2];

				Carry(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);//左手で運ぶ carry

				A_Objects[0][2 * N - 1 + Te].IchiX = IchiX2;//手の座標を更新
				A_Objects[0][2 * N - 1 + Te].IchiY = IchiY2;
				A_Objects[0][2 * N - 1 + Te].IchiZ = IchiZ2;

				A_Objects[0][use_object].IchiX = IchiX2;//部品の座標を更新
				A_Objects[0][use_object].IchiY = IchiY2;
				A_Objects[0][use_object].IchiZ = IchiZ2;


				if ((Kouguflag != 0 && M_pattern[movetype].Move[Te][nowmove][target] == Ko) || M_pattern[movetype].Move[Te][nowmove][target] == KOUGU || M_pattern[movetype].Move[Te][nowmove][target] == ChangeKOUGU)//工具を用いて部品を運ぶ場合は工具の座標も変更
				{
					A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiX = IchiX2;//部品の座標を更新
					A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY = IchiY2;
					A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = IchiZ2;
				}

			}
		}
		else if (Te == ryoute)
		{
			//右手の対象を決める
			if (M_pattern[movetype].Move[migite][nowmove][target] == Oya)//対象製品が親部品
			{

				if (Oya2flag == 1)//基準部品が最初の部品の時
				{//2番目の部品が対象の部品になる
					R_use_parts = kumijun[line + 1].oya;
					R_use_object = OyaPnum;
				}
				else if (Oya2flag == 2)//基準部品が2番目の部品の時
				{//最初の部品が対象の部品になる
					R_use_parts = kumijun[line].oya;
					R_use_object = OyaPnum1;
				}
				else
				{
					R_use_parts = OyaPa;
					R_use_object = OyaPnum;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Ko)//対象製品が子部品
			{
				R_use_parts = KoPa;
				R_use_object = KoPnum;
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Tyukan)//対象製品が中間製品
			{
				R_use_parts = TyuPa;
				R_use_object = TyuPnum;
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Start_P)//手を初期位置に戻すとき、対象製品は使用する手
			{
				R_use_object = 2 * N - 1 + migite;
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Ko1)//両手2部品の時の右手で扱う子部品
			{
				R_use_parts = A_Objects[0][R_KoPnum].Id;
				R_use_object = R_KoPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].ko == R_use_parts)
					{
						R_TyuPa = kumijun[i].tyukan;
						R_line = i;
						if (NewNOS0 == 0)
						{
							R_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									R_Jig = k;
									break;
								}

							}
						}

						R_Jigbangou = A_Supports[0][N + putting + 3 + R_Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Oya1)//両手2部品の時の右手で扱う親部品
			{
				R_use_parts = A_Objects[0][R_OyaPnum].Id;
				R_use_object = R_OyaPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].oya == R_use_parts)
					{
						R_TyuPa = kumijun[i].tyukan;
						R_line = i;
						if (NewNOS0 == 0)
						{
							R_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									R_Jig = k;
									break;
								}

							}
						}
						R_Jigbangou = A_Supports[0][N + putting + 3 + R_Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Tyukan1)//両手2部品の時の右手で扱う中間製品部品
			{
				R_use_parts = A_Objects[0][R_TyuPnum].Id;
				R_use_object = R_TyuPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].tyukan == R_use_parts)
					{
						R_TyuPa = kumijun[i].tyukan;
						R_line = i;
						if (NewNOS0 == 0)
						{
							R_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									R_Jig = k;
									break;
								}

							}
						}
						R_Jigbangou = A_Supports[0][N + putting + 3 + R_Jig].Id;
					}
				}
			}

			//左手の対象を決める
			if (M_pattern[movetype].Move[hidarite][nowmove][target] == Oya)//対象製品が親部品
			{
				if (Oya2flag == 1)//基準部品が最初の部品の時
				{//2番目の部品が対象の部品になる
					L_use_parts = kumijun[line + 1].oya;
					L_use_object = OyaPnum;
				}
				else if (Oya2flag == 2)//基準部品が2番目の部品の時
				{//最初の部品が対象の部品になる
					L_use_parts = kumijun[line].oya;
					L_use_object = OyaPnum1;
				}
				else
				{
					L_use_parts = OyaPa;
					L_use_object = OyaPnum;
				}
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Ko)//対象製品が子部品
			{
				L_use_parts = KoPa;
				L_use_object = KoPnum;
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Tyukan)//対象製品が中間製品
			{
				L_use_parts = TyuPa;
				L_use_object = TyuPnum;
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Start_P)//手を初期位置に戻すとき、対象製品は使用する手
			{
				L_use_object = 2 * N - 1 + hidarite;
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Ko2)//両手2部品の時の左手で扱う子部品
			{
				L_use_parts = A_Objects[0][L_KoPnum].Id;
				L_use_object = L_KoPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].ko == L_use_parts)
					{
						L_TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							L_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									L_Jig = k;
									break;
								}

							}
						}
						L_Jigbangou = A_Supports[0][N + putting + 3 + L_Jig].Id;
						L_line = i;
					}
				}
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Oya2)//両手2部品の時の左手で扱う親部品
			{
				L_use_parts = A_Objects[0][L_OyaPnum].Id;
				L_use_object = L_OyaPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].oya == L_use_parts)
					{
						L_TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							L_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									L_Jig = k;
									break;
								}

							}
						}
						L_Jigbangou = A_Supports[0][N + putting + 3 + L_Jig].Id;
						L_line = i;
					}
				}
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Tyukan2)//両手2部品の時の左手で扱う中間製品部品
			{
				L_use_parts = A_Objects[0][L_TyuPnum].Id;
				L_use_object = L_TyuPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].tyukan == L_use_parts)
					{
						L_TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							L_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									L_Jig = k;
									break;
								}

							}
						}
						L_Jigbangou = A_Supports[0][N + putting + 3 + L_Jig].Id;
						L_line = i;
					}
				}
			}

			if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[hidarite][nowmove][move]) == nobasu)//右手と左手が同じ動作で伸ばすの時
			{
				//右手と左手の部品に回転があるときに必要、もしくは右手と左手にこの動作が指定されているとき
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{//Te = M_pattern[movetype].kobuhin[nowmove][Hand];
				//もともと治具に付いている部品(親部品)に手を伸ばす

					L_IchiX1 = A_Objects[0][2 * N - 1 + hidarite].IchiX;//使用する手の現在の位置
					L_IchiY1 = A_Objects[0][2 * N - 1 + hidarite].IchiY;
					L_IchiZ1 = A_Objects[0][2 * N - 1 + hidarite].IchiZ;
					L_IchiX2 = A_Objects[0][L_use_object].IchiX;
					L_IchiY2 = A_Objects[0][L_use_object].IchiY;
					L_IchiZ2 = A_Objects[0][L_use_object].IchiZ;

					R_IchiX1 = A_Objects[0][2 * N - 1 + migite].IchiX;//使用する手の現在の位置
					R_IchiY1 = A_Objects[0][2 * N - 1 + migite].IchiY;
					R_IchiZ1 = A_Objects[0][2 * N - 1 + migite].IchiZ;
					R_IchiX2 = A_Objects[0][R_use_object].IchiX;
					R_IchiY2 = A_Objects[0][R_use_object].IchiY;
					R_IchiZ2 = A_Objects[0][R_use_object].IchiZ;
					/*IchiX2 = A_Objects[0][OyaPnum].IchiX;
					IchiY2 = A_Objects[0][OyaPnum].IchiY;
					IchiZ2 = A_Objects[0][OyaPnum].IchiZ;*/

					WReach(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					R_IchiX1 = A_Objects[0][2 * N - 1 + migite].IchiX;//使用する手の現在の位置
					R_IchiY1 = A_Objects[0][2 * N - 1 + migite].IchiY;
					R_IchiZ1 = A_Objects[0][2 * N - 1 + migite].IchiZ;
					R_IchiX2 = A_Objects[0][R_use_object].IchiX;
					R_IchiY2 = A_Objects[0][R_use_object].IchiY;
					R_IchiZ2 = A_Objects[0][R_use_object].IchiZ;

					Reach(fp2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2, migite);

					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;

				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					L_IchiX1 = A_Objects[0][2 * N - 1 + hidarite].IchiX;//使用する手の現在の位置
					L_IchiY1 = A_Objects[0][2 * N - 1 + hidarite].IchiY;
					L_IchiZ1 = A_Objects[0][2 * N - 1 + hidarite].IchiZ;
					L_IchiX2 = A_Objects[0][L_use_object].IchiX;
					L_IchiY2 = A_Objects[0][L_use_object].IchiY;
					L_IchiZ2 = A_Objects[0][L_use_object].IchiZ;

					Reach(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, hidarite);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == hakobu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					//Te = M_pattern[movetype].kobuhin[nowmove][Hand];

					L_IchiX1 = A_Objects[0][2 * N - 1 + hidarite].IchiX;
					L_IchiY1 = A_Objects[0][2 * N - 1 + hidarite].IchiY;
					L_IchiZ1 = A_Objects[0][2 * N - 1 + hidarite].IchiZ;
					L_IchiX2 = A_Objects[1][L_use_object].IchiX;
					L_IchiY2 = A_Objects[1][L_use_object].IchiY;
					L_IchiZ2 = A_Objects[1][L_use_object].IchiZ;

					R_IchiX1 = A_Objects[0][2 * N - 1 + migite].IchiX;
					R_IchiY1 = A_Objects[0][2 * N - 1 + migite].IchiY;
					R_IchiZ1 = A_Objects[0][2 * N - 1 + migite].IchiZ;
					R_IchiX2 = A_Objects[1][R_use_object].IchiX;
					R_IchiY2 = A_Objects[1][R_use_object].IchiY;
					R_IchiZ2 = A_Objects[1][R_use_object].IchiZ;
					/*IchiX2 = A_Objects[1][TyuPnum].IchiX;
					IchiY2 = A_Objects[1][TyuPnum].IchiY;
					IchiZ2 = A_Objects[1][TyuPnum].IchiZ;*/

					WCarry(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2);//両手で運ぶ carry

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;

					A_Objects[0][R_use_object].IchiX = R_IchiX2;//部品の座標を更新
					A_Objects[0][R_use_object].IchiY = R_IchiY2;
					A_Objects[0][R_use_object].IchiZ = R_IchiZ2;
					A_Objects[0][L_use_object].IchiX = L_IchiX2;//部品の座標を更新
					A_Objects[0][L_use_object].IchiY = L_IchiY2;
					A_Objects[0][L_use_object].IchiZ = L_IchiZ2;
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					R_IchiX1 = A_Objects[0][2 * N - 1 + migite].IchiX;
					R_IchiY1 = A_Objects[0][2 * N - 1 + migite].IchiY;
					R_IchiZ1 = A_Objects[0][2 * N - 1 + migite].IchiZ;
					R_IchiX2 = A_Objects[1][R_use_object].IchiX;
					R_IchiY2 = A_Objects[1][R_use_object].IchiY;
					R_IchiZ2 = A_Objects[1][R_use_object].IchiZ;

					Carry(fp2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2, migite);

					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;

					A_Objects[0][R_use_object].IchiX = R_IchiX2;//部品の座標を更新
					A_Objects[0][R_use_object].IchiY = R_IchiY2;
					A_Objects[0][R_use_object].IchiZ = R_IchiZ2;

				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					L_IchiX1 = A_Objects[0][2 * N - 1 + hidarite].IchiX;
					L_IchiY1 = A_Objects[0][2 * N - 1 + hidarite].IchiY;
					L_IchiZ1 = A_Objects[0][2 * N - 1 + hidarite].IchiZ;
					L_IchiX2 = A_Objects[1][L_use_object].IchiX;
					L_IchiY2 = A_Objects[1][L_use_object].IchiY;
					L_IchiZ2 = A_Objects[1][L_use_object].IchiZ;

					Carry(fp2, L_IchiX1, L_IchiY1, R_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, hidarite);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					A_Objects[0][L_use_object].IchiX = L_IchiX2;//部品の座標を更新
					A_Objects[0][L_use_object].IchiY = L_IchiY2;
					A_Objects[0][L_use_object].IchiZ = L_IchiZ2;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == kumitateidou)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					hold_hands = migite;//部品を持っている手を記録
					/*IchiX1 = A_Objects[1][KoPnum].IchiX;
					IchiY1 = A_Objects[1][KoPnum].IchiY;
					IchiZ1 = A_Objects[1][KoPnum].IchiZ;*/
					L_IchiX1 = A_Objects[1][L_use_object].IchiX;
					L_IchiY1 = A_Objects[1][L_use_object].IchiY;
					L_IchiZ1 = A_Objects[1][L_use_object].IchiZ;

					R_IchiX1 = A_Objects[1][R_use_object].IchiX;
					R_IchiY1 = A_Objects[1][R_use_object].IchiY;
					R_IchiZ1 = A_Objects[1][R_use_object].IchiZ;

					if (kumijun[line].scene_type == oya1ko2 || kumijun[line].scene_type == oya2ko2)
					{
						if (R_line < L_line)
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
						else
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
					}
					else if (kumijun[line].scene_type == oya2ko1)
					{
						if (Oya2flag == 1)//組立順序の最初の部品が基準部品の場合
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
						else if (Oya2flag == 2 || Oya2flag == 3)
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
					}
					else
					{
						R_IchiX2 = KIdo_X;
						R_IchiY2 = KIdo_Y;
						R_IchiZ2 = KIdo_Z;

						L_IchiX2 = KIdo_X;
						L_IchiY2 = KIdo_Y;
						L_IchiZ2 = KIdo_Z;
					}

					WKumimove(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;

					//部品の座標の更新
					A_Objects[1][L_use_object].IchiX = L_IchiX2;
					A_Objects[1][L_use_object].IchiY = L_IchiX2;
					A_Objects[1][L_use_object].IchiZ = L_IchiX2;

					A_Objects[1][R_use_object].IchiX = R_IchiX2;
					A_Objects[1][R_use_object].IchiY = R_IchiY2;
					A_Objects[1][R_use_object].IchiZ = R_IchiZ2;
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					R_IchiX1 = A_Objects[1][R_use_object].IchiX;
					R_IchiY1 = A_Objects[1][R_use_object].IchiY;
					R_IchiZ1 = A_Objects[1][R_use_object].IchiZ;

					if (kumijun[line].scene_type == oya1ko2 || kumijun[line].scene_type == oya2ko2)
					{
						if (R_line < L_line)
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
						else
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
					}
					else if (kumijun[line].scene_type == oya2ko1)
					{
						if (Oya2flag == 1)//組立順序の最初の部品が基準部品の場合
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
						else if (Oya2flag == 2 || Oya2flag == 3)
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
					}
					else
					{
						R_IchiX2 = KIdo_X;
						R_IchiY2 = KIdo_Y;
						R_IchiZ2 = KIdo_Z;

						L_IchiX2 = KIdo_X;
						L_IchiY2 = KIdo_Y;
						L_IchiZ2 = KIdo_Z;
					}

					Kumimove(fp2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2, migite);

					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;
					A_Objects[1][R_use_object].IchiX = R_IchiX2;//部品の座標の更新
					A_Objects[1][R_use_object].IchiY = R_IchiY2;
					A_Objects[1][R_use_object].IchiZ = R_IchiZ2;
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					L_IchiX1 = A_Objects[1][L_use_object].IchiX;
					L_IchiY1 = A_Objects[1][L_use_object].IchiY;
					L_IchiZ1 = A_Objects[1][L_use_object].IchiZ;

					if (kumijun[line].scene_type == oya1ko2 || kumijun[line].scene_type == oya2ko2)
					{
						if (R_line < L_line)
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
						else
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
					}
					else if (kumijun[line].scene_type == oya2ko1)
					{
						if (Oya2flag == 1)//組立順序の最初の部品が基準部品の場合
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
						else if (Oya2flag == 2 || Oya2flag == 3)
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
					}
					else
					{
						R_IchiX2 = KIdo_X;
						R_IchiY2 = KIdo_Y;
						R_IchiZ2 = KIdo_Z;

						L_IchiX2 = KIdo_X;
						L_IchiY2 = KIdo_Y;
						L_IchiZ2 = KIdo_Z;
					}

					Kumimove(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, hidarite);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					//部品の座標の更新
					A_Objects[1][L_use_object].IchiX = L_IchiX2;
					A_Objects[1][L_use_object].IchiY = L_IchiX2;
					A_Objects[1][L_use_object].IchiZ = L_IchiX2;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == tsukeru)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					WFix(fp2, L_Jigbangou, R_Jigbangou, L_use_parts, R_use_parts);//付ける fix

					//治具と親部品の支えの関係をつくる
					A_Supports[1][3 + N + putting + R_Jig].Id = A_Jigus[R_Jig].Jnum;
					A_Supports[1][3 + N + putting + R_Jig].Flag = 1;

					A_Supports[1][3 + N + putting + L_Jig].Id = A_Jigus[L_Jig].Jnum;
					A_Supports[1][3 + N + putting + L_Jig].Flag = 1;

					for (k = 0; k < A_Supports[1][3 + N + putting + R_Jig].Length; k++)//治具と親部品の支えの関係をつくる(右手)
					{
						//A_Supports[0][Te].PId = use_parts;
						if (A_Supports[1][3 + N + putting + R_Jig].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
						{
							supportflug = 1;
							break;
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][3 + N + putting + R_Jig].PId[A_Supports[1][3 + N + putting + R_Jig].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + R_Jig].Length++;
							break;
						}
						else
						{
							supportflug = 0;
						}
					}

					for (k = 0; k < A_Supports[1][3 + N + putting + L_Jig].Length; k++)//治具と親部品の支えの関係をつくる(左手)
					{
						//A_Supports[0][Te].PId = use_parts;
						if (A_Supports[1][3 + N + putting + L_Jig].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
						{
							supportflug = 1;
							break;
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][3 + N + putting + L_Jig].PId[A_Supports[1][3 + N + putting + L_Jig].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + L_Jig].Length++;
							break;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					Fix(fp2, R_Jigbangou, R_use_parts, migite);//付ける fix

					//治具と親部品の支えの関係をつくる
					A_Supports[1][3 + N + putting + R_Jig].Id = A_Jigus[R_Jig].Jnum;
					A_Supports[1][3 + N + putting + R_Jig].Flag = 1;
					for (k = 0; k < A_Supports[1][3 + N + putting + R_Jig].Length; k++)//治具と親部品の支えの関係をつくる(右手)
					{
						//A_Supports[0][Te].PId = use_parts;
						if (A_Supports[1][3 + N + putting + R_Jig].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
						{
							supportflug = 1;
							break;
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][3 + N + putting + R_Jig].PId[A_Supports[1][3 + N + putting + R_Jig].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + R_Jig].Length++;
							break;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					Fix(fp2, L_Jigbangou, L_use_parts, hidarite);//付ける fix
					A_Supports[1][3 + N + putting + L_Jig].Id = A_Jigus[L_Jig].Jnum;
					A_Supports[1][3 + N + putting + L_Jig].Flag = 1;
					for (k = 0; k < A_Supports[1][3 + N + putting + L_Jig].Length; k++)//治具と親部品の支えの関係をつくる(左手)
					{
						//A_Supports[0][Te].PId = use_parts;
						if (A_Supports[1][3 + N + putting + L_Jig].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
						{
							supportflug = 1;
							break;
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][3 + N + putting + L_Jig].PId[A_Supports[1][3 + N + putting + L_Jig].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + L_Jig].Length++;
							break;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == tsukamu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					WGripping(fp2, L_use_parts, R_use_parts);//掴む
					//Gripping(fp2, TyuPa, Te);//掴む

					if (A_Supports[1][hidarite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][hidarite].Flag = 1;
						A_Supports[1][hidarite].PId[0] = L_use_parts;
						A_Supports[1][hidarite].Length++;
					}
					else
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;
						A_Supports[1][hidarite].Flag = 1;
						for (k = 0; k < A_Supports[1][hidarite].Length; k++)
						{
							//A_Supports[0][hidarite].PId = use_parts;
							if (A_Supports[1][hidarite].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][hidarite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

					if (A_Supports[1][migite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][migite].Flag = 1;
						A_Supports[1][migite].PId[0] = R_use_parts;
						A_Supports[1][migite].Length++;
					}
					else
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;
						A_Supports[1][migite].Flag = 1;
						for (k = 0; k < A_Supports[1][migite].Length; k++)
						{
							//A_Supports[0][migite].PId = use_parts;
							if (A_Supports[1][migite].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][migite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					Gripping(fp2, R_use_parts, migite);
					if (A_Supports[1][migite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][migite].Flag = 1;
						A_Supports[1][migite].PId[0] = R_use_parts;
						A_Supports[1][migite].Length++;
					}
					else
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;
						A_Supports[1][migite].Flag = 1;
						for (k = 0; k < A_Supports[1][migite].Length; k++)
						{
							//A_Supports[0][migite].PId = use_parts;
							if (A_Supports[1][migite].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][migite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					Gripping(fp2, L_use_parts, hidarite);
					if (A_Supports[1][hidarite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][hidarite].Flag = 1;
						A_Supports[1][hidarite].PId[0] = L_use_parts;
						A_Supports[1][hidarite].Length++;
					}
					else
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;
						A_Supports[1][hidarite].Flag = 1;
						for (k = 0; k < A_Supports[1][hidarite].Length; k++)
						{
							//A_Supports[0][hidarite].PId = use_parts;
							if (A_Supports[1][hidarite].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][hidarite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == tsukamitoru)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					//右側の部品に関して
					if (JigKobuhin == R_use_parts || JigKobuhin2 == R_use_parts || ChangeJig == R_use_parts || ChangeJig2 == R_use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == R_use_parts)
								{
									BeforeJigR = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					//左側の部品に関して
					if (JigKobuhin == L_use_parts || JigKobuhin2 == L_use_parts || ChangeJig == L_use_parts || ChangeJig2 == L_use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == L_use_parts)
								{
									BeforeJigL = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					for (i = 0; i < Bboxnum; i++)
					{
						for (k = 0; k < A_Supports[1][i + 2].Length; k++)
						{
							if (A_Supports[1][i + 2].PId[k] == L_use_parts || A_Supports[1][i + 2].PId[k] == R_use_parts) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
							   //A_Supports[1][i + 2].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i + 2].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i + 2].Length;
								A_Supports[1][i + 2].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if ((temp[supportlength] != L_use_parts && A_Supports[1][i + 2].PId[k] == L_use_parts) ||
										(temp[supportlength] != R_use_parts && A_Supports[1][i + 2].PId[k] == R_use_parts))//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i + 2].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i + 2].Length == 0)
								{
									A_Supports[1][i + 2].Flag = 0;
								}
								break;
							}
						}
					}
					for (i = 0; i < putting; i++)
					{//中間製品置き場からとるとき、支えの関係を切る
						//if (A_Supports[0][3 + N + i].PId == OyaPa)
						/*if (A_Supports[0][3 + N + i].PId == use_parts)
						{
							A_Supports[1][3 + N + i].Flag = 0;
							A_Supports[1][3 + N + i].PId = 0;
						}*/
						for (k = 0; k < A_Supports[1][3 + N + i].Length; k++)
						{
							if (A_Supports[1][3 + N + i].PId[k] == L_use_parts || A_Supports[1][3 + N + i].PId[k] == R_use_parts)//右手で扱う部品か左手で扱う部品の時
							{
								//A_Supports[1][3 + N + i].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][3 + N + i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][3 + N + i].Length;
								A_Supports[1][3 + N + i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if ((temp[supportlength] != L_use_parts && A_Supports[1][3 + N + i].PId[k] == L_use_parts) ||
										(temp[supportlength] != R_use_parts && A_Supports[1][3 + N + i].PId[k] == R_use_parts))//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = temp[supportlength];//データの移行
										A_Supports[1][3 + N + i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][3 + N + i].Length == 0)
								{
									A_Supports[1][3 + N + i].Flag = 0;
								}
								break;
							}
						}
					}

					if (A_Supports[1][hidarite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][hidarite].Flag = 1;
						A_Supports[1][hidarite].PId[0] = L_use_parts;
						A_Supports[1][hidarite].Length++;
					}
					else
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;
						A_Supports[1][hidarite].Flag = 1;
						for (k = 0; k < A_Supports[1][hidarite].Length; k++)
						{
							//A_Supports[0][hidarite].PId = use_parts;
							if (A_Supports[1][hidarite].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][hidarite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

					if (A_Supports[1][migite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][migite].Flag = 1;
						A_Supports[1][migite].PId[0] = R_use_parts;
						A_Supports[1][migite].Length++;
					}
					else
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;
						A_Supports[1][migite].Flag = 1;
						for (k = 0; k < A_Supports[1][migite].Length; k++)
						{
							//A_Supports[0][migite].PId = use_parts;
							if (A_Supports[1][migite].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][migite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

					WGrip(fp2, L_use_parts, R_use_parts, BeforeJigL, BeforeJigR);
					BeforeJigL = BeforeJigR = 0;
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					if (JigKobuhin == R_use_parts || JigKobuhin2 == R_use_parts || ChangeJig == R_use_parts || ChangeJig2 == R_use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == R_use_parts)
								{
									BeforeJigR = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					for (i = 0; i < Bboxnum; i++)
					{
						for (k = 0; k < A_Supports[1][i + 2].Length; k++)
						{
							if (A_Supports[1][i + 2].PId[k] == R_use_parts) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
							   //A_Supports[1][i + 2].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i + 2].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i + 2].Length;
								A_Supports[1][i + 2].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != R_use_parts && A_Supports[1][i + 2].PId[k] == R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i + 2].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i + 2].Length == 0)
								{
									A_Supports[1][i + 2].Flag = 0;
								}
								break;
							}
						}
					}
					for (i = 0; i < putting; i++)
					{//中間製品置き場からとるとき、支えの関係を切る
						//if (A_Supports[0][3 + N + i].PId == OyaPa)
						/*if (A_Supports[0][3 + N + i].PId == use_parts)
						{
							A_Supports[1][3 + N + i].Flag = 0;
							A_Supports[1][3 + N + i].PId = 0;
						}*/
						for (k = 0; k < A_Supports[1][3 + N + i].Length; k++)
						{
							if (A_Supports[1][3 + N + i].PId[k] == R_use_parts)//右手で扱う部品か左手で扱う部品の時
							{
								//A_Supports[1][3 + N + i].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][3 + N + i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][3 + N + i].Length;
								A_Supports[1][3 + N + i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != R_use_parts && A_Supports[1][3 + N + i].PId[k] == R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = temp[supportlength];//データの移行
										A_Supports[1][3 + N + i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][3 + N + i].Length == 0)
								{
									A_Supports[1][3 + N + i].Flag = 0;
								}
								break;
							}
						}
					}
					if (A_Supports[1][migite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][migite].Flag = 1;
						A_Supports[1][migite].PId[0] = use_parts;
						A_Supports[1][migite].Length++;
					}
					else
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;
						A_Supports[1][migite].Flag = 1;
						for (k = 0; k < A_Supports[1][migite].Length; k++)
						{
							//A_Supports[0][migite].PId = use_parts;
							if (A_Supports[1][migite].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][migite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
					Grip(fp2, R_use_parts, BeforeJigR, migite);
					BeforeJigR = 0;
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					if (JigKobuhin == L_use_parts || JigKobuhin2 == L_use_parts || ChangeJig == L_use_parts || ChangeJig2 == L_use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == L_use_parts)
								{
									BeforeJigL = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					for (i = 0; i < Bboxnum; i++)
					{
						for (k = 0; k < A_Supports[1][i + 2].Length; k++)
						{
							if (A_Supports[1][i + 2].PId[k] == L_use_parts) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
							   //A_Supports[1][i + 2].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i + 2].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i + 2].Length;
								A_Supports[1][i + 2].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != L_use_parts && A_Supports[1][i + 2].PId[k] == L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i + 2].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i + 2].Length == 0)
								{
									A_Supports[1][i + 2].Flag = 0;
								}
								break;
							}
						}
					}
					for (i = 0; i < putting; i++)
					{//中間製品置き場からとるとき、支えの関係を切る
						//if (A_Supports[0][3 + N + i].PId == OyaPa)
						/*if (A_Supports[0][3 + N + i].PId == use_parts)
						{
							A_Supports[1][3 + N + i].Flag = 0;
							A_Supports[1][3 + N + i].PId = 0;
						}*/
						for (k = 0; k < A_Supports[1][3 + N + i].Length; k++)
						{
							if (A_Supports[1][3 + N + i].PId[k] == L_use_parts)//右手で扱う部品か左手で扱う部品の時
							{
								//A_Supports[1][3 + N + i].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][3 + N + i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][3 + N + i].Length;
								A_Supports[1][3 + N + i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != L_use_parts && A_Supports[1][3 + N + i].PId[k] == L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = temp[supportlength];//データの移行
										A_Supports[1][3 + N + i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][3 + N + i].Length == 0)
								{
									A_Supports[1][3 + N + i].Flag = 0;
								}
								break;
							}
						}
					}

					if (A_Supports[1][hidarite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][hidarite].Flag = 1;
						A_Supports[1][hidarite].PId[0] = use_parts;
						A_Supports[1][hidarite].Length++;
					}
					else
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;
						A_Supports[1][hidarite].Flag = 1;
						for (k = 0; k < A_Supports[1][hidarite].Length; k++)
						{
							//A_Supports[0][hidarite].PId = use_parts;
							if (A_Supports[1][hidarite].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][hidarite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

					Grip(fp2, L_use_parts, BeforeJigL, hidarite);
					BeforeJigL = 0;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == okihanasu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					Wleave(fp2, L_use_parts, R_use_parts);//置き放す leave
					//leave(fp2, TyuPa, Te);//置き放す leave

					for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
					{//左手、右手、冶具の支えの関係を切る
						//if (A_Supports[1][i].PId == TyuPa)
						f = A_Supports[1][i].Length;//支えている数を保存
						for (k = 0; k < f; k++)
						{
							/*if (A_Supports[1][i].PId == use_parts)
							{
								A_Supports[1][i].Flag = 0;
								A_Supports[1][i].PId = 0;
							}*/
							if (A_Supports[1][i].PId[k] == L_use_parts || A_Supports[1][i].PId[k] == R_use_parts)//組立後に部品を支えていてはいけないのでA_Supports[1][i].PId
							{
								for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i].Length;
								A_Supports[1][i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if ((temp[supportlength] != L_use_parts && A_Supports[1][3 + N + i].PId[k] == L_use_parts) ||
										(temp[supportlength] != R_use_parts && A_Supports[1][3 + N + i].PId[k] == R_use_parts))//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i].PId[A_Supports[1][i].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i].Length == 0)
								{
									A_Supports[1][i].Flag = 0;
								}
								break;
							}
						}

						if (i == Tnum - 1 + N + 3)
						{//中間製品置き場と中間製品の支えの関係を作る
							A_Supports[1][i].Flag = 1;
							//A_Supports[1][i].PId = use_parts;
							//A_Supports[1][i].PId = TyuPa;
							for (k = 0; k < A_Supports[1][i].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][i].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = supportflug + 1;//左手で扱う部品を持っている時は＋1する
								}
								else if (A_Supports[1][i].PId[k] == R_use_parts)
								{
									supportflug = supportflug + 2;//右手で扱う部品を持っている時は＋2する
								}
							}
							if (supportflug == 0)//まだ支えられていない時
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = L_use_parts;//中間製品置き場と左手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;

								A_Supports[1][i].PId[A_Supports[1][i].Length] = R_use_parts;//中間製品置き場と右手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else if (supportflug == 1)//左手で扱う部品がすでに支えられているとき(一応の作業)
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = R_use_parts;//中間製品置き場と中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else if (supportflug == 2)//右手で扱う部品がすでに支えられているとき(一応の作業)
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = L_use_parts;//中間製品置き場と左手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else
							{
								supportflug = 0;
							}
						}
					}

				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					leave(fp2, R_use_parts, migite);
					for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
					{//右手、冶具の支えの関係を切る
						//if (A_Supports[1][i].PId == TyuPa)
						f = A_Supports[1][i].Length;//支えている数を保存
						for (k = 0; k < f; k++)
						{
							/*if (A_Supports[1][i].PId == use_parts)
							{
								A_Supports[1][i].Flag = 0;
								A_Supports[1][i].PId = 0;
							}*/
							if (A_Supports[1][i].PId[k] == R_use_parts)//組立後に部品を支えていてはいけないのでA_Supports[1][i].PId
							{
								for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i].Length;
								A_Supports[1][i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != R_use_parts && A_Supports[1][3 + N + i].PId[k] == R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i].PId[A_Supports[1][i].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i].Length == 0)
								{
									A_Supports[1][i].Flag = 0;
								}
								break;
							}
						}

						if (i == Tnum - 1 + N + 3)
						{//中間製品置き場と中間製品の支えの関係を作る
							A_Supports[1][i].Flag = 1;
							//A_Supports[1][i].PId = use_parts;
							//A_Supports[1][i].PId = TyuPa;
							for (k = 0; k < A_Supports[1][i].Length; k++)
							{
								if (A_Supports[1][i].PId[k] == R_use_parts)
								{
									supportflug = supportflug + 2;//右手で扱う部品を持っている時は＋2する
								}
							}
							if (supportflug == 0)//まだ支えられていない時
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = R_use_parts;//中間製品置き場と右手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else
							{
								supportflug = 0;
							}
						}
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					leave(fp2, L_use_parts, hidarite);
					for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
					{//左手、右手、冶具の支えの関係を切る
						//if (A_Supports[1][i].PId == TyuPa)
						f = A_Supports[1][i].Length;//支えている数を保存
						for (k = 0; k < f; k++)
						{
							/*if (A_Supports[1][i].PId == use_parts)
							{
								A_Supports[1][i].Flag = 0;
								A_Supports[1][i].PId = 0;
							}*/
							if (A_Supports[1][i].PId[k] == L_use_parts)//組立後に部品を支えていてはいけないのでA_Supports[1][i].PId
							{
								for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i].Length;
								A_Supports[1][i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != L_use_parts && A_Supports[1][3 + N + i].PId[k] == L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i].PId[A_Supports[1][i].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i].Length == 0)
								{
									A_Supports[1][i].Flag = 0;
								}
								break;
							}
						}

						if (i == Tnum - 1 + N + 3)
						{//中間製品置き場と中間製品の支えの関係を作る
							A_Supports[1][i].Flag = 1;
							//A_Supports[1][i].PId = use_parts;
							//A_Supports[1][i].PId = TyuPa;
							for (k = 0; k < A_Supports[1][i].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][i].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = supportflug + 1;//左手で扱う部品を持っている時は＋1する
								}
							}
							if (supportflug == 0)//まだ支えられていない時
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = L_use_parts;//中間製品置き場と左手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else
							{
								supportflug = 0;
							}
						}
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == hanasu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					WRelease(fp2, L_use_parts, R_use_parts);//両手で放すrelease

					for (supportlength = 0; supportlength < A_Supports[1][hidarite].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][hidarite].PId[supportlength];//値を移す
						A_Supports[1][hidarite].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][hidarite].Length;
					A_Supports[1][hidarite].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != L_use_parts)
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = temp[k];
							A_Supports[1][hidarite].Length++;
						}
					}
					if (A_Supports[1][hidarite].Length == 0)
					{
						A_Supports[1][hidarite].Flag = 0;
					}

					for (supportlength = 0; supportlength < A_Supports[1][migite].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][migite].PId[supportlength];//値を移す
						A_Supports[1][migite].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][migite].Length;
					A_Supports[1][migite].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != use_parts)
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = temp[k];
							A_Supports[1][migite].Length++;
						}
					}
					if (A_Supports[1][migite].Length == 0)
					{
						A_Supports[1][migite].Flag = 0;
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					Release(fp2, R_use_parts, migite);//右手で放すrelease
					for (supportlength = 0; supportlength < A_Supports[1][migite].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][migite].PId[supportlength];//値を移す
						A_Supports[1][migite].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][migite].Length;
					A_Supports[1][migite].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != use_parts)
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = temp[k];
							A_Supports[1][migite].Length++;
						}
					}
					if (A_Supports[1][migite].Length == 0)
					{
						A_Supports[1][migite].Flag = 0;
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					Release(fp2, L_use_parts, hidarite);//左手で放すrelease
					for (supportlength = 0; supportlength < A_Supports[1][hidarite].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][hidarite].PId[supportlength];//値を移す
						A_Supports[1][hidarite].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][hidarite].Length;
					A_Supports[1][hidarite].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != L_use_parts)
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = temp[k];
							A_Supports[1][hidarite].Length++;
						}
					}
					if (A_Supports[1][hidarite].Length == 0)
					{
						A_Supports[1][hidarite].Flag = 0;
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == kumitateru)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					oya_hoji = A_Jigus[Jig].Jnum;
					if (R_line < L_line)
					{
						Kumitate(fp2, A_Supports[1][N + putting + 3 + R_Jig].Id, TyuPa, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
						Kumitate(fp2, A_Supports[1][N + putting + 3 + L_Jig].Id, TyuPa2, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
					}
					else
					{
						Kumitate(fp2, A_Supports[1][N + putting + 3 + L_Jig].Id, TyuPa, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
						Kumitate(fp2, A_Supports[1][N + putting + 3 + R_Jig].Id, TyuPa2, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					oya_hoji = A_Jigus[Jig].Jnum;
					if (R_line < L_line)
					{
						Kumitate(fp2, A_Supports[1][N + putting + 3 + R_Jig].Id, TyuPa, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[L_line].jig - 1].Id, TyuPa2, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
					}
					else
					{
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[L_line].jig - 1].Id, TyuPa, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
						Kumitate(fp2, A_Supports[1][N + putting + 3 + R_Jig].Id, TyuPa2, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
					}

				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					oya_hoji = A_Jigus[Jig].Jnum;
					if (R_line < L_line)
					{
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[R_line].jig - 1].Id, TyuPa, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
						Kumitate(fp2, A_Supports[1][N + putting + 3 + L_Jig].Id, TyuPa2, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
					}
					else
					{
						Kumitate(fp2, A_Supports[1][N + putting + 3 + L_Jig].Id, TyuPa, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[R_line].jig - 1].Id, TyuPa2, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == motinaosu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					L_Turn0X = A_Objects[0][L_use_object].DirX;
					L_Turn1X = A_Objects[1][L_use_object].DirX;
					L_Turn0Y = A_Objects[0][L_use_object].DirY;
					L_Turn1Y = A_Objects[1][L_use_object].DirY;
					L_Turn0Z = A_Objects[0][L_use_object].DirZ;
					L_Turn1Z = A_Objects[1][L_use_object].DirZ;

					R_Turn0X = A_Objects[0][R_use_object].DirX;
					R_Turn1X = A_Objects[1][R_use_object].DirX;
					R_Turn0Y = A_Objects[0][R_use_object].DirY;
					R_Turn1Y = A_Objects[1][R_use_object].DirY;
					R_Turn0Z = A_Objects[0][R_use_object].DirZ;
					R_Turn1Z = A_Objects[1][R_use_object].DirZ;

					WTurn(fp2, L_use_parts, L_Turn0X, L_Turn0Y, L_Turn0Z, L_Turn1X, L_Turn1Y, L_Turn1Z, R_use_parts, R_Turn0X, R_Turn0Y, R_Turn0Z, R_Turn1X, R_Turn1Y, R_Turn1Z);//左手で回転させるturn
					if (M_pattern[movetype].Move[migite][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(R_Turn0X - R_Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(R_Turn0Y - R_Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(R_Turn0Z - R_Turn1Z) + Oyakaitenkakudo;
					}
					if (M_pattern[movetype].Move[hidarite][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(L_Turn0X - L_Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(L_Turn0Y - L_Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(L_Turn0Z - L_Turn1Z) + Oyakaitenkakudo;
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					R_Turn0X = A_Objects[0][R_use_object].DirX;
					R_Turn1X = A_Objects[1][R_use_object].DirX;
					R_Turn0Y = A_Objects[0][R_use_object].DirY;
					R_Turn1Y = A_Objects[1][R_use_object].DirY;
					R_Turn0Z = A_Objects[0][R_use_object].DirZ;
					R_Turn1Z = A_Objects[1][R_use_object].DirZ;

					Turn(fp2, R_use_parts, R_Turn0X, R_Turn0Y, R_Turn0Z, R_Turn1X, R_Turn1Y, R_Turn1Z, migite);//回転させるturn
					if (M_pattern[movetype].Move[migite][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(R_Turn0X - R_Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(R_Turn0Y - R_Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(R_Turn0Z - R_Turn1Z) + Oyakaitenkakudo;
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					L_Turn0X = A_Objects[0][L_use_object].DirX;
					L_Turn1X = A_Objects[1][L_use_object].DirX;
					L_Turn0Y = A_Objects[0][L_use_object].DirY;
					L_Turn1Y = A_Objects[1][L_use_object].DirY;
					L_Turn0Z = A_Objects[0][L_use_object].DirZ;
					L_Turn1Z = A_Objects[1][L_use_object].DirZ;
					Turn(fp2, L_use_parts, L_Turn0X, L_Turn0Y, L_Turn0Z, L_Turn1X, L_Turn1Y, L_Turn1Z, hidarite);
					if (M_pattern[movetype].Move[hidarite][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(L_Turn0X - L_Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(L_Turn0Y - L_Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(L_Turn0Z - L_Turn1Z) + Oyakaitenkakudo;
					}
				}
			}
		}
	}
	for (i = 0; i < 2; i++)
	{
		//手の最終座標を合わせる
		A_Objects[1][2 * N - 1 + i].IchiX = A_Objects[0][2 * N - 1 + i].IchiX;
		A_Objects[1][2 * N - 1 + i].IchiY = A_Objects[0][2 * N - 1 + i].IchiY;
		A_Objects[1][2 * N - 1 + i].IchiZ = A_Objects[0][2 * N - 1 + i].IchiZ;
	}
	//printf("%d\n", kumijun[line].kougu);
	if (kumijun[line].kougu != 0)//工具を用いる時
	{
		A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiX = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiX;//工具の座標を更新
		A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiY = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY;
		A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY;
		//printf("%lf--%lf--%lf", A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiX, A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiY, A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiZ);
	}
}

void kumitatemae_to_kumitatego(FILE* fp2, int line, int movetype)
{
	int i = 0, R_length = 0, L_length = 0, length = 0, /*movetype = 0,*/ Te = 0, nowmove = 0, Jig = 0;
	int OyaPa, KoPa, TyuPa, Jigbangou = 0;//親部品番号,子部品番号,中間製品
	double IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Turn0X, Turn0Y, Turn0Z, Turn1X, Turn1Y, Turn1Z;
	int Oyanum = 0;//親部品が何番目にあるか
	int use_parts = 0/*使用する部品番号*/, use_object = 0/*使用する部品がobjectでどこにあるか*/;
	int R_use_parts = 0/*右手で使用する部品番号*/, R_use_object = 0;/*右手で使用する部品がobjectでどこにあるか*/
	int L_use_parts = 0/*左手で使用する部品番号*/, L_use_object = 0;/*左手で使用する部品がobjectでどこにあるか*/
	double R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2, R_Turn0X, R_Turn0Y, R_Turn0Z, R_Turn1X, R_Turn1Y, R_Turn1Z;
	double L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, L_Turn0X, L_Turn0Y, L_Turn0Z, L_Turn1X, L_Turn1Y, L_Turn1Z;
	int temp[MaxSupport], templength = 0;

	int R_Jig = 0, L_Jig = 0, R_Jigbangou = 0, L_Jigbangou = 0, R_TyuPa = 0, L_TyuPa = 0, TyuPa2 = 0, R_line = 0/*両手の時右手の組付けが一行目か二行目かどうかを保管*/, L_line = 0/*両手の時右手の組付けが一行目か二行目かどうかを保管*/;
	int supportlength = 0, k = 0, supportflug = 0, f = 0;
	int KouguBnum = 0, Kougunum = 0, KouguPnum = 0;//KouguBnum：レイアウト情報での工具の番号、Kougunum：工具番号,KouguPnum：工具がobjectsでどこにあるか
	int ChangeKouguBnum = 0, ChangeKougunum = 0, ChangeKouguPnum = 0;//ChangeKouguBnum：レイアウト情報での交換する工具の番号、ChangeKougunum：交換する工具番号,ChangeKouguPnum：交換する工具がobjectsでどこにあるか
	int TempKougunum = 0;
	int BeforeJig = 0;
	int BeforeJigR = 0, BeforeJigL = 0;

	TyuPa2 = kumijun[line + 1].tyukan;

	R_length = M_pattern[movetype].length[migite];
	L_length = M_pattern[movetype].length[hidarite];
	KoPa = kumijun[line].ko;
	OyaPa = kumijun[line].oya;
	TyuPa = kumijun[line].tyukan;
	if (NewNOS0 == 0)
	{
		Jig = kumijun[line].jig - 1;
		Kougunum = kumijun[line].kougu - 1;
		ChangeKougunum = kumijun[line - 1].kougu - 1;
	}
	else
	{
		for (i = 0; i < Jigu; i++)
		{
			if (A_Objects[0][3 * N + 2 + i + putting].Id == kumijun[line].jig)
			{
				Jig = i;
				break;
			}
		}
		for (i = 0; i < Kougu; i++)
		{
			if (A_Objects[0][3 * N + 2 + i + putting + Jigu].Id == kumijun[line].kougu)
			{
				Kougunum = i;
				break;
			}
		}
		for (i = 0; i < Kougu; i++)
		{
			if (A_Objects[0][3 * N + 2 + i + putting + Jigu].Id == kumijun[line - 1].kougu)
			{
				ChangeKougunum = i;
				break;
			}
		}
	}
	Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
	//Kougunum = kumijun[line].kougu;
	KouguBnum = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].Id;
	//ChangeKougunum = kumijun[line-1].kougu;
	ChangeKouguBnum = A_Objects[0][3 * N + 2 + ChangeKougunum + putting + Jigu].Id;

	if (R_length > L_length)
	{
		length = R_length;
	}
	else
	{
		length = L_length;
	}

	for (nowmove = 0; nowmove <= length; nowmove++)
	{
		if (M_pattern[movetype].Move[migite][nowmove][move] != none && M_pattern[movetype].Move[hidarite][nowmove][move] != none)//右手左手両方に同時に動作がある時
		{
			Te = ryoute;
		}
		else if (M_pattern[movetype].Move[migite][nowmove][move] != none)//右手に作業がある時
		{
			Te = migite;
		}
		else if (M_pattern[movetype].Move[hidarite][nowmove][move] != none)//左手に動作がある時
		{
			Te = hidarite;
		}
		//どの部品を対象とするかを調べる
		if (Te == migite || Te == hidarite)//両手で同時に作業をしない時
		{

			if (M_pattern[movetype].Move[Te][nowmove][target] == Oya)//対象製品が親部品
			{
				if (Oya2flag == 1)//基準部品が最初の部品の時
				{//2番目の部品が対象の部品になる
					use_parts = kumijun[line + 1].oya;
					use_object = OyaPnum;
				}
				else if (Oya2flag == 2)//基準部品が2番目の部品の時
				{//最初の部品が対象の部品になる
					use_parts = kumijun[line].oya;
					use_object = OyaPnum1;
				}
				else
				{
					use_parts = OyaPa;
					if (kumijun[line].scene_type == oya1ko2)
					{
						use_object = OyaPnum1;
					}
					else
					{
						use_object = OyaPnum;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Ko)//対象製品が子部品
			{
				use_parts = KoPa;
				use_object = KoPnum;
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Tyukan)//対象製品が中間製品
			{
				use_parts = TyuPa;
				use_object = TyuPnum;
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Start_P)//手を初期位置に戻すとき、対象製品は使用する手
			{
				use_object = 2 * N - 1 + Te;
			}

			else if (M_pattern[movetype].Move[Te][nowmove][target] == Ko1)//両手2部品の時の右手で扱う子部品
			{
				use_parts = A_Objects[0][R_KoPnum].Id;
				use_object = R_KoPnum;
				if (Oya2flag == 2)
				{
					use_object = KoPnum1;
				}
				else if (Oya2flag == 1)
				{
					use_object = KoPnum1;
				}
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].ko == R_use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						OyaPa = kumijun[i].oya;
						KoPa = kumijun[i].ko;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Oya1)//両手2部品の時の右手で扱う親部品
			{
				use_parts = A_Objects[0][R_OyaPnum].Id;
				use_object = R_OyaPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].oya == R_use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Tyukan1)//両手2部品の時の右手で扱う中間製品部品
			{
				use_parts = A_Objects[0][R_TyuPnum].Id;
				use_object = R_TyuPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].tyukan == use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Ko2)//両手2部品の時の左手で扱う子部品
			{
			
				use_parts = A_Objects[0][L_KoPnum].Id;
				use_object = L_KoPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].ko == use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						OyaPa = kumijun[i].oya;
						KoPa = kumijun[i].ko;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + i + putting].Id == kumijun[i].jig)
								{
									Jig = i;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Oya2)//両手2部品の時の左手で扱う親部品
			{
				use_parts = A_Objects[0][L_OyaPnum].Id;
				use_object = L_OyaPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].oya == use_parts)
					{
						OyaPa = kumijun[i].oya;
						KoPa = kumijun[line].ko;
						TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Tyukan2)//両手2部品の時の左手で扱う中間製品部品
			{
				use_parts = A_Objects[0][L_TyuPnum].Id;
				use_object = L_TyuPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].tyukan == L_use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)
			{
				use_parts = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].Id;
				use_object = 3 * N + 2 + Kougunum + putting + Jigu;
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == ChangeKOUGU)
			{
				use_parts = A_Objects[0][3 * N + 2 + ChangeKougunum + putting + Jigu].Id;
				use_object = 3 * N + 2 + ChangeKougunum + putting + Jigu;
			}
			if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == nobasu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{//Te = M_pattern[movetype].kobuhin[nowmove][Hand];
				//もともと治具に付いている部品(親部品)に手を伸ばす
					IchiX1 = A_Objects[0][2 * N - 1 + Te].IchiX;//使用する手の現在の位置
					IchiY1 = A_Objects[0][2 * N - 1 + Te].IchiY;
					IchiZ1 = A_Objects[0][2 * N - 1 + Te].IchiZ;
					if (M_pattern[movetype].Move[Te][nowmove][target] == Start_P)
					{
						IchiX2 = A_Objects[1][use_object].IchiX;
						IchiY2 = A_Objects[1][use_object].IchiY;
						IchiZ2 = A_Objects[1][use_object].IchiZ;
					}
					else
					{
						IchiX2 = A_Objects[0][use_object].IchiX;
						IchiY2 = A_Objects[0][use_object].IchiY;
						IchiZ2 = A_Objects[0][use_object].IchiZ;
					}
					/*IchiX2 = A_Objects[0][OyaPnum].IchiX;
					IchiY2 = A_Objects[0][OyaPnum].IchiY;
					IchiZ2 = A_Objects[0][OyaPnum].IchiZ;*/

					Reach(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);

					A_Objects[0][2 * N - 1 + Te].IchiX = IchiX2;//手の座標を更新
					A_Objects[0][2 * N - 1 + Te].IchiY = IchiY2;
					A_Objects[0][2 * N - 1 + Te].IchiZ = IchiZ2;
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == tsukamu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = Te;//部品を持っている手を記録
					if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)//対象が工具の時は工具を使用していることを記録しておく
					{
						Kouguflag = KouguBnum;
					}
					Gripping(fp2, use_parts, Te);//掴む
					//Gripping(fp2, TyuPa, Te);//掴む
					if (A_Supports[1][Te].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][Te].Id = A_Hands[Te].Hnum;//部品と手の支えの関係をつくる
						A_Supports[1][Te].Flag = 1;
						A_Supports[1][Te].PId[0] = use_parts;
						A_Supports[1][Te].Length++;
					}
					else
					{
						A_Supports[1][Te].Id = A_Hands[Te].Hnum;
						A_Supports[1][Te].Flag = 1;
						for (k = 0; k < A_Supports[1][Te].Length; k++)
						{
							//A_Supports[0][Te].PId = use_parts;
							if (A_Supports[1][Te].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][Te].PId[A_Supports[1][Te].Length] = use_parts;//部品と手の支えの関係をつくる
							A_Supports[1][Te].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
					//A_Supports[1][Te].PId = TyuPa;
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == tsukamitoru)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = Te;//部品を持っている手を記録
					if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)//対象が工具の時は工具を使用していることを記録しておく
					{
						Kouguflag = KouguBnum;
					}

					if (JigKobuhin == use_parts || JigKobuhin2 == use_parts || ChangeJig == use_parts || ChangeJig2 == use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == use_parts)
								{
									BeforeJig = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					//部品箱の支えの関係を切る
					for (i = 0; i < Bboxnum; i++)
					{
						for (k = 0; k < A_Supports[1][i + 2].Length; k++)
						{
							if (A_Supports[1][i + 2].PId[k] == use_parts) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
							   //A_Supports[1][i + 2].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i + 2].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i + 2].Length;
								A_Supports[1][i + 2].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i + 2].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i + 2].Length == 0)
								{
									A_Supports[1][i + 2].Flag = 0;
								}
								break;
							}
						}
					}
					for (i = 0; i < putting; i++)
					{//中間製品置き場からとるとき、支えの関係を切る
						//if (A_Supports[0][3 + N + i].PId == OyaPa)
						/*if (A_Supports[0][3 + N + i].PId == use_parts)
						{
							A_Supports[1][3 + N + i].Flag = 0;
							A_Supports[1][3 + N + i].PId = 0;
						}*/
						for (k = 0; k < A_Supports[1][3 + N + i].Length; k++)
						{
							if (A_Supports[1][3 + N + i].PId[k] == use_parts) {//A_Supports[][0],A_Supports[][1]には
							   //A_Supports[1][3 + N + i].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][3 + N + i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][3 + N + i].Length;
								A_Supports[1][3 + N + i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = temp[supportlength];//データの移行
										A_Supports[1][3 + N + i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][3 + N + i].Length == 0)
								{
									A_Supports[1][3 + N + i].Flag = 0;
								}
								break;
							}
						}
					}

					if (A_Supports[1][Te].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][Te].Id = A_Hands[Te].Hnum;//部品と手の支えの関係をつくる
						A_Supports[1][Te].Flag = 1;
						A_Supports[1][Te].PId[0] = use_parts;
						A_Supports[1][Te].Length++;
					}
					else
					{
						A_Supports[1][Te].Id = A_Hands[Te].Hnum;
						A_Supports[1][Te].Flag = 1;
						for (k = 0; k < A_Supports[1][Te].Length; k++)
						{
							//A_Supports[0][Te].PId = use_parts;
							if (A_Supports[1][Te].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][Te].PId[A_Supports[1][Te].Length] = use_parts;//部品と手の支えの関係をつくる
							A_Supports[1][Te].Length++;
						}
						else
						{
							supportflug = 0;
						}

					}
					//A_Supports[0][Te].PId = OyaPa;

					Grip(fp2, use_parts, BeforeJig, Te);//掴み取る grip
					//Grip(fp2, OyaPa, Te);//掴み取る grip
					BeforeJig = 0;
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == hakobu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					//Te = M_pattern[movetype].kobuhin[nowmove][Hand];

					IchiX1 = A_Objects[0][2 * N - 1 + Te].IchiX;
					IchiY1 = A_Objects[0][2 * N - 1 + Te].IchiY;
					IchiZ1 = A_Objects[0][2 * N - 1 + Te].IchiZ;
					IchiX2 = A_Objects[1][use_object].IchiX;
					IchiY2 = A_Objects[1][use_object].IchiY;
					IchiZ2 = A_Objects[1][use_object].IchiZ;
					/*IchiX2 = A_Objects[1][TyuPnum].IchiX;
					IchiY2 = A_Objects[1][TyuPnum].IchiY;
					IchiZ2 = A_Objects[1][TyuPnum].IchiZ;*/

					Carry(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);//左手で運ぶ carry

					A_Objects[0][2 * N - 1 + Te].IchiX = IchiX2;//手の座標を更新
					A_Objects[0][2 * N - 1 + Te].IchiY = IchiY2;
					A_Objects[0][2 * N - 1 + Te].IchiZ = IchiZ2;

					A_Objects[0][use_object].IchiX = IchiX2;//部品の座標を更新
					A_Objects[0][use_object].IchiY = IchiY2;
					A_Objects[0][use_object].IchiZ = IchiZ2;

					if ((Kouguflag != 0 && M_pattern[movetype].Move[Te][nowmove][target] == Ko) || M_pattern[movetype].Move[Te][nowmove][target] == KOUGU || M_pattern[movetype].Move[Te][nowmove][target] == ChangeKOUGU)//工具を用いて部品を運ぶ場合は工具の座標も変更
					{
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiX = IchiX2;//工具の座標を更新
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY = IchiY2;
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = IchiZ2;
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == okihanasu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = -1;//部品を持っている手がないことを記録
					if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)//対象が工具の時は工具を使用していないのでフラグを0に戻す
					{
						Kouguflag = 0;
					}

					for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
					{//左手、右手、冶具の支えの関係を切る
						//if (A_Supports[1][i].PId == TyuPa)
						f = A_Supports[1][i].Length;//支えている数を保存
						for (k = 0; k < f; k++)
						{
							/*if (A_Supports[1][i].PId == use_parts)
							{
								A_Supports[1][i].Flag = 0;
								A_Supports[1][i].PId = 0;
							}*/
							if (A_Supports[1][i].PId[k] == use_parts)//組立後に部品を支えていてはいけないのでA_Supports[1][i].PId
							{
								for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i].Length;
								A_Supports[1][i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != use_parts)//一致する部品は支えない部品なのでカウントしない
									{
										A_Supports[1][i].PId[A_Supports[1][i].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i].Length == 0)
								{
									A_Supports[1][i].Flag = 0;
								}
								break;
							}
						}

						if (i == Tnum - 1 + N + 3)
						{//中間製品置き場と中間製品の支えの関係を作る
							A_Supports[1][i].Flag = 1;
							//A_Supports[1][i].PId = use_parts;
							//A_Supports[1][i].PId = TyuPa;
							for (k = 0; k < A_Supports[1][i].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][i].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = 1;
									break;
								}
							}
							if (supportflug == 0)//まだ支えられていない時
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = use_parts;//親部品と手の支えの関係をつくる
								A_Supports[1][i].Length++;
							}
							else
							{
								supportflug = 0;
							}
						}
					}

					leave(fp2, use_parts, Te);//置き放す leave
					//leave(fp2, TyuPa, Te);//置き放す leave
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == tsukeru)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = Te;//部品を持っている手を記録

					if (M_pattern[movetype].Move[Te][nowmove][destination] == KOUGU)//付ける対象が工具の時は工具に付ける
					{
						Fix(fp2, KouguBnum, use_parts, Te);//付ける fix
						//Fix(fp2, Jigbangou, OyaPa, Te);//付ける fix

						//工具と親部品の支えの関係をつくる
						A_Supports[1][N + 3 + putting + Jigu + Kougunum].Id = A_Kougus[Kougunum].Bnum;
						A_Supports[1][N + 3 + putting + Jigu + Kougunum].Flag = 1;

						if (A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length == 0)
						{
							A_Supports[1][N + 3 + putting + Jigu + Kougunum].PId[A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length] = use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length++;
						}
						else
						{
							for (k = 0; k < A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][N + 3 + putting + Jigu + Kougunum].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = 1;
									break;
								}

								if (supportflug == 0)//まだ支えられていない時
								{
									A_Supports[1][N + 3 + putting + Jigu + Kougunum].PId[A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length] = use_parts;//親部品と手の支えの関係をつくる
									A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length++;
									break;
								}
								else
								{
									supportflug = 0;
								}
							}
						}
					}
					else
					{
						Fix(fp2, Jigbangou, use_parts, Te);//付ける fix
					   //Fix(fp2, Jigbangou, OyaPa, Te);//付ける fix

					   //治具と親部品の支えの関係をつくる
						A_Supports[1][3 + N + putting + Jig].Id = A_Jigus[Jig].Jnum;
						A_Supports[1][3 + N + putting + Jig].Flag = 1;
						//A_Supports[1][3 + N + putting + Jig].PId = use_parts;
						//A_Supports[1][3 + N + putting + Jig].PId = OyaPa;

						if (A_Supports[1][3 + N + putting + Jig].Length == 0)
						{
							A_Supports[1][3 + N + putting + Jig].PId[A_Supports[1][3 + N + putting + Jig].Length] = use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + Jig].Length++;
						}
						else
						{
							for (k = 0; k < A_Supports[1][3 + N + putting + Jig].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][3 + N + putting + Jig].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = 1;
									break;
								}

								if (supportflug == 0)//まだ支えられていない時
								{
									A_Supports[1][3 + N + putting + Jig].PId[A_Supports[1][3 + N + putting + Jig].Length] = use_parts;//親部品と手の支えの関係をつくる
									A_Supports[1][3 + N + putting + Jig].Length++;
									break;
								}
								else
								{
									supportflug = 0;
								}
							}
						}
						oya_hoji = A_Jigus[Jig].Jnum;
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == hazusu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					if (M_pattern[movetype].Move[Te][nowmove][destination] == KOUGU || M_pattern[movetype].Move[Te][nowmove][destination] == ChangeKOUGU)
					{
						if (M_pattern[movetype].Move[Te][nowmove][destination] == ChangeKOUGU)
						{
							TempKougunum = ChangeKougunum;
						}
						else
						{
							TempKougunum = Kougunum;
						}

						Remove(fp2, A_Objects[0][3 * N + 2 + TempKougunum + putting + Jigu].Id, use_parts, Te);//外す remove
						//Remove(fp2, Jigbangou, TyuPa, Te);//外す remove
						//治具と親部品の支えの関係を切る
						//A_Supports[1][3 + N + putting + Jig].PId = 0;

						for (supportlength = 0; supportlength < A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length; supportlength++)
						{
							temp[supportlength] = 0;//配列の初期化
							temp[supportlength] = A_Supports[1][N + 3 + putting + Jigu + TempKougunum].PId[supportlength];//値を移す
							A_Supports[1][N + 3 + putting + Jigu + TempKougunum].PId[supportlength] = 0;//配列の初期化
						}
						templength = 0;
						templength = A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length;
						A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length = 0;//一旦0にする
						for (k = 0; k < templength; k++)
						{
							if (temp[k] != use_parts)
							{
								A_Supports[1][N + 3 + putting + Jigu + TempKougunum].PId[A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length] = temp[k];
								A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length++;
							}
						}
						if (A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length == 0)
						{
							A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Flag = 0;
						}
					}
					else
					{
						Remove(fp2, Jigbangou, use_parts, Te);//外す remove
						//Remove(fp2, Jigbangou, TyuPa, Te);//外す remove
						//治具と親部品の支えの関係を切る
						//A_Supports[1][3 + N + putting + Jig].PId = 0;

						for (supportlength = 0; supportlength < A_Supports[1][3 + N + putting + Jig].Length; supportlength++)
						{
							temp[supportlength] = 0;//配列の初期化
							temp[supportlength] = A_Supports[1][3 + N + putting + Jig].PId[supportlength];//値を移す
							A_Supports[1][3 + N + putting + Jig].PId[supportlength] = 0;//配列の初期化
						}
						templength = 0;
						templength = A_Supports[1][3 + N + putting + Jig].Length;
						A_Supports[1][3 + N + putting + Jig].Length = 0;//一旦0にする
						for (k = 0; k < templength; k++)
						{
							if (temp[k] != use_parts)
							{
								A_Supports[1][3 + N + putting + Jig].PId[A_Supports[1][3 + N + putting + Jig].Length] = temp[k];
								A_Supports[1][3 + N + putting + Jig].Length++;
							}
						}
						if (A_Supports[1][3 + N + putting + Jig].Length == 0)
						{
							A_Supports[1][3 + N + putting + Jig].Flag = 0;
						}
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == hanasu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = -1;//部品を持っている手がないことを記録
					if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)//対象が工具の時は工具を使用していないのでフラグを0に戻す
					{
						Kouguflag = 0;
					}
					Release(fp2, use_parts, Te);//放すrelease
					//Release(fp2, OyaPa, Te);//放すrelease
					//親部品と手の支えの関係を切る
					//A_Supports[0][Te].Flag = 0;
					//A_Supports[0][Te].PId = 0;
					for (supportlength = 0; supportlength < A_Supports[1][Te].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][Te].PId[supportlength];//値を移す
						A_Supports[1][Te].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][Te].Length;
					A_Supports[1][Te].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != use_parts)
						{
							A_Supports[1][Te].PId[A_Supports[1][Te].Length] = temp[k];
							A_Supports[1][Te].Length++;
						}
					}
					if (A_Supports[1][Te].Length == 0)
					{
						A_Supports[1][Te].Flag = 0;
					}

					if (Kouguflag != 0)
					{
						for (supportlength = 0; supportlength < A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length; supportlength++)
						{
							temp[supportlength] = 0;//配列の初期化
							temp[supportlength] = A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId[supportlength];//値を移す
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId[supportlength] = 0;//配列の初期化
						}
						templength = 0;
						templength = A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length;
						A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length = 0;//一旦0にする
						for (k = 0; k < templength; k++)
						{
							if (temp[k] != use_parts)
							{
								A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId[A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length] = temp[k];
								A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length++;
							}
						}
						if (A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length == 0)
						{
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].Flag = 0;
						}
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == motinaosu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					Turn0X = A_Objects[0][use_object].DirX;
					Turn1X = A_Objects[1][use_object].DirX;
					Turn0Y = A_Objects[0][use_object].DirY;
					Turn1Y = A_Objects[1][use_object].DirY;
					Turn0Z = A_Objects[0][use_object].DirZ;
					Turn1Z = A_Objects[1][use_object].DirZ;

					Turn(fp2, use_parts, Turn0X, Turn0Y, Turn0Z, Turn1X, Turn1Y, Turn1Z, Te);//左手で回転させるturn
					if (M_pattern[movetype].Move[Te][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(Turn0X - Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(Turn0Y - Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(Turn0Z - Turn1Z) + Oyakaitenkakudo;
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == kumitateidou)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = Te;//部品を持っている手を記録
					/*IchiX1 = A_Objects[1][KoPnum].IchiX;
					IchiY1 = A_Objects[1][KoPnum].IchiY;
					IchiZ1 = A_Objects[1][KoPnum].IchiZ;*/
					IchiX1 = A_Objects[0][2 * N - 1 + Te].IchiX;
					IchiY1 = A_Objects[0][2 * N - 1 + Te].IchiY;
					IchiZ1 = A_Objects[0][2 * N - 1 + Te].IchiZ;

					if (kumijun[line].scene_type == oya2ko1)
					{
						/*if (Oya2flag == 1 || Oya2flag == 3)
						{
							IchiX2 = KIdo_X1;
							IchiY2 = KIdo_Y1;
							IchiZ2 = KIdo_Z1;
						}
						else if (Oya2flag == 2)
						{
							IchiX2 = KIdo_X;
							IchiY2 = KIdo_Y;
							IchiZ2 = KIdo_Z;
						}*/
						IchiX2 = KIdo_X1;
						IchiY2 = KIdo_Y1;
						IchiZ2 = KIdo_Z1;
					}
					else
					{
						IchiX2 = KIdo_X;
						IchiY2 = KIdo_Y;
						IchiZ2 = KIdo_Z;
					}

					Kumimove(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);//組立移動Kumimove

					A_Objects[0][2 * N - 1 + Te].IchiX = IchiX2;//手の座標を更新
					A_Objects[0][2 * N - 1 + Te].IchiY = IchiY2;
					A_Objects[0][2 * N - 1 + Te].IchiZ = IchiZ2;

					A_Objects[0][use_object].IchiX = IchiX2;//部品の座標を更新
					A_Objects[0][use_object].IchiY = IchiY2;
					A_Objects[0][use_object].IchiZ = IchiZ2;

					A_Objects[1][use_object].IchiX = IchiX2;//部品の座標を更新
					A_Objects[1][use_object].IchiY = IchiY2;
					A_Objects[1][use_object].IchiZ = IchiZ2;

					if ((Kouguflag != 0 && M_pattern[movetype].Move[Te][nowmove][target] == Ko) || M_pattern[movetype].Move[Te][nowmove][target] == KOUGU || M_pattern[movetype].Move[Te][nowmove][target] == ChangeKOUGU)//工具を用いて部品を運ぶ場合は工具の座標も変更
					{
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiX = IchiX2;//部品の座標を更新
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY = IchiY2;
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = IchiZ2;
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == kumitateru)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					//Te = M_pattern[movetype].kobuhin[nowmove][Hand];
					/*if (kumijun[line].scene_type == oya2ko1)
					{
						Kumitate(fp2, A_Supports[0][N + putting + 3 + kumijun[line].jig - 1].Id, kumijun[line].tyukan, kumijun[line].oya, kumijun[line].ko, Te);//右手で組立Kumitate
						Kumitate(fp2, A_Supports[0][N + putting + 3 + kumijun[line + 1].jig - 1].Id, kumijun[line + 1].tyukan, kumijun[line + 1].oya, kumijun[line + 1].ko, Te);//右手で組立Kumitate
					}*/
					if (kumijun[line].kougu != 0)//工具を用いて組立を行う時
					{
						KouguKumi(fp2, Jigbangou, KouguBnum, TyuPa, OyaPa, KoPa);
					}
					else
					{
						Kumitate(fp2, Jigbangou, TyuPa, OyaPa, KoPa, Te);//組立Kumitate
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == sentanhenkou)
			{
				Tipmove(fp2, line, M_pattern[movetype].Move[Te][nowmove][target], Te);
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == hakobu_tsuika)
			{
				IchiX1 = A_Objects[0][2 * N - 1 + Te].IchiX;
				IchiY1 = A_Objects[0][2 * N - 1 + Te].IchiY;
				IchiZ1 = A_Objects[0][2 * N - 1 + Te].IchiZ;
				IchiX2 = A_Objects[1][use_object].IchiX + M_pattern[movetype].Move_addition[Te][nowmove][0];
				IchiY2 = A_Objects[1][use_object].IchiY + M_pattern[movetype].Move_addition[Te][nowmove][1];
				IchiZ2 = A_Objects[1][use_object].IchiZ + M_pattern[movetype].Move_addition[Te][nowmove][2];

				Carry(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);//左手で運ぶ carry

				A_Objects[0][2 * N - 1 + Te].IchiX = IchiX2;//手の座標を更新
				A_Objects[0][2 * N - 1 + Te].IchiY = IchiY2;
				A_Objects[0][2 * N - 1 + Te].IchiZ = IchiZ2;

				A_Objects[0][use_object].IchiX = IchiX2;//部品の座標を更新
				A_Objects[0][use_object].IchiY = IchiY2;
				A_Objects[0][use_object].IchiZ = IchiZ2;


				if ((Kouguflag != 0 && M_pattern[movetype].Move[Te][nowmove][target] == Ko) || M_pattern[movetype].Move[Te][nowmove][target] == KOUGU || M_pattern[movetype].Move[Te][nowmove][target] == ChangeKOUGU)//工具を用いて部品を運ぶ場合は工具の座標も変更
				{
					A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiX = IchiX2;//部品の座標を更新
					A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY = IchiY2;
					A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = IchiZ2;
				}

			}
		}
		else if (Te == ryoute)
		{
			//右手の対象を決める
			if (M_pattern[movetype].Move[migite][nowmove][target] == Oya)//対象製品が親部品
			{

				if (Oya2flag == 1)//基準部品が最初の部品の時
				{//2番目の部品が対象の部品になる
					R_use_parts = kumijun[line + 1].oya;
					R_use_object = OyaPnum;
				}
				else if (Oya2flag == 2)//基準部品が2番目の部品の時
				{//最初の部品が対象の部品になる
					R_use_parts = kumijun[line].oya;
					R_use_object = OyaPnum1;
				}
				else
				{
					R_use_parts = OyaPa;
					R_use_object = OyaPnum;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Ko)//対象製品が子部品
			{
				R_use_parts = KoPa;
				R_use_object = KoPnum;
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Tyukan)//対象製品が中間製品
			{
				R_use_parts = TyuPa;
				R_use_object = TyuPnum;
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Start_P)//手を初期位置に戻すとき、対象製品は使用する手
			{
				R_use_object = 2 * N - 1 + migite;
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Ko1)//両手2部品の時の右手で扱う子部品
			{
				R_use_parts = A_Objects[0][R_KoPnum].Id;
				R_use_object = R_KoPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].ko == R_use_parts)
					{
						R_TyuPa = kumijun[i].tyukan;
						R_line = i;
						if (NewNOS0 == 0)
						{
							R_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									R_Jig = k;
									break;
								}

							}
						}

						R_Jigbangou = A_Supports[0][N + putting + 3 + R_Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Oya1)//両手2部品の時の右手で扱う親部品
			{
				R_use_parts = A_Objects[0][R_OyaPnum].Id;
				R_use_object = R_OyaPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].oya == R_use_parts)
					{
						R_TyuPa = kumijun[i].tyukan;
						R_line = i;
						if (NewNOS0 == 0)
						{
							R_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									R_Jig = k;
									break;
								}

							}
						}
						R_Jigbangou = A_Supports[0][N + putting + 3 + R_Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Tyukan1)//両手2部品の時の右手で扱う中間製品部品
			{
				R_use_parts = A_Objects[0][R_TyuPnum].Id;
				R_use_object = R_TyuPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].tyukan == R_use_parts)
					{
						R_TyuPa = kumijun[i].tyukan;
						R_line = i;
						if (NewNOS0 == 0)
						{
							R_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									R_Jig = k;
									break;
								}

							}
						}
						R_Jigbangou = A_Supports[0][N + putting + 3 + R_Jig].Id;
					}
				}
			}

			//左手の対象を決める
			if (M_pattern[movetype].Move[hidarite][nowmove][target] == Oya)//対象製品が親部品
			{
				if (Oya2flag == 1)//基準部品が最初の部品の時
				{//2番目の部品が対象の部品になる
					L_use_parts = kumijun[line + 1].oya;
					L_use_object = OyaPnum;
				}
				else if (Oya2flag == 2)//基準部品が2番目の部品の時
				{//最初の部品が対象の部品になる
					L_use_parts = kumijun[line].oya;
					L_use_object = OyaPnum1;
				}
				else
				{
					L_use_parts = OyaPa;
					L_use_object = OyaPnum;
				}
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Ko)//対象製品が子部品
			{
				L_use_parts = KoPa;
				L_use_object = KoPnum;
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Tyukan)//対象製品が中間製品
			{
				L_use_parts = TyuPa;
				L_use_object = TyuPnum;
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Start_P)//手を初期位置に戻すとき、対象製品は使用する手
			{
				L_use_object = 2 * N - 1 + hidarite;
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Ko2)//両手2部品の時の左手で扱う子部品
			{
				L_use_parts = A_Objects[0][L_KoPnum].Id;
				L_use_object = L_KoPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].ko == L_use_parts)
					{
						L_TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							L_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									L_Jig = k;
									break;
								}

							}
						}
						L_Jigbangou = A_Supports[0][N + putting + 3 + L_Jig].Id;
						L_line = i;
					}
				}
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Oya2)//両手2部品の時の左手で扱う親部品
			{
				L_use_parts = A_Objects[0][L_OyaPnum].Id;
				L_use_object = L_OyaPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].oya == L_use_parts)
					{
						L_TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							L_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									L_Jig = k;
									break;
								}

							}
						}
						L_Jigbangou = A_Supports[0][N + putting + 3 + L_Jig].Id;
						L_line = i;
					}
				}
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Tyukan2)//両手2部品の時の左手で扱う中間製品部品
			{
				L_use_parts = A_Objects[0][L_TyuPnum].Id;
				L_use_object = L_TyuPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].tyukan == L_use_parts)
					{
						L_TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							L_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									L_Jig = k;
									break;
								}

							}
						}
						L_Jigbangou = A_Supports[0][N + putting + 3 + L_Jig].Id;
						L_line = i;
					}
				}
			}

			if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[hidarite][nowmove][move]) == nobasu)//右手と左手が同じ動作で伸ばすの時
			{
				//右手と左手の部品に回転があるときに必要、もしくは右手と左手にこの動作が指定されているとき
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{//Te = M_pattern[movetype].kobuhin[nowmove][Hand];
				//もともと治具に付いている部品(親部品)に手を伸ばす

					L_IchiX1 = A_Objects[0][2 * N - 1 + hidarite].IchiX;//使用する手の現在の位置
					L_IchiY1 = A_Objects[0][2 * N - 1 + hidarite].IchiY;
					L_IchiZ1 = A_Objects[0][2 * N - 1 + hidarite].IchiZ;
					L_IchiX2 = A_Objects[0][L_use_object].IchiX;
					L_IchiY2 = A_Objects[0][L_use_object].IchiY;
					L_IchiZ2 = A_Objects[0][L_use_object].IchiZ;

					R_IchiX1 = A_Objects[0][2 * N - 1 + migite].IchiX;//使用する手の現在の位置
					R_IchiY1 = A_Objects[0][2 * N - 1 + migite].IchiY;
					R_IchiZ1 = A_Objects[0][2 * N - 1 + migite].IchiZ;
					R_IchiX2 = A_Objects[0][R_use_object].IchiX;
					R_IchiY2 = A_Objects[0][R_use_object].IchiY;
					R_IchiZ2 = A_Objects[0][R_use_object].IchiZ;
					/*IchiX2 = A_Objects[0][OyaPnum].IchiX;
					IchiY2 = A_Objects[0][OyaPnum].IchiY;
					IchiZ2 = A_Objects[0][OyaPnum].IchiZ;*/

					WReach(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					R_IchiX1 = A_Objects[0][2 * N - 1 + migite].IchiX;//使用する手の現在の位置
					R_IchiY1 = A_Objects[0][2 * N - 1 + migite].IchiY;
					R_IchiZ1 = A_Objects[0][2 * N - 1 + migite].IchiZ;
					R_IchiX2 = A_Objects[0][R_use_object].IchiX;
					R_IchiY2 = A_Objects[0][R_use_object].IchiY;
					R_IchiZ2 = A_Objects[0][R_use_object].IchiZ;

					Reach(fp2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2, migite);

					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;

				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					L_IchiX1 = A_Objects[0][2 * N - 1 + hidarite].IchiX;//使用する手の現在の位置
					L_IchiY1 = A_Objects[0][2 * N - 1 + hidarite].IchiY;
					L_IchiZ1 = A_Objects[0][2 * N - 1 + hidarite].IchiZ;
					L_IchiX2 = A_Objects[0][L_use_object].IchiX;
					L_IchiY2 = A_Objects[0][L_use_object].IchiY;
					L_IchiZ2 = A_Objects[0][L_use_object].IchiZ;

					Reach(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, hidarite);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == hakobu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					//Te = M_pattern[movetype].kobuhin[nowmove][Hand];

					L_IchiX1 = A_Objects[0][2 * N - 1 + hidarite].IchiX;
					L_IchiY1 = A_Objects[0][2 * N - 1 + hidarite].IchiY;
					L_IchiZ1 = A_Objects[0][2 * N - 1 + hidarite].IchiZ;
					L_IchiX2 = A_Objects[1][L_use_object].IchiX;
					L_IchiY2 = A_Objects[1][L_use_object].IchiY;
					L_IchiZ2 = A_Objects[1][L_use_object].IchiZ;

					R_IchiX1 = A_Objects[0][2 * N - 1 + migite].IchiX;
					R_IchiY1 = A_Objects[0][2 * N - 1 + migite].IchiY;
					R_IchiZ1 = A_Objects[0][2 * N - 1 + migite].IchiZ;
					R_IchiX2 = A_Objects[1][R_use_object].IchiX;
					R_IchiY2 = A_Objects[1][R_use_object].IchiY;
					R_IchiZ2 = A_Objects[1][R_use_object].IchiZ;
					/*IchiX2 = A_Objects[1][TyuPnum].IchiX;
					IchiY2 = A_Objects[1][TyuPnum].IchiY;
					IchiZ2 = A_Objects[1][TyuPnum].IchiZ;*/

					WCarry(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2);//両手で運ぶ carry

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;

					A_Objects[0][R_use_object].IchiX = R_IchiX2;//部品の座標を更新
					A_Objects[0][R_use_object].IchiY = R_IchiY2;
					A_Objects[0][R_use_object].IchiZ = R_IchiZ2;
					A_Objects[0][L_use_object].IchiX = L_IchiX2;//部品の座標を更新
					A_Objects[0][L_use_object].IchiY = L_IchiY2;
					A_Objects[0][L_use_object].IchiZ = L_IchiZ2;
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					R_IchiX1 = A_Objects[0][2 * N - 1 + migite].IchiX;
					R_IchiY1 = A_Objects[0][2 * N - 1 + migite].IchiY;
					R_IchiZ1 = A_Objects[0][2 * N - 1 + migite].IchiZ;
					R_IchiX2 = A_Objects[1][R_use_object].IchiX;
					R_IchiY2 = A_Objects[1][R_use_object].IchiY;
					R_IchiZ2 = A_Objects[1][R_use_object].IchiZ;

					Carry(fp2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2, migite);

					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;

					A_Objects[0][R_use_object].IchiX = R_IchiX2;//部品の座標を更新
					A_Objects[0][R_use_object].IchiY = R_IchiY2;
					A_Objects[0][R_use_object].IchiZ = R_IchiZ2;

				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					L_IchiX1 = A_Objects[0][2 * N - 1 + hidarite].IchiX;
					L_IchiY1 = A_Objects[0][2 * N - 1 + hidarite].IchiY;
					L_IchiZ1 = A_Objects[0][2 * N - 1 + hidarite].IchiZ;
					L_IchiX2 = A_Objects[1][L_use_object].IchiX;
					L_IchiY2 = A_Objects[1][L_use_object].IchiY;
					L_IchiZ2 = A_Objects[1][L_use_object].IchiZ;

					Carry(fp2, L_IchiX1, L_IchiY1, R_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, hidarite);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					A_Objects[0][L_use_object].IchiX = L_IchiX2;//部品の座標を更新
					A_Objects[0][L_use_object].IchiY = L_IchiY2;
					A_Objects[0][L_use_object].IchiZ = L_IchiZ2;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == kumitateidou)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					hold_hands = migite;//部品を持っている手を記録
					/*IchiX1 = A_Objects[1][KoPnum].IchiX;
					IchiY1 = A_Objects[1][KoPnum].IchiY;
					IchiZ1 = A_Objects[1][KoPnum].IchiZ;*/
					L_IchiX1 = A_Objects[1][L_use_object].IchiX;
					L_IchiY1 = A_Objects[1][L_use_object].IchiY;
					L_IchiZ1 = A_Objects[1][L_use_object].IchiZ;

					R_IchiX1 = A_Objects[1][R_use_object].IchiX;
					R_IchiY1 = A_Objects[1][R_use_object].IchiY;
					R_IchiZ1 = A_Objects[1][R_use_object].IchiZ;

					if (kumijun[line].scene_type == oya1ko2 || kumijun[line].scene_type == oya2ko2)
					{
						if (R_line < L_line)
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
						else
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
					}
					else if (kumijun[line].scene_type == oya2ko1)
					{
						if (Oya2flag == 1)//組立順序の最初の部品が基準部品の場合
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
						else if (Oya2flag == 2 || Oya2flag == 3)
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
					}
					else
					{
						R_IchiX2 = KIdo_X;
						R_IchiY2 = KIdo_Y;
						R_IchiZ2 = KIdo_Z;

						L_IchiX2 = KIdo_X;
						L_IchiY2 = KIdo_Y;
						L_IchiZ2 = KIdo_Z;
					}

					WKumimove(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;

					//部品の座標の更新
					A_Objects[1][L_use_object].IchiX = L_IchiX2;
					A_Objects[1][L_use_object].IchiY = L_IchiX2;
					A_Objects[1][L_use_object].IchiZ = L_IchiX2;

					A_Objects[1][R_use_object].IchiX = R_IchiX2;
					A_Objects[1][R_use_object].IchiY = R_IchiY2;
					A_Objects[1][R_use_object].IchiZ = R_IchiZ2;
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					R_IchiX1 = A_Objects[1][R_use_object].IchiX;
					R_IchiY1 = A_Objects[1][R_use_object].IchiY;
					R_IchiZ1 = A_Objects[1][R_use_object].IchiZ;

					if (kumijun[line].scene_type == oya1ko2 || kumijun[line].scene_type == oya2ko2)
					{
						if (R_line < L_line)
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
						else
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
					}
					else if (kumijun[line].scene_type == oya2ko1)
					{
						if (Oya2flag == 1)//組立順序の最初の部品が基準部品の場合
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
						else if (Oya2flag == 2 || Oya2flag == 3)
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
					}
					else
					{
						R_IchiX2 = KIdo_X;
						R_IchiY2 = KIdo_Y;
						R_IchiZ2 = KIdo_Z;

						L_IchiX2 = KIdo_X;
						L_IchiY2 = KIdo_Y;
						L_IchiZ2 = KIdo_Z;
					}

					Kumimove(fp2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2, migite);

					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;
					A_Objects[1][R_use_object].IchiX = R_IchiX2;//部品の座標の更新
					A_Objects[1][R_use_object].IchiY = R_IchiY2;
					A_Objects[1][R_use_object].IchiZ = R_IchiZ2;
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					L_IchiX1 = A_Objects[1][L_use_object].IchiX;
					L_IchiY1 = A_Objects[1][L_use_object].IchiY;
					L_IchiZ1 = A_Objects[1][L_use_object].IchiZ;

					if (kumijun[line].scene_type == oya1ko2 || kumijun[line].scene_type == oya2ko2)
					{
						if (R_line < L_line)
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
						else
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
					}
					else if (kumijun[line].scene_type == oya2ko1)
					{
						if (Oya2flag == 1)//組立順序の最初の部品が基準部品の場合
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
						else if (Oya2flag == 2 || Oya2flag == 3)
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
					}
					else
					{
						R_IchiX2 = KIdo_X;
						R_IchiY2 = KIdo_Y;
						R_IchiZ2 = KIdo_Z;

						L_IchiX2 = KIdo_X;
						L_IchiY2 = KIdo_Y;
						L_IchiZ2 = KIdo_Z;
					}

					Kumimove(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, hidarite);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					//部品の座標の更新
					A_Objects[1][L_use_object].IchiX = L_IchiX2;
					A_Objects[1][L_use_object].IchiY = L_IchiX2;
					A_Objects[1][L_use_object].IchiZ = L_IchiX2;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == tsukeru)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					WFix(fp2, L_Jigbangou, R_Jigbangou, L_use_parts, R_use_parts);//付ける fix

					//治具と親部品の支えの関係をつくる
					A_Supports[1][3 + N + putting + R_Jig].Id = A_Jigus[R_Jig].Jnum;
					A_Supports[1][3 + N + putting + R_Jig].Flag = 1;

					A_Supports[1][3 + N + putting + L_Jig].Id = A_Jigus[L_Jig].Jnum;
					A_Supports[1][3 + N + putting + L_Jig].Flag = 1;

					for (k = 0; k < A_Supports[1][3 + N + putting + R_Jig].Length; k++)//治具と親部品の支えの関係をつくる(右手)
					{
						//A_Supports[0][Te].PId = use_parts;
						if (A_Supports[1][3 + N + putting + R_Jig].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
						{
							supportflug = 1;
							break;
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][3 + N + putting + R_Jig].PId[A_Supports[1][3 + N + putting + R_Jig].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + R_Jig].Length++;
							break;
						}
						else
						{
							supportflug = 0;
						}
					}

					for (k = 0; k < A_Supports[1][3 + N + putting + L_Jig].Length; k++)//治具と親部品の支えの関係をつくる(左手)
					{
						//A_Supports[0][Te].PId = use_parts;
						if (A_Supports[1][3 + N + putting + L_Jig].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
						{
							supportflug = 1;
							break;
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][3 + N + putting + L_Jig].PId[A_Supports[1][3 + N + putting + L_Jig].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + L_Jig].Length++;
							break;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					Fix(fp2, R_Jigbangou, R_use_parts, migite);//付ける fix

					//治具と親部品の支えの関係をつくる
					A_Supports[1][3 + N + putting + R_Jig].Id = A_Jigus[R_Jig].Jnum;
					A_Supports[1][3 + N + putting + R_Jig].Flag = 1;
					for (k = 0; k < A_Supports[1][3 + N + putting + R_Jig].Length; k++)//治具と親部品の支えの関係をつくる(右手)
					{
						//A_Supports[0][Te].PId = use_parts;
						if (A_Supports[1][3 + N + putting + R_Jig].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
						{
							supportflug = 1;
							break;
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][3 + N + putting + R_Jig].PId[A_Supports[1][3 + N + putting + R_Jig].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + R_Jig].Length++;
							break;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					Fix(fp2, L_Jigbangou, L_use_parts, hidarite);//付ける fix
					A_Supports[1][3 + N + putting + L_Jig].Id = A_Jigus[L_Jig].Jnum;
					A_Supports[1][3 + N + putting + L_Jig].Flag = 1;
					for (k = 0; k < A_Supports[1][3 + N + putting + L_Jig].Length; k++)//治具と親部品の支えの関係をつくる(左手)
					{
						//A_Supports[0][Te].PId = use_parts;
						if (A_Supports[1][3 + N + putting + L_Jig].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
						{
							supportflug = 1;
							break;
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][3 + N + putting + L_Jig].PId[A_Supports[1][3 + N + putting + L_Jig].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + L_Jig].Length++;
							break;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == tsukamu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					WGripping(fp2, L_use_parts, R_use_parts);//掴む
					//Gripping(fp2, TyuPa, Te);//掴む

					if (A_Supports[1][hidarite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][hidarite].Flag = 1;
						A_Supports[1][hidarite].PId[0] = L_use_parts;
						A_Supports[1][hidarite].Length++;
					}
					else
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;
						A_Supports[1][hidarite].Flag = 1;
						for (k = 0; k < A_Supports[1][hidarite].Length; k++)
						{
							//A_Supports[0][hidarite].PId = use_parts;
							if (A_Supports[1][hidarite].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][hidarite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

					if (A_Supports[1][migite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][migite].Flag = 1;
						A_Supports[1][migite].PId[0] = R_use_parts;
						A_Supports[1][migite].Length++;
					}
					else
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;
						A_Supports[1][migite].Flag = 1;
						for (k = 0; k < A_Supports[1][migite].Length; k++)
						{
							//A_Supports[0][migite].PId = use_parts;
							if (A_Supports[1][migite].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][migite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					Gripping(fp2, R_use_parts, migite);
					if (A_Supports[1][migite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][migite].Flag = 1;
						A_Supports[1][migite].PId[0] = R_use_parts;
						A_Supports[1][migite].Length++;
					}
					else
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;
						A_Supports[1][migite].Flag = 1;
						for (k = 0; k < A_Supports[1][migite].Length; k++)
						{
							//A_Supports[0][migite].PId = use_parts;
							if (A_Supports[1][migite].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][migite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					Gripping(fp2, L_use_parts, hidarite);
					if (A_Supports[1][hidarite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][hidarite].Flag = 1;
						A_Supports[1][hidarite].PId[0] = L_use_parts;
						A_Supports[1][hidarite].Length++;
					}
					else
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;
						A_Supports[1][hidarite].Flag = 1;
						for (k = 0; k < A_Supports[1][hidarite].Length; k++)
						{
							//A_Supports[0][hidarite].PId = use_parts;
							if (A_Supports[1][hidarite].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][hidarite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == tsukamitoru)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					//右側の部品に関して
					if (JigKobuhin == R_use_parts || JigKobuhin2 == R_use_parts || ChangeJig == R_use_parts || ChangeJig2 == R_use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == R_use_parts)
								{
									BeforeJigR = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					//左側の部品に関して
					if (JigKobuhin == L_use_parts || JigKobuhin2 == L_use_parts || ChangeJig == L_use_parts || ChangeJig2 == L_use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == L_use_parts)
								{
									BeforeJigL = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					for (i = 0; i < Bboxnum; i++)
					{
						for (k = 0; k < A_Supports[1][i + 2].Length; k++)
						{
							if (A_Supports[1][i + 2].PId[k] == L_use_parts || A_Supports[1][i + 2].PId[k] == R_use_parts) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
							   //A_Supports[1][i + 2].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i + 2].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i + 2].Length;
								A_Supports[1][i + 2].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if ((temp[supportlength] != L_use_parts && A_Supports[1][i + 2].PId[k] == L_use_parts) ||
										(temp[supportlength] != R_use_parts && A_Supports[1][i + 2].PId[k] == R_use_parts))//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i + 2].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i + 2].Length == 0)
								{
									A_Supports[1][i + 2].Flag = 0;
								}
								break;
							}
						}
					}
					for (i = 0; i < putting; i++)
					{//中間製品置き場からとるとき、支えの関係を切る
						//if (A_Supports[0][3 + N + i].PId == OyaPa)
						/*if (A_Supports[0][3 + N + i].PId == use_parts)
						{
							A_Supports[1][3 + N + i].Flag = 0;
							A_Supports[1][3 + N + i].PId = 0;
						}*/
						for (k = 0; k < A_Supports[1][3 + N + i].Length; k++)
						{
							if (A_Supports[1][3 + N + i].PId[k] == L_use_parts || A_Supports[1][3 + N + i].PId[k] == R_use_parts)//右手で扱う部品か左手で扱う部品の時
							{
								//A_Supports[1][3 + N + i].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][3 + N + i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][3 + N + i].Length;
								A_Supports[1][3 + N + i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if ((temp[supportlength] != L_use_parts && A_Supports[1][3 + N + i].PId[k] == L_use_parts) ||
										(temp[supportlength] != R_use_parts && A_Supports[1][3 + N + i].PId[k] == R_use_parts))//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = temp[supportlength];//データの移行
										A_Supports[1][3 + N + i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][3 + N + i].Length == 0)
								{
									A_Supports[1][3 + N + i].Flag = 0;
								}
								break;
							}
						}
					}

					if (A_Supports[1][hidarite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][hidarite].Flag = 1;
						A_Supports[1][hidarite].PId[0] = L_use_parts;
						A_Supports[1][hidarite].Length++;
					}
					else
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;
						A_Supports[1][hidarite].Flag = 1;
						for (k = 0; k < A_Supports[1][hidarite].Length; k++)
						{
							//A_Supports[0][hidarite].PId = use_parts;
							if (A_Supports[1][hidarite].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][hidarite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

					if (A_Supports[1][migite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][migite].Flag = 1;
						A_Supports[1][migite].PId[0] = R_use_parts;
						A_Supports[1][migite].Length++;
					}
					else
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;
						A_Supports[1][migite].Flag = 1;
						for (k = 0; k < A_Supports[1][migite].Length; k++)
						{
							//A_Supports[0][migite].PId = use_parts;
							if (A_Supports[1][migite].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][migite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

					WGrip(fp2, L_use_parts, R_use_parts, BeforeJigL, BeforeJigR);
					BeforeJigL = BeforeJigR = 0;
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					if (JigKobuhin == R_use_parts || JigKobuhin2 == R_use_parts || ChangeJig == R_use_parts || ChangeJig2 == R_use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == R_use_parts)
								{
									BeforeJigR = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					for (i = 0; i < Bboxnum; i++)
					{
						for (k = 0; k < A_Supports[1][i + 2].Length; k++)
						{
							if (A_Supports[1][i + 2].PId[k] == R_use_parts) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
							   //A_Supports[1][i + 2].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i + 2].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i + 2].Length;
								A_Supports[1][i + 2].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != R_use_parts && A_Supports[1][i + 2].PId[k] == R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i + 2].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i + 2].Length == 0)
								{
									A_Supports[1][i + 2].Flag = 0;
								}
								break;
							}
						}
					}
					for (i = 0; i < putting; i++)
					{//中間製品置き場からとるとき、支えの関係を切る
						//if (A_Supports[0][3 + N + i].PId == OyaPa)
						/*if (A_Supports[0][3 + N + i].PId == use_parts)
						{
							A_Supports[1][3 + N + i].Flag = 0;
							A_Supports[1][3 + N + i].PId = 0;
						}*/
						for (k = 0; k < A_Supports[1][3 + N + i].Length; k++)
						{
							if (A_Supports[1][3 + N + i].PId[k] == R_use_parts)//右手で扱う部品か左手で扱う部品の時
							{
								//A_Supports[1][3 + N + i].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][3 + N + i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][3 + N + i].Length;
								A_Supports[1][3 + N + i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != R_use_parts && A_Supports[1][3 + N + i].PId[k] == R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = temp[supportlength];//データの移行
										A_Supports[1][3 + N + i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][3 + N + i].Length == 0)
								{
									A_Supports[1][3 + N + i].Flag = 0;
								}
								break;
							}
						}
					}
					if (A_Supports[1][migite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][migite].Flag = 1;
						A_Supports[1][migite].PId[0] = use_parts;
						A_Supports[1][migite].Length++;
					}
					else
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;
						A_Supports[1][migite].Flag = 1;
						for (k = 0; k < A_Supports[1][migite].Length; k++)
						{
							//A_Supports[0][migite].PId = use_parts;
							if (A_Supports[1][migite].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][migite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
					Grip(fp2, R_use_parts, BeforeJigR, migite);
					BeforeJigR = 0;
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					if (JigKobuhin == L_use_parts || JigKobuhin2 == L_use_parts || ChangeJig == L_use_parts || ChangeJig2 == L_use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == L_use_parts)
								{
									BeforeJigL = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					for (i = 0; i < Bboxnum; i++)
					{
						for (k = 0; k < A_Supports[1][i + 2].Length; k++)
						{
							if (A_Supports[1][i + 2].PId[k] == L_use_parts) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
							   //A_Supports[1][i + 2].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i + 2].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i + 2].Length;
								A_Supports[1][i + 2].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != L_use_parts && A_Supports[1][i + 2].PId[k] == L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i + 2].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i + 2].Length == 0)
								{
									A_Supports[1][i + 2].Flag = 0;
								}
								break;
							}
						}
					}
					for (i = 0; i < putting; i++)
					{//中間製品置き場からとるとき、支えの関係を切る
						//if (A_Supports[0][3 + N + i].PId == OyaPa)
						/*if (A_Supports[0][3 + N + i].PId == use_parts)
						{
							A_Supports[1][3 + N + i].Flag = 0;
							A_Supports[1][3 + N + i].PId = 0;
						}*/
						for (k = 0; k < A_Supports[1][3 + N + i].Length; k++)
						{
							if (A_Supports[1][3 + N + i].PId[k] == L_use_parts)//右手で扱う部品か左手で扱う部品の時
							{
								//A_Supports[1][3 + N + i].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][3 + N + i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][3 + N + i].Length;
								A_Supports[1][3 + N + i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != L_use_parts && A_Supports[1][3 + N + i].PId[k] == L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = temp[supportlength];//データの移行
										A_Supports[1][3 + N + i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][3 + N + i].Length == 0)
								{
									A_Supports[1][3 + N + i].Flag = 0;
								}
								break;
							}
						}
					}

					if (A_Supports[1][hidarite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][hidarite].Flag = 1;
						A_Supports[1][hidarite].PId[0] = use_parts;
						A_Supports[1][hidarite].Length++;
					}
					else
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;
						A_Supports[1][hidarite].Flag = 1;
						for (k = 0; k < A_Supports[1][hidarite].Length; k++)
						{
							//A_Supports[0][hidarite].PId = use_parts;
							if (A_Supports[1][hidarite].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][hidarite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

					Grip(fp2, L_use_parts, BeforeJigL, hidarite);
					BeforeJigL = 0;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == okihanasu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					Wleave(fp2, L_use_parts, R_use_parts);//置き放す leave
					//leave(fp2, TyuPa, Te);//置き放す leave

					for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
					{//左手、右手、冶具の支えの関係を切る
						//if (A_Supports[1][i].PId == TyuPa)
						f = A_Supports[1][i].Length;//支えている数を保存
						for (k = 0; k < f; k++)
						{
							/*if (A_Supports[1][i].PId == use_parts)
							{
								A_Supports[1][i].Flag = 0;
								A_Supports[1][i].PId = 0;
							}*/
							if (A_Supports[1][i].PId[k] == L_use_parts || A_Supports[1][i].PId[k] == R_use_parts)//組立後に部品を支えていてはいけないのでA_Supports[1][i].PId
							{
								for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i].Length;
								A_Supports[1][i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if ((temp[supportlength] != L_use_parts && A_Supports[1][3 + N + i].PId[k] == L_use_parts) ||
										(temp[supportlength] != R_use_parts && A_Supports[1][3 + N + i].PId[k] == R_use_parts))//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i].PId[A_Supports[1][i].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i].Length == 0)
								{
									A_Supports[1][i].Flag = 0;
								}
								break;
							}
						}

						if (i == Tnum - 1 + N + 3)
						{//中間製品置き場と中間製品の支えの関係を作る
							A_Supports[1][i].Flag = 1;
							//A_Supports[1][i].PId = use_parts;
							//A_Supports[1][i].PId = TyuPa;
							for (k = 0; k < A_Supports[1][i].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][i].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = supportflug + 1;//左手で扱う部品を持っている時は＋1する
								}
								else if (A_Supports[1][i].PId[k] == R_use_parts)
								{
									supportflug = supportflug + 2;//右手で扱う部品を持っている時は＋2する
								}
							}
							if (supportflug == 0)//まだ支えられていない時
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = L_use_parts;//中間製品置き場と左手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;

								A_Supports[1][i].PId[A_Supports[1][i].Length] = R_use_parts;//中間製品置き場と右手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else if (supportflug == 1)//左手で扱う部品がすでに支えられているとき(一応の作業)
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = R_use_parts;//中間製品置き場と中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else if (supportflug == 2)//右手で扱う部品がすでに支えられているとき(一応の作業)
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = L_use_parts;//中間製品置き場と左手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else
							{
								supportflug = 0;
							}
						}
					}

				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					leave(fp2, R_use_parts, migite);
					for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
					{//右手、冶具の支えの関係を切る
						//if (A_Supports[1][i].PId == TyuPa)
						f = A_Supports[1][i].Length;//支えている数を保存
						for (k = 0; k < f; k++)
						{
							/*if (A_Supports[1][i].PId == use_parts)
							{
								A_Supports[1][i].Flag = 0;
								A_Supports[1][i].PId = 0;
							}*/
							if (A_Supports[1][i].PId[k] == R_use_parts)//組立後に部品を支えていてはいけないのでA_Supports[1][i].PId
							{
								for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i].Length;
								A_Supports[1][i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != R_use_parts && A_Supports[1][3 + N + i].PId[k] == R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i].PId[A_Supports[1][i].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i].Length == 0)
								{
									A_Supports[1][i].Flag = 0;
								}
								break;
							}
						}

						if (i == Tnum - 1 + N + 3)
						{//中間製品置き場と中間製品の支えの関係を作る
							A_Supports[1][i].Flag = 1;
							//A_Supports[1][i].PId = use_parts;
							//A_Supports[1][i].PId = TyuPa;
							for (k = 0; k < A_Supports[1][i].Length; k++)
							{
								if (A_Supports[1][i].PId[k] == R_use_parts)
								{
									supportflug = supportflug + 2;//右手で扱う部品を持っている時は＋2する
								}
							}
							if (supportflug == 0)//まだ支えられていない時
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = R_use_parts;//中間製品置き場と右手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else
							{
								supportflug = 0;
							}
						}
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					leave(fp2, L_use_parts, hidarite);
					for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
					{//左手、右手、冶具の支えの関係を切る
						//if (A_Supports[1][i].PId == TyuPa)
						f = A_Supports[1][i].Length;//支えている数を保存
						for (k = 0; k < f; k++)
						{
							/*if (A_Supports[1][i].PId == use_parts)
							{
								A_Supports[1][i].Flag = 0;
								A_Supports[1][i].PId = 0;
							}*/
							if (A_Supports[1][i].PId[k] == L_use_parts)//組立後に部品を支えていてはいけないのでA_Supports[1][i].PId
							{
								for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i].Length;
								A_Supports[1][i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != L_use_parts && A_Supports[1][3 + N + i].PId[k] == L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i].PId[A_Supports[1][i].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i].Length == 0)
								{
									A_Supports[1][i].Flag = 0;
								}
								break;
							}
						}

						if (i == Tnum - 1 + N + 3)
						{//中間製品置き場と中間製品の支えの関係を作る
							A_Supports[1][i].Flag = 1;
							//A_Supports[1][i].PId = use_parts;
							//A_Supports[1][i].PId = TyuPa;
							for (k = 0; k < A_Supports[1][i].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][i].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = supportflug + 1;//左手で扱う部品を持っている時は＋1する
								}
							}
							if (supportflug == 0)//まだ支えられていない時
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = L_use_parts;//中間製品置き場と左手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else
							{
								supportflug = 0;
							}
						}
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == hanasu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					WRelease(fp2, L_use_parts, R_use_parts);//両手で放すrelease

					for (supportlength = 0; supportlength < A_Supports[1][hidarite].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][hidarite].PId[supportlength];//値を移す
						A_Supports[1][hidarite].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][hidarite].Length;
					A_Supports[1][hidarite].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != L_use_parts)
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = temp[k];
							A_Supports[1][hidarite].Length++;
						}
					}
					if (A_Supports[1][hidarite].Length == 0)
					{
						A_Supports[1][hidarite].Flag = 0;
					}

					for (supportlength = 0; supportlength < A_Supports[1][migite].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][migite].PId[supportlength];//値を移す
						A_Supports[1][migite].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][migite].Length;
					A_Supports[1][migite].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != use_parts)
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = temp[k];
							A_Supports[1][migite].Length++;
						}
					}
					if (A_Supports[1][migite].Length == 0)
					{
						A_Supports[1][migite].Flag = 0;
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					Release(fp2, R_use_parts, migite);//右手で放すrelease
					for (supportlength = 0; supportlength < A_Supports[1][migite].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][migite].PId[supportlength];//値を移す
						A_Supports[1][migite].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][migite].Length;
					A_Supports[1][migite].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != use_parts)
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = temp[k];
							A_Supports[1][migite].Length++;
						}
					}
					if (A_Supports[1][migite].Length == 0)
					{
						A_Supports[1][migite].Flag = 0;
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					Release(fp2, L_use_parts, hidarite);//左手で放すrelease
					for (supportlength = 0; supportlength < A_Supports[1][hidarite].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][hidarite].PId[supportlength];//値を移す
						A_Supports[1][hidarite].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][hidarite].Length;
					A_Supports[1][hidarite].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != L_use_parts)
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = temp[k];
							A_Supports[1][hidarite].Length++;
						}
					}
					if (A_Supports[1][hidarite].Length == 0)
					{
						A_Supports[1][hidarite].Flag = 0;
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == kumitateru)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					oya_hoji = A_Jigus[Jig].Jnum;
					if (R_line < L_line)
					{
						Kumitate(fp2, A_Supports[1][N + putting + 3 + R_Jig].Id, TyuPa, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
						Kumitate(fp2, A_Supports[1][N + putting + 3 + L_Jig].Id, TyuPa2, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
					}
					else
					{
						Kumitate(fp2, A_Supports[1][N + putting + 3 + L_Jig].Id, TyuPa, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
						Kumitate(fp2, A_Supports[1][N + putting + 3 + R_Jig].Id, TyuPa2, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					oya_hoji = A_Jigus[Jig].Jnum;
					if (R_line < L_line)
					{
						Kumitate(fp2, A_Supports[1][N + putting + 3 + R_Jig].Id, TyuPa, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[L_line].jig - 1].Id, TyuPa2, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
					}
					else
					{
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[L_line].jig - 1].Id, TyuPa, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
						Kumitate(fp2, A_Supports[1][N + putting + 3 + R_Jig].Id, TyuPa2, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
					}

				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					oya_hoji = A_Jigus[Jig].Jnum;
					if (R_line < L_line)
					{
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[R_line].jig - 1].Id, TyuPa, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
						Kumitate(fp2, A_Supports[1][N + putting + 3 + L_Jig].Id, TyuPa2, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
					}
					else
					{
						Kumitate(fp2, A_Supports[1][N + putting + 3 + L_Jig].Id, TyuPa, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[R_line].jig - 1].Id, TyuPa2, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == motinaosu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					L_Turn0X = A_Objects[0][L_use_object].DirX;
					L_Turn1X = A_Objects[1][L_use_object].DirX;
					L_Turn0Y = A_Objects[0][L_use_object].DirY;
					L_Turn1Y = A_Objects[1][L_use_object].DirY;
					L_Turn0Z = A_Objects[0][L_use_object].DirZ;
					L_Turn1Z = A_Objects[1][L_use_object].DirZ;

					R_Turn0X = A_Objects[0][R_use_object].DirX;
					R_Turn1X = A_Objects[1][R_use_object].DirX;
					R_Turn0Y = A_Objects[0][R_use_object].DirY;
					R_Turn1Y = A_Objects[1][R_use_object].DirY;
					R_Turn0Z = A_Objects[0][R_use_object].DirZ;
					R_Turn1Z = A_Objects[1][R_use_object].DirZ;

					WTurn(fp2, L_use_parts, L_Turn0X, L_Turn0Y, L_Turn0Z, L_Turn1X, L_Turn1Y, L_Turn1Z, R_use_parts, R_Turn0X, R_Turn0Y, R_Turn0Z, R_Turn1X, R_Turn1Y, R_Turn1Z);//左手で回転させるturn
					if (M_pattern[movetype].Move[migite][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(R_Turn0X - R_Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(R_Turn0Y - R_Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(R_Turn0Z - R_Turn1Z) + Oyakaitenkakudo;
					}
					if (M_pattern[movetype].Move[hidarite][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(L_Turn0X - L_Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(L_Turn0Y - L_Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(L_Turn0Z - L_Turn1Z) + Oyakaitenkakudo;
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					R_Turn0X = A_Objects[0][R_use_object].DirX;
					R_Turn1X = A_Objects[1][R_use_object].DirX;
					R_Turn0Y = A_Objects[0][R_use_object].DirY;
					R_Turn1Y = A_Objects[1][R_use_object].DirY;
					R_Turn0Z = A_Objects[0][R_use_object].DirZ;
					R_Turn1Z = A_Objects[1][R_use_object].DirZ;

					Turn(fp2, R_use_parts, R_Turn0X, R_Turn0Y, R_Turn0Z, R_Turn1X, R_Turn1Y, R_Turn1Z, migite);//回転させるturn
					if (M_pattern[movetype].Move[migite][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(R_Turn0X - R_Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(R_Turn0Y - R_Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(R_Turn0Z - R_Turn1Z) + Oyakaitenkakudo;
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					L_Turn0X = A_Objects[0][L_use_object].DirX;
					L_Turn1X = A_Objects[1][L_use_object].DirX;
					L_Turn0Y = A_Objects[0][L_use_object].DirY;
					L_Turn1Y = A_Objects[1][L_use_object].DirY;
					L_Turn0Z = A_Objects[0][L_use_object].DirZ;
					L_Turn1Z = A_Objects[1][L_use_object].DirZ;
					Turn(fp2, L_use_parts, L_Turn0X, L_Turn0Y, L_Turn0Z, L_Turn1X, L_Turn1Y, L_Turn1Z, hidarite);
					if (M_pattern[movetype].Move[hidarite][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(L_Turn0X - L_Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(L_Turn0Y - L_Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(L_Turn0Z - L_Turn1Z) + Oyakaitenkakudo;
					}
				}
			}
		}
	}

	for (i = 0; i < 2; i++)
	{
		//手の最終座標を合わせる
		A_Objects[1][2 * N - 1 + i].IchiX = A_Objects[0][2 * N - 1 + i].IchiX;
		A_Objects[1][2 * N - 1 + i].IchiY = A_Objects[0][2 * N - 1 + i].IchiY;
		A_Objects[1][2 * N - 1 + i].IchiZ = A_Objects[0][2 * N - 1 + i].IchiZ;
	}
	if (kumijun[line].kougu != 0)//工具を用いる時
	{
		A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiX = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiX;//工具の座標を更新
		A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiY = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY;
		A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY;
	}
}

void kumitatego_to_kumitatemae(FILE* fp2, int line, int movetype)
{
	int i = 0, R_length = 0, L_length = 0, length = 0, /*movetype = 0,*/ Te = 0, nowmove = 0, Jig = 0;
	int OyaPa, KoPa, TyuPa, Jigbangou = 0;//親部品番号,子部品番号,中間製品
	double IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Turn0X, Turn0Y, Turn0Z, Turn1X, Turn1Y, Turn1Z;
	int Oyanum = 0;//親部品が何番目にあるか
	int use_parts = 0/*使用する部品番号*/, use_object = 0/*使用する部品がobjectでどこにあるか*/;
	int R_use_parts = 0/*右手で使用する部品番号*/, R_use_object = 0;/*右手で使用する部品がobjectでどこにあるか*/
	int L_use_parts = 0/*左手で使用する部品番号*/, L_use_object = 0;/*左手で使用する部品がobjectでどこにあるか*/
	double R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2, R_Turn0X, R_Turn0Y, R_Turn0Z, R_Turn1X, R_Turn1Y, R_Turn1Z;
	double L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, L_Turn0X, L_Turn0Y, L_Turn0Z, L_Turn1X, L_Turn1Y, L_Turn1Z;
	int temp[MaxSupport], templength = 0;

	int R_Jig = 0, L_Jig = 0, R_Jigbangou = 0, L_Jigbangou = 0, R_TyuPa = 0, L_TyuPa = 0, TyuPa2 = 0, R_line = 0/*両手の時右手の組付けが一行目か二行目かどうかを保管*/, L_line = 0/*両手の時右手の組付けが一行目か二行目かどうかを保管*/;
	int supportlength = 0, k = 0, supportflug = 0, f = 0;
	int KouguBnum = 0, Kougunum = 0, KouguPnum = 0;//KouguBnum：レイアウト情報での工具の番号、Kougunum：工具番号,KouguPnum：工具がobjectsでどこにあるか
	int ChangeKouguBnum = 0, ChangeKougunum = 0, ChangeKouguPnum = 0;//ChangeKouguBnum：レイアウト情報での交換する工具の番号、ChangeKougunum：交換する工具番号,ChangeKouguPnum：交換する工具がobjectsでどこにあるか
	int TempKougunum = 0;
	int BeforeJig = 0;
	int BeforeJigR = 0, BeforeJigL = 0;

	TyuPa2 = kumijun[line + 1].tyukan;

	R_length = M_pattern[movetype].length[migite];
	L_length = M_pattern[movetype].length[hidarite];
	KoPa = kumijun[line].ko;
	OyaPa = kumijun[line].oya;
	TyuPa = kumijun[line].tyukan;
	if (NewNOS0 == 0)
	{
		
		Jig = kumijun[line].jig - 1;
		Kougunum = kumijun[line].kougu - 1;
		ChangeKougunum = kumijun[line - 1].kougu - 1;
	}
	else
	{
		
		for (i = 0; i < Jigu; i++)
		{
			if (A_Objects[0][3 * N + 2 + i + putting].Id == kumijun[line].jig)
			{
				Jig = i;
				break;
			}
		}
		for (i = 0; i < Kougu; i++)
		{
			if (A_Objects[0][3 * N + 2 + i + putting + Jigu].Id == kumijun[line].kougu)
			{
				Kougunum = i;
				break;
			}
		}
		for (i = 0; i < Kougu; i++)
		{
			if (A_Objects[0][3 * N + 2 + i + putting + Jigu].Id == kumijun[line - 1].kougu)
			{
				ChangeKougunum = i;
				break;
			}
		}
	}
	Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
	//Kougunum = kumijun[line].kougu;
	KouguBnum = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].Id;
	//ChangeKougunum = kumijun[line-1].kougu;
	ChangeKouguBnum = A_Objects[0][3 * N + 2 + ChangeKougunum + putting + Jigu].Id;

	if (R_length > L_length)
	{
		length = R_length;
	}
	else
	{
		length = L_length;
	}

	for (nowmove = 0; nowmove <= length; nowmove++)
	{
		if (M_pattern[movetype].Move[migite][nowmove][move] != none && M_pattern[movetype].Move[hidarite][nowmove][move] != none)//右手左手両方に同時に動作がある時
		{
			Te = ryoute;
		}
		else if (M_pattern[movetype].Move[migite][nowmove][move] != none)//右手に作業がある時
		{
			Te = migite;
		}
		else if (M_pattern[movetype].Move[hidarite][nowmove][move] != none)//左手に動作がある時
		{
			Te = hidarite;
		}

		//どの部品を対象とするかを調べる
		if (Te == migite || Te == hidarite)//両手で同時に作業をしない時
		{
			if (M_pattern[movetype].Move[Te][nowmove][target] == Oya)//対象製品が親部品
			{
				if (Oya2flag == 1)//基準部品が最初の部品の時
				{//2番目の部品が対象の部品になる
					use_parts = kumijun[line + 1].oya;
					use_object = OyaPnum;
				}
				else if (Oya2flag == 2)//基準部品が2番目の部品の時
				{//最初の部品が対象の部品になる
					use_parts = kumijun[line].oya;
					use_object = OyaPnum1;
				}
				else
				{
					use_parts = OyaPa;
					if (kumijun[line].scene_type == oya1ko2)
					{
						use_object = OyaPnum1;
					}
					else
					{
						use_object = OyaPnum;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Ko)//対象製品が子部品
			{
				use_parts = KoPa;
				use_object = KoPnum;
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Tyukan)//対象製品が中間製品
			{
				use_parts = TyuPa;
				use_object = TyuPnum;
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Start_P)//手を初期位置に戻すとき、対象製品は使用する手
			{
				use_object = 2 * N - 1 + Te;
			}

			else if (M_pattern[movetype].Move[Te][nowmove][target] == Ko1)//両手2部品の時の右手で扱う子部品
			{
				use_parts = A_Objects[0][R_KoPnum].Id;
				use_object = R_KoPnum;
				if (Oya2flag == 2)
				{
					use_object = KoPnum1;
				}
				else if (Oya2flag == 1)
				{
					use_object = KoPnum1;
				}
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].ko == R_use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						OyaPa = kumijun[i].oya;
						KoPa = kumijun[i].ko;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Oya1)//両手2部品の時の右手で扱う親部品
			{
				use_parts = A_Objects[0][R_OyaPnum].Id;
				use_object = R_OyaPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].oya == R_use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Tyukan1)//両手2部品の時の右手で扱う中間製品部品
			{
				use_parts = A_Objects[0][R_TyuPnum].Id;
				use_object = R_TyuPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].tyukan == use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Ko2)//両手2部品の時の左手で扱う子部品
			{
				use_parts = A_Objects[0][L_KoPnum].Id;
				use_object = L_KoPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].ko == use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						OyaPa = kumijun[i].oya;
						KoPa = kumijun[i].ko;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[line].jig - 1;
						}
						else
						{
							for (i = 0; i < Jigu; i++)
							{
								if (A_Objects[0][3 * N + 2 + i + putting].Id == kumijun[line].jig)
								{
									Jig = i;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Oya2)//両手2部品の時の左手で扱う親部品
			{
				use_parts = A_Objects[0][L_OyaPnum].Id;
				use_object = L_OyaPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].oya == use_parts)
					{
						OyaPa = kumijun[i].oya;
						KoPa = kumijun[line].ko;
						TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Tyukan2)//両手2部品の時の左手で扱う中間製品部品
			{
				use_parts = A_Objects[0][L_TyuPnum].Id;
				use_object = L_TyuPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].tyukan == L_use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)
			{
				use_parts = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].Id;
				use_object = 3 * N + 2 + Kougunum + putting + Jigu;
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == ChangeKOUGU)
			{
				use_parts = A_Objects[0][3 * N + 2 + ChangeKougunum + putting + Jigu].Id;
				use_object = 3 * N + 2 + ChangeKougunum + putting + Jigu;
			}

			if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == nobasu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{//Te = M_pattern[movetype].kobuhin[nowmove][Hand];
				//もともと治具に付いている部品(親部品)に手を伸ばす
					IchiX1 = A_Objects[0][2 * N - 1 + Te].IchiX;//使用する手の現在の位置
					IchiY1 = A_Objects[0][2 * N - 1 + Te].IchiY;
					IchiZ1 = A_Objects[0][2 * N - 1 + Te].IchiZ;
					if (M_pattern[movetype].Move[Te][nowmove][target] == Start_P)
					{
						IchiX2 = A_Objects[1][use_object].IchiX;
						IchiY2 = A_Objects[1][use_object].IchiY;
						IchiZ2 = A_Objects[1][use_object].IchiZ;
					}
					else
					{
						IchiX2 = A_Objects[0][use_object].IchiX;
						IchiY2 = A_Objects[0][use_object].IchiY;
						IchiZ2 = A_Objects[0][use_object].IchiZ;
					}
					/*IchiX2 = A_Objects[0][OyaPnum].IchiX;
					IchiY2 = A_Objects[0][OyaPnum].IchiY;
					IchiZ2 = A_Objects[0][OyaPnum].IchiZ;*/

					Reach(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);

					A_Objects[0][2 * N - 1 + Te].IchiX = IchiX2;//手の座標を更新
					A_Objects[0][2 * N - 1 + Te].IchiY = IchiY2;
					A_Objects[0][2 * N - 1 + Te].IchiZ = IchiZ2;
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == tsukamu)
			{
				
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					
					hold_hands = Te;//部品を持っている手を記録
					if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)//対象が工具の時は工具を使用していることを記録しておく
					{
						Kouguflag = KouguBnum;
					}
					Gripping(fp2, use_parts, Te);//掴む
					//Gripping(fp2, TyuPa, Te);//掴む
					if (A_Supports[1][Te].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][Te].Id = A_Hands[Te].Hnum;//部品と手の支えの関係をつくる
						A_Supports[1][Te].Flag = 1;
						A_Supports[1][Te].PId[0] = use_parts;
						A_Supports[1][Te].Length++;
					}
					else
					{
						A_Supports[1][Te].Id = A_Hands[Te].Hnum;
						A_Supports[1][Te].Flag = 1;
						for (k = 0; k < A_Supports[1][Te].Length; k++)
						{
							//A_Supports[0][Te].PId = use_parts;
							if (A_Supports[1][Te].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}
						
						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][Te].PId[A_Supports[1][Te].Length] = use_parts;//部品と手の支えの関係をつくる
							A_Supports[1][Te].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
					//A_Supports[1][Te].PId = TyuPa;
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == tsukamitoru)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = Te;//部品を持っている手を記録
					if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)//対象が工具の時は工具を使用していることを記録しておく
					{
						Kouguflag = KouguBnum;
					}

					if (JigKobuhin == use_parts || JigKobuhin2 == use_parts || ChangeJig == use_parts || ChangeJig2 == use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == use_parts)
								{
									BeforeJig = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					//部品箱の支えの関係を切る
					for (i = 0; i < Bboxnum; i++)
					{
						for (k = 0; k < A_Supports[1][i + 2].Length; k++)
						{
							if (A_Supports[1][i + 2].PId[k] == use_parts) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
							   //A_Supports[1][i + 2].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i + 2].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i + 2].Length;
								A_Supports[1][i + 2].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i + 2].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i + 2].Length == 0)
								{
									A_Supports[1][i + 2].Flag = 0;
								}
								break;
							}
						}
					}
					for (i = 0; i < putting; i++)
					{//中間製品置き場からとるとき、支えの関係を切る
						//if (A_Supports[0][3 + N + i].PId == OyaPa)
						/*if (A_Supports[0][3 + N + i].PId == use_parts)
						{
							A_Supports[1][3 + N + i].Flag = 0;
							A_Supports[1][3 + N + i].PId = 0;
						}*/
						for (k = 0; k < A_Supports[1][3 + N + i].Length; k++)
						{
							if (A_Supports[1][3 + N + i].PId[k] == use_parts) {//A_Supports[][0],A_Supports[][1]には
							   //A_Supports[1][3 + N + i].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][3 + N + i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][3 + N + i].Length;
								A_Supports[1][3 + N + i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = temp[supportlength];//データの移行
										A_Supports[1][3 + N + i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][3 + N + i].Length == 0)
								{
									A_Supports[1][3 + N + i].Flag = 0;
								}
								break;
							}
						}
					}

					if (A_Supports[1][Te].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][Te].Id = A_Hands[Te].Hnum;//部品と手の支えの関係をつくる
						A_Supports[1][Te].Flag = 1;
						A_Supports[1][Te].PId[0] = use_parts;
						A_Supports[1][Te].Length++;
					}
					else
					{
						A_Supports[1][Te].Id = A_Hands[Te].Hnum;
						A_Supports[1][Te].Flag = 1;
						for (k = 0; k < A_Supports[1][Te].Length; k++)
						{
							//A_Supports[0][Te].PId = use_parts;
							if (A_Supports[1][Te].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][Te].PId[A_Supports[1][Te].Length] = use_parts;//部品と手の支えの関係をつくる
							A_Supports[1][Te].Length++;
						}
						else
						{
							supportflug = 0;
						}

					}
					//A_Supports[0][Te].PId = OyaPa;

					Grip(fp2, use_parts, BeforeJig, Te);//掴み取る grip
					//Grip(fp2, OyaPa, Te);//掴み取る grip
					BeforeJig = 0;
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == hakobu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					//Te = M_pattern[movetype].kobuhin[nowmove][Hand];

					IchiX1 = A_Objects[0][2 * N - 1 + Te].IchiX;
					IchiY1 = A_Objects[0][2 * N - 1 + Te].IchiY;
					IchiZ1 = A_Objects[0][2 * N - 1 + Te].IchiZ;
					IchiX2 = A_Objects[1][use_object].IchiX;
					IchiY2 = A_Objects[1][use_object].IchiY;
					IchiZ2 = A_Objects[1][use_object].IchiZ;
					/*IchiX2 = A_Objects[1][TyuPnum].IchiX;
					IchiY2 = A_Objects[1][TyuPnum].IchiY;
					IchiZ2 = A_Objects[1][TyuPnum].IchiZ;*/

					Carry(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);//左手で運ぶ carry

					A_Objects[0][2 * N - 1 + Te].IchiX = IchiX2;//手の座標を更新
					A_Objects[0][2 * N - 1 + Te].IchiY = IchiY2;
					A_Objects[0][2 * N - 1 + Te].IchiZ = IchiZ2;

					A_Objects[0][use_object].IchiX = IchiX2;//部品の座標を更新
					A_Objects[0][use_object].IchiY = IchiY2;
					A_Objects[0][use_object].IchiZ = IchiZ2;

					if ((Kouguflag != 0 && M_pattern[movetype].Move[Te][nowmove][target] == Ko) || M_pattern[movetype].Move[Te][nowmove][target] == KOUGU || M_pattern[movetype].Move[Te][nowmove][target] == ChangeKOUGU)//工具を用いて部品を運ぶ場合は工具の座標も変更
					{
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiX = IchiX2;//工具の座標を更新
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY = IchiY2;
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = IchiZ2;
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == okihanasu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = -1;//部品を持っている手がないことを記録
					if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)//対象が工具の時は工具を使用していないのでフラグを0に戻す
					{
						Kouguflag = 0;
					}

					for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
					{//左手、右手、冶具の支えの関係を切る
						//if (A_Supports[1][i].PId == TyuPa)
						f = A_Supports[1][i].Length;//支えている数を保存
						for (k = 0; k < f; k++)
						{
							/*if (A_Supports[1][i].PId == use_parts)
							{
								A_Supports[1][i].Flag = 0;
								A_Supports[1][i].PId = 0;
							}*/
							if (A_Supports[1][i].PId[k] == use_parts)//組立後に部品を支えていてはいけないのでA_Supports[1][i].PId
							{
								for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i].Length;
								A_Supports[1][i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != use_parts)//一致する部品は支えない部品なのでカウントしない
									{
										A_Supports[1][i].PId[A_Supports[1][i].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i].Length == 0)
								{
									A_Supports[1][i].Flag = 0;
								}
								break;
							}
						}

						if (i == Tnum - 1 + N + 3)
						{//中間製品置き場と中間製品の支えの関係を作る
							A_Supports[1][i].Flag = 1;
							//A_Supports[1][i].PId = use_parts;
							//A_Supports[1][i].PId = TyuPa;
							for (k = 0; k < A_Supports[1][i].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][i].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = 1;
									break;
								}
							}
							if (supportflug == 0)//まだ支えられていない時
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = use_parts;//親部品と手の支えの関係をつくる
								A_Supports[1][i].Length++;
							}
							else
							{
								supportflug = 0;
							}
						}
					}

					leave(fp2, use_parts, Te);//置き放す leave
					//leave(fp2, TyuPa, Te);//置き放す leave
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == tsukeru)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = Te;//部品を持っている手を記録

					if (M_pattern[movetype].Move[Te][nowmove][destination] == KOUGU)//付ける対象が工具の時は工具に付ける
					{
						Fix(fp2, KouguBnum, use_parts, Te);//付ける fix
						//Fix(fp2, Jigbangou, OyaPa, Te);//付ける fix

						//工具と親部品の支えの関係をつくる
						A_Supports[1][N + 3 + putting + Jigu + Kougunum].Id = A_Kougus[Kougunum].Bnum;
						A_Supports[1][N + 3 + putting + Jigu + Kougunum].Flag = 1;

						if (A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length == 0)
						{
							A_Supports[1][N + 3 + putting + Jigu + Kougunum].PId[A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length] = use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length++;
						}
						else
						{
							for (k = 0; k < A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][N + 3 + putting + Jigu + Kougunum].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = 1;
									break;
								}

								if (supportflug == 0)//まだ支えられていない時
								{
									A_Supports[1][N + 3 + putting + Jigu + Kougunum].PId[A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length] = use_parts;//親部品と手の支えの関係をつくる
									A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length++;
									break;
								}
								else
								{
									supportflug = 0;
								}
							}
						}
					}
					else
					{
						Fix(fp2, Jigbangou, use_parts, Te);//付ける fix
					   //Fix(fp2, Jigbangou, OyaPa, Te);//付ける fix

					   //治具と親部品の支えの関係をつくる
						A_Supports[1][3 + N + putting + Jig].Id = A_Jigus[Jig].Jnum;
						A_Supports[1][3 + N + putting + Jig].Flag = 1;
						//A_Supports[1][3 + N + putting + Jig].PId = use_parts;
						//A_Supports[1][3 + N + putting + Jig].PId = OyaPa;
						//printf("--------------------%d\n", A_Supports[1][3 + N + putting + Jig].Length);
						if (A_Supports[1][3 + N + putting + Jig].Length == 0)
						{
							A_Supports[1][3 + N + putting + Jig].PId[A_Supports[1][3 + N + putting + Jig].Length] = use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + Jig].Length++;
						}
						else
						{
							for (k = 0; k < A_Supports[1][3 + N + putting + Jig].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][3 + N + putting + Jig].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = 1;
									break;
								}

								if (supportflug == 0)//まだ支えられていない時
								{
									A_Supports[1][3 + N + putting + Jig].PId[A_Supports[1][3 + N + putting + Jig].Length] = use_parts;//親部品と手の支えの関係をつくる
									A_Supports[1][3 + N + putting + Jig].Length++;
									break;
								}
								else
								{
									supportflug = 0;
								}
							}
						}
						oya_hoji = A_Jigus[Jig].Jnum;
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == hazusu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					if (M_pattern[movetype].Move[Te][nowmove][destination] == KOUGU || M_pattern[movetype].Move[Te][nowmove][destination] == ChangeKOUGU)
					{
						if (M_pattern[movetype].Move[Te][nowmove][destination] == ChangeKOUGU)
						{
							TempKougunum = ChangeKougunum;
						}
						else
						{
							TempKougunum = Kougunum;
						}

						Remove(fp2, A_Objects[0][3 * N + 2 + TempKougunum + putting + Jigu].Id, use_parts, Te);//外す remove
						//Remove(fp2, Jigbangou, TyuPa, Te);//外す remove
						//治具と親部品の支えの関係を切る
						//A_Supports[1][3 + N + putting + Jig].PId = 0;

						for (supportlength = 0; supportlength < A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length; supportlength++)
						{
							temp[supportlength] = 0;//配列の初期化
							temp[supportlength] = A_Supports[1][N + 3 + putting + Jigu + TempKougunum].PId[supportlength];//値を移す
							A_Supports[1][N + 3 + putting + Jigu + TempKougunum].PId[supportlength] = 0;//配列の初期化
						}
						templength = 0;
						templength = A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length;
						A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length = 0;//一旦0にする
						for (k = 0; k < templength; k++)
						{
							if (temp[k] != use_parts)
							{
								A_Supports[1][N + 3 + putting + Jigu + TempKougunum].PId[A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length] = temp[k];
								A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length++;
							}
						}
						if (A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length == 0)
						{
							A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Flag = 0;
						}
					}
					else
					{
						Remove(fp2, Jigbangou, use_parts, Te);//外す remove
						//Remove(fp2, Jigbangou, TyuPa, Te);//外す remove
						//治具と親部品の支えの関係を切る
						//A_Supports[1][3 + N + putting + Jig].PId = 0;

						for (supportlength = 0; supportlength < A_Supports[1][3 + N + putting + Jig].Length; supportlength++)
						{
							temp[supportlength] = 0;//配列の初期化
							temp[supportlength] = A_Supports[1][3 + N + putting + Jig].PId[supportlength];//値を移す
							A_Supports[1][3 + N + putting + Jig].PId[supportlength] = 0;//配列の初期化
						}
						templength = 0;
						templength = A_Supports[1][3 + N + putting + Jig].Length;
						A_Supports[1][3 + N + putting + Jig].Length = 0;//一旦0にする
						for (k = 0; k < templength; k++)
						{
							if (temp[k] != use_parts)
							{
								A_Supports[1][3 + N + putting + Jig].PId[A_Supports[1][3 + N + putting + Jig].Length] = temp[k];
								A_Supports[1][3 + N + putting + Jig].Length++;
							}
						}
						if (A_Supports[1][3 + N + putting + Jig].Length == 0)
						{
							A_Supports[1][3 + N + putting + Jig].Flag = 0;
						}
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == hanasu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = -1;//部品を持っている手がないことを記録
					if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)//対象が工具の時は工具を使用していないのでフラグを0に戻す
					{
						Kouguflag = 0;
					}
					Release(fp2, use_parts, Te);//放すrelease
					//Release(fp2, OyaPa, Te);//放すrelease
					//親部品と手の支えの関係を切る
					//A_Supports[0][Te].Flag = 0;
					//A_Supports[0][Te].PId = 0;
					for (supportlength = 0; supportlength < A_Supports[1][Te].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][Te].PId[supportlength];//値を移す
						A_Supports[1][Te].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][Te].Length;
					A_Supports[1][Te].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != use_parts)
						{
							A_Supports[1][Te].PId[A_Supports[1][Te].Length] = temp[k];
							A_Supports[1][Te].Length++;
						}
					}
					if (A_Supports[1][Te].Length == 0)
					{
						A_Supports[1][Te].Flag = 0;
					}

					if (Kouguflag != 0)
					{
						for (supportlength = 0; supportlength < A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length; supportlength++)
						{
							temp[supportlength] = 0;//配列の初期化
							temp[supportlength] = A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId[supportlength];//値を移す
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId[supportlength] = 0;//配列の初期化
						}
						templength = 0;
						templength = A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length;
						A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length = 0;//一旦0にする
						for (k = 0; k < templength; k++)
						{
							if (temp[k] != use_parts)
							{
								A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId[A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length] = temp[k];
								A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length++;
							}
						}
						if (A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length == 0)
						{
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].Flag = 0;
						}
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == motinaosu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					Turn0X = A_Objects[0][use_object].DirX;
					Turn1X = A_Objects[1][use_object].DirX;
					Turn0Y = A_Objects[0][use_object].DirY;
					Turn1Y = A_Objects[1][use_object].DirY;
					Turn0Z = A_Objects[0][use_object].DirZ;
					Turn1Z = A_Objects[1][use_object].DirZ;

					Turn(fp2, use_parts, Turn0X, Turn0Y, Turn0Z, Turn1X, Turn1Y, Turn1Z, Te);//左手で回転させるturn
					if (M_pattern[movetype].Move[Te][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(Turn0X - Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(Turn0Y - Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(Turn0Z - Turn1Z) + Oyakaitenkakudo;
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == kumitateidou)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = Te;//部品を持っている手を記録
					/*IchiX1 = A_Objects[1][KoPnum].IchiX;
					IchiY1 = A_Objects[1][KoPnum].IchiY;
					IchiZ1 = A_Objects[1][KoPnum].IchiZ;*/
					IchiX1 = A_Objects[0][2 * N - 1 + Te].IchiX;
					IchiY1 = A_Objects[0][2 * N - 1 + Te].IchiY;
					IchiZ1 = A_Objects[0][2 * N - 1 + Te].IchiZ;

					if (kumijun[line].scene_type == oya2ko1)
					{
						/*if (Oya2flag == 1 || Oya2flag == 3)
						{
							IchiX2 = KIdo_X1;
							IchiY2 = KIdo_Y1;
							IchiZ2 = KIdo_Z1;
						}
						else if (Oya2flag == 2)
						{
							IchiX2 = KIdo_X;
							IchiY2 = KIdo_Y;
							IchiZ2 = KIdo_Z;
						}*/
						IchiX2 = KIdo_X1;
						IchiY2 = KIdo_Y1;
						IchiZ2 = KIdo_Z1;
					}
					else
					{
						IchiX2 = KIdo_X;
						IchiY2 = KIdo_Y;
						IchiZ2 = KIdo_Z;
					}

					Kumimove(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);//組立移動Kumimove

					A_Objects[0][2 * N - 1 + Te].IchiX = IchiX2;//手の座標を更新
					A_Objects[0][2 * N - 1 + Te].IchiY = IchiY2;
					A_Objects[0][2 * N - 1 + Te].IchiZ = IchiZ2;

					A_Objects[0][use_object].IchiX = IchiX2;//部品の座標を更新
					A_Objects[0][use_object].IchiY = IchiY2;
					A_Objects[0][use_object].IchiZ = IchiZ2;

					A_Objects[1][use_object].IchiX = IchiX2;//部品の座標を更新
					A_Objects[1][use_object].IchiY = IchiY2;
					A_Objects[1][use_object].IchiZ = IchiZ2;

					if ((Kouguflag != 0 && M_pattern[movetype].Move[Te][nowmove][target] == Ko) || M_pattern[movetype].Move[Te][nowmove][target] == KOUGU || M_pattern[movetype].Move[Te][nowmove][target] == ChangeKOUGU)//工具を用いて部品を運ぶ場合は工具の座標も変更
					{
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiX = IchiX2;//部品の座標を更新
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY = IchiY2;
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = IchiZ2;
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == kumitateru)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					//Te = M_pattern[movetype].kobuhin[nowmove][Hand];
					/*if (kumijun[line].scene_type == oya2ko1)
					{
						Kumitate(fp2, A_Supports[0][N + putting + 3 + kumijun[line].jig - 1].Id, kumijun[line].tyukan, kumijun[line].oya, kumijun[line].ko, Te);//右手で組立Kumitate
						Kumitate(fp2, A_Supports[0][N + putting + 3 + kumijun[line + 1].jig - 1].Id, kumijun[line + 1].tyukan, kumijun[line + 1].oya, kumijun[line + 1].ko, Te);//右手で組立Kumitate
					}*/
					if (kumijun[line].kougu != 0)//工具を用いて組立を行う時
					{
						KouguKumi(fp2, Jigbangou, KouguBnum, TyuPa, OyaPa, KoPa);
					}
					else
					{
						Kumitate(fp2, Jigbangou, TyuPa, OyaPa, KoPa, Te);//組立Kumitate
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == sentanhenkou)
			{
				Tipmove(fp2, line, M_pattern[movetype].Move[Te][nowmove][target], Te);
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == hakobu_tsuika)
			{
				IchiX1 = A_Objects[0][2 * N - 1 + Te].IchiX;
				IchiY1 = A_Objects[0][2 * N - 1 + Te].IchiY;
				IchiZ1 = A_Objects[0][2 * N - 1 + Te].IchiZ;
				IchiX2 = A_Objects[1][use_object].IchiX + M_pattern[movetype].Move_addition[Te][nowmove][0];
				IchiY2 = A_Objects[1][use_object].IchiY + M_pattern[movetype].Move_addition[Te][nowmove][1];
				IchiZ2 = A_Objects[1][use_object].IchiZ + M_pattern[movetype].Move_addition[Te][nowmove][2];

				Carry(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);//左手で運ぶ carry

				A_Objects[0][2 * N - 1 + Te].IchiX = IchiX2;//手の座標を更新
				A_Objects[0][2 * N - 1 + Te].IchiY = IchiY2;
				A_Objects[0][2 * N - 1 + Te].IchiZ = IchiZ2;

				A_Objects[0][use_object].IchiX = IchiX2;//部品の座標を更新
				A_Objects[0][use_object].IchiY = IchiY2;
				A_Objects[0][use_object].IchiZ = IchiZ2;


				if ((Kouguflag != 0 && M_pattern[movetype].Move[Te][nowmove][target] == Ko) || M_pattern[movetype].Move[Te][nowmove][target] == KOUGU || M_pattern[movetype].Move[Te][nowmove][target] == ChangeKOUGU)//工具を用いて部品を運ぶ場合は工具の座標も変更
				{
					A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiX = IchiX2;//部品の座標を更新
					A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY = IchiY2;
					A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = IchiZ2;
				}

			}
		}
		else if (Te == ryoute)
		{
			//右手の対象を決める
			if (M_pattern[movetype].Move[migite][nowmove][target] == Oya)//対象製品が親部品
			{

				if (Oya2flag == 1)//基準部品が最初の部品の時
				{//2番目の部品が対象の部品になる
					R_use_parts = kumijun[line + 1].oya;
					R_use_object = OyaPnum;
				}
				else if (Oya2flag == 2)//基準部品が2番目の部品の時
				{//最初の部品が対象の部品になる
					R_use_parts = kumijun[line].oya;
					R_use_object = OyaPnum1;
				}
				else
				{
					R_use_parts = OyaPa;
					R_use_object = OyaPnum;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Ko)//対象製品が子部品
			{
				R_use_parts = KoPa;
				R_use_object = KoPnum;
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Tyukan)//対象製品が中間製品
			{
				R_use_parts = TyuPa;
				R_use_object = TyuPnum;
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Start_P)//手を初期位置に戻すとき、対象製品は使用する手
			{
				R_use_object = 2 * N - 1 + migite;
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Ko1)//両手2部品の時の右手で扱う子部品
			{
				R_use_parts = A_Objects[0][R_KoPnum].Id;
				R_use_object = R_KoPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].ko == R_use_parts)
					{
						R_TyuPa = kumijun[i].tyukan;
						R_line = i;
						if (NewNOS0 == 0)
						{
							R_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									R_Jig = k;
									break;
								}

							}
						}

						R_Jigbangou = A_Supports[0][N + putting + 3 + R_Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Oya1)//両手2部品の時の右手で扱う親部品
			{
				R_use_parts = A_Objects[0][R_OyaPnum].Id;
				R_use_object = R_OyaPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].oya == R_use_parts)
					{
						R_TyuPa = kumijun[i].tyukan;
						R_line = i;
						if (NewNOS0 == 0)
						{
							R_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									R_Jig = k;
									break;
								}

							}
						}
						R_Jigbangou = A_Supports[0][N + putting + 3 + R_Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Tyukan1)//両手2部品の時の右手で扱う中間製品部品
			{
				R_use_parts = A_Objects[0][R_TyuPnum].Id;
				R_use_object = R_TyuPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].tyukan == R_use_parts)
					{
						R_TyuPa = kumijun[i].tyukan;
						R_line = i;
						if (NewNOS0 == 0)
						{
							R_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									R_Jig = k;
									break;
								}

							}
						}
						R_Jigbangou = A_Supports[0][N + putting + 3 + R_Jig].Id;
					}
				}
			}

			//左手の対象を決める
			if (M_pattern[movetype].Move[hidarite][nowmove][target] == Oya)//対象製品が親部品
			{
				if (Oya2flag == 1)//基準部品が最初の部品の時
				{//2番目の部品が対象の部品になる
					L_use_parts = kumijun[line + 1].oya;
					L_use_object = OyaPnum;
				}
				else if (Oya2flag == 2)//基準部品が2番目の部品の時
				{//最初の部品が対象の部品になる
					L_use_parts = kumijun[line].oya;
					L_use_object = OyaPnum1;
				}
				else
				{
					L_use_parts = OyaPa;
					L_use_object = OyaPnum;
				}
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Ko)//対象製品が子部品
			{
				L_use_parts = KoPa;
				L_use_object = KoPnum;
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Tyukan)//対象製品が中間製品
			{
				L_use_parts = TyuPa;
				L_use_object = TyuPnum;
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Start_P)//手を初期位置に戻すとき、対象製品は使用する手
			{
				L_use_object = 2 * N - 1 + hidarite;
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Ko2)//両手2部品の時の左手で扱う子部品
			{
				L_use_parts = A_Objects[0][L_KoPnum].Id;
				L_use_object = L_KoPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].ko == L_use_parts)
					{
						L_TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							L_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									L_Jig = k;
									break;
								}

							}
						}
						L_Jigbangou = A_Supports[0][N + putting + 3 + L_Jig].Id;
						L_line = i;
					}
				}
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Oya2)//両手2部品の時の左手で扱う親部品
			{
				L_use_parts = A_Objects[0][L_OyaPnum].Id;
				L_use_object = L_OyaPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].oya == L_use_parts)
					{
						L_TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							L_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									L_Jig = k;
									break;
								}

							}
						}
						L_Jigbangou = A_Supports[0][N + putting + 3 + L_Jig].Id;
						L_line = i;
					}
				}
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Tyukan2)//両手2部品の時の左手で扱う中間製品部品
			{
				L_use_parts = A_Objects[0][L_TyuPnum].Id;
				L_use_object = L_TyuPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].tyukan == L_use_parts)
					{
						L_TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							L_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									L_Jig = k;
									break;
								}

							}
						}
						L_Jigbangou = A_Supports[0][N + putting + 3 + L_Jig].Id;
						L_line = i;
					}
				}
			}

			if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[hidarite][nowmove][move]) == nobasu)//右手と左手が同じ動作で伸ばすの時
			{
				//右手と左手の部品に回転があるときに必要、もしくは右手と左手にこの動作が指定されているとき
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{//Te = M_pattern[movetype].kobuhin[nowmove][Hand];
				//もともと治具に付いている部品(親部品)に手を伸ばす

					L_IchiX1 = A_Objects[0][2 * N - 1 + hidarite].IchiX;//使用する手の現在の位置
					L_IchiY1 = A_Objects[0][2 * N - 1 + hidarite].IchiY;
					L_IchiZ1 = A_Objects[0][2 * N - 1 + hidarite].IchiZ;
					L_IchiX2 = A_Objects[0][L_use_object].IchiX;
					L_IchiY2 = A_Objects[0][L_use_object].IchiY;
					L_IchiZ2 = A_Objects[0][L_use_object].IchiZ;

					R_IchiX1 = A_Objects[0][2 * N - 1 + migite].IchiX;//使用する手の現在の位置
					R_IchiY1 = A_Objects[0][2 * N - 1 + migite].IchiY;
					R_IchiZ1 = A_Objects[0][2 * N - 1 + migite].IchiZ;
					R_IchiX2 = A_Objects[0][R_use_object].IchiX;
					R_IchiY2 = A_Objects[0][R_use_object].IchiY;
					R_IchiZ2 = A_Objects[0][R_use_object].IchiZ;
					/*IchiX2 = A_Objects[0][OyaPnum].IchiX;
					IchiY2 = A_Objects[0][OyaPnum].IchiY;
					IchiZ2 = A_Objects[0][OyaPnum].IchiZ;*/

					WReach(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					R_IchiX1 = A_Objects[0][2 * N - 1 + migite].IchiX;//使用する手の現在の位置
					R_IchiY1 = A_Objects[0][2 * N - 1 + migite].IchiY;
					R_IchiZ1 = A_Objects[0][2 * N - 1 + migite].IchiZ;
					R_IchiX2 = A_Objects[0][R_use_object].IchiX;
					R_IchiY2 = A_Objects[0][R_use_object].IchiY;
					R_IchiZ2 = A_Objects[0][R_use_object].IchiZ;

					Reach(fp2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2, migite);

					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;

				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					L_IchiX1 = A_Objects[0][2 * N - 1 + hidarite].IchiX;//使用する手の現在の位置
					L_IchiY1 = A_Objects[0][2 * N - 1 + hidarite].IchiY;
					L_IchiZ1 = A_Objects[0][2 * N - 1 + hidarite].IchiZ;
					L_IchiX2 = A_Objects[0][L_use_object].IchiX;
					L_IchiY2 = A_Objects[0][L_use_object].IchiY;
					L_IchiZ2 = A_Objects[0][L_use_object].IchiZ;

					Reach(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, hidarite);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == hakobu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					//Te = M_pattern[movetype].kobuhin[nowmove][Hand];

					L_IchiX1 = A_Objects[0][2 * N - 1 + hidarite].IchiX;
					L_IchiY1 = A_Objects[0][2 * N - 1 + hidarite].IchiY;
					L_IchiZ1 = A_Objects[0][2 * N - 1 + hidarite].IchiZ;
					L_IchiX2 = A_Objects[1][L_use_object].IchiX;
					L_IchiY2 = A_Objects[1][L_use_object].IchiY;
					L_IchiZ2 = A_Objects[1][L_use_object].IchiZ;

					R_IchiX1 = A_Objects[0][2 * N - 1 + migite].IchiX;
					R_IchiY1 = A_Objects[0][2 * N - 1 + migite].IchiY;
					R_IchiZ1 = A_Objects[0][2 * N - 1 + migite].IchiZ;
					R_IchiX2 = A_Objects[1][R_use_object].IchiX;
					R_IchiY2 = A_Objects[1][R_use_object].IchiY;
					R_IchiZ2 = A_Objects[1][R_use_object].IchiZ;
					/*IchiX2 = A_Objects[1][TyuPnum].IchiX;
					IchiY2 = A_Objects[1][TyuPnum].IchiY;
					IchiZ2 = A_Objects[1][TyuPnum].IchiZ;*/

					WCarry(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2);//両手で運ぶ carry

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;

					A_Objects[0][R_use_object].IchiX = R_IchiX2;//部品の座標を更新
					A_Objects[0][R_use_object].IchiY = R_IchiY2;
					A_Objects[0][R_use_object].IchiZ = R_IchiZ2;
					A_Objects[0][L_use_object].IchiX = L_IchiX2;//部品の座標を更新
					A_Objects[0][L_use_object].IchiY = L_IchiY2;
					A_Objects[0][L_use_object].IchiZ = L_IchiZ2;
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					R_IchiX1 = A_Objects[0][2 * N - 1 + migite].IchiX;
					R_IchiY1 = A_Objects[0][2 * N - 1 + migite].IchiY;
					R_IchiZ1 = A_Objects[0][2 * N - 1 + migite].IchiZ;
					R_IchiX2 = A_Objects[1][R_use_object].IchiX;
					R_IchiY2 = A_Objects[1][R_use_object].IchiY;
					R_IchiZ2 = A_Objects[1][R_use_object].IchiZ;

					Carry(fp2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2, migite);

					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;

					A_Objects[0][R_use_object].IchiX = R_IchiX2;//部品の座標を更新
					A_Objects[0][R_use_object].IchiY = R_IchiY2;
					A_Objects[0][R_use_object].IchiZ = R_IchiZ2;

				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					L_IchiX1 = A_Objects[0][2 * N - 1 + hidarite].IchiX;
					L_IchiY1 = A_Objects[0][2 * N - 1 + hidarite].IchiY;
					L_IchiZ1 = A_Objects[0][2 * N - 1 + hidarite].IchiZ;
					L_IchiX2 = A_Objects[1][L_use_object].IchiX;
					L_IchiY2 = A_Objects[1][L_use_object].IchiY;
					L_IchiZ2 = A_Objects[1][L_use_object].IchiZ;

					Carry(fp2, L_IchiX1, L_IchiY1, R_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, hidarite);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					A_Objects[0][L_use_object].IchiX = L_IchiX2;//部品の座標を更新
					A_Objects[0][L_use_object].IchiY = L_IchiY2;
					A_Objects[0][L_use_object].IchiZ = L_IchiZ2;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == kumitateidou)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					hold_hands = migite;//部品を持っている手を記録
					/*IchiX1 = A_Objects[1][KoPnum].IchiX;
					IchiY1 = A_Objects[1][KoPnum].IchiY;
					IchiZ1 = A_Objects[1][KoPnum].IchiZ;*/
					L_IchiX1 = A_Objects[1][L_use_object].IchiX;
					L_IchiY1 = A_Objects[1][L_use_object].IchiY;
					L_IchiZ1 = A_Objects[1][L_use_object].IchiZ;

					R_IchiX1 = A_Objects[1][R_use_object].IchiX;
					R_IchiY1 = A_Objects[1][R_use_object].IchiY;
					R_IchiZ1 = A_Objects[1][R_use_object].IchiZ;

					if (kumijun[line].scene_type == oya1ko2 || kumijun[line].scene_type == oya2ko2)
					{
						if (R_line < L_line)
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
						else
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
					}
					else if (kumijun[line].scene_type == oya2ko1)
					{
						if (Oya2flag == 1)//組立順序の最初の部品が基準部品の場合
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
						else if (Oya2flag == 2 || Oya2flag == 3)
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
					}
					else
					{
						R_IchiX2 = KIdo_X;
						R_IchiY2 = KIdo_Y;
						R_IchiZ2 = KIdo_Z;

						L_IchiX2 = KIdo_X;
						L_IchiY2 = KIdo_Y;
						L_IchiZ2 = KIdo_Z;
					}

					WKumimove(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;

					//部品の座標の更新
					A_Objects[1][L_use_object].IchiX = L_IchiX2;
					A_Objects[1][L_use_object].IchiY = L_IchiX2;
					A_Objects[1][L_use_object].IchiZ = L_IchiX2;

					A_Objects[1][R_use_object].IchiX = R_IchiX2;
					A_Objects[1][R_use_object].IchiY = R_IchiY2;
					A_Objects[1][R_use_object].IchiZ = R_IchiZ2;
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					R_IchiX1 = A_Objects[1][R_use_object].IchiX;
					R_IchiY1 = A_Objects[1][R_use_object].IchiY;
					R_IchiZ1 = A_Objects[1][R_use_object].IchiZ;

					if (kumijun[line].scene_type == oya1ko2 || kumijun[line].scene_type == oya2ko2)
					{
						if (R_line < L_line)
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
						else
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
					}
					else if (kumijun[line].scene_type == oya2ko1)
					{
						if (Oya2flag == 1)//組立順序の最初の部品が基準部品の場合
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
						else if (Oya2flag == 2 || Oya2flag == 3)
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
					}
					else
					{
						R_IchiX2 = KIdo_X;
						R_IchiY2 = KIdo_Y;
						R_IchiZ2 = KIdo_Z;

						L_IchiX2 = KIdo_X;
						L_IchiY2 = KIdo_Y;
						L_IchiZ2 = KIdo_Z;
					}

					Kumimove(fp2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2, migite);

					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;
					A_Objects[1][R_use_object].IchiX = R_IchiX2;//部品の座標の更新
					A_Objects[1][R_use_object].IchiY = R_IchiY2;
					A_Objects[1][R_use_object].IchiZ = R_IchiZ2;
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					L_IchiX1 = A_Objects[1][L_use_object].IchiX;
					L_IchiY1 = A_Objects[1][L_use_object].IchiY;
					L_IchiZ1 = A_Objects[1][L_use_object].IchiZ;

					if (kumijun[line].scene_type == oya1ko2 || kumijun[line].scene_type == oya2ko2)
					{
						if (R_line < L_line)
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
						else
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
					}
					else if (kumijun[line].scene_type == oya2ko1)
					{
						if (Oya2flag == 1)//組立順序の最初の部品が基準部品の場合
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
						else if (Oya2flag == 2 || Oya2flag == 3)
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
					}
					else
					{
						R_IchiX2 = KIdo_X;
						R_IchiY2 = KIdo_Y;
						R_IchiZ2 = KIdo_Z;

						L_IchiX2 = KIdo_X;
						L_IchiY2 = KIdo_Y;
						L_IchiZ2 = KIdo_Z;
					}

					Kumimove(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, hidarite);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					//部品の座標の更新
					A_Objects[1][L_use_object].IchiX = L_IchiX2;
					A_Objects[1][L_use_object].IchiY = L_IchiX2;
					A_Objects[1][L_use_object].IchiZ = L_IchiX2;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == tsukeru)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					WFix(fp2, L_Jigbangou, R_Jigbangou, L_use_parts, R_use_parts);//付ける fix

					//治具と親部品の支えの関係をつくる
					A_Supports[1][3 + N + putting + R_Jig].Id = A_Jigus[R_Jig].Jnum;
					A_Supports[1][3 + N + putting + R_Jig].Flag = 1;

					A_Supports[1][3 + N + putting + L_Jig].Id = A_Jigus[L_Jig].Jnum;
					A_Supports[1][3 + N + putting + L_Jig].Flag = 1;

					for (k = 0; k < A_Supports[1][3 + N + putting + R_Jig].Length; k++)//治具と親部品の支えの関係をつくる(右手)
					{
						//A_Supports[0][Te].PId = use_parts;
						if (A_Supports[1][3 + N + putting + R_Jig].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
						{
							supportflug = 1;
							break;
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][3 + N + putting + R_Jig].PId[A_Supports[1][3 + N + putting + R_Jig].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + R_Jig].Length++;
							break;
						}
						else
						{
							supportflug = 0;
						}
					}

					for (k = 0; k < A_Supports[1][3 + N + putting + L_Jig].Length; k++)//治具と親部品の支えの関係をつくる(左手)
					{
						//A_Supports[0][Te].PId = use_parts;
						if (A_Supports[1][3 + N + putting + L_Jig].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
						{
							supportflug = 1;
							break;
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][3 + N + putting + L_Jig].PId[A_Supports[1][3 + N + putting + L_Jig].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + L_Jig].Length++;
							break;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					Fix(fp2, R_Jigbangou, R_use_parts, migite);//付ける fix

					//治具と親部品の支えの関係をつくる
					A_Supports[1][3 + N + putting + R_Jig].Id = A_Jigus[R_Jig].Jnum;
					A_Supports[1][3 + N + putting + R_Jig].Flag = 1;
					for (k = 0; k < A_Supports[1][3 + N + putting + R_Jig].Length; k++)//治具と親部品の支えの関係をつくる(右手)
					{
						//A_Supports[0][Te].PId = use_parts;
						if (A_Supports[1][3 + N + putting + R_Jig].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
						{
							supportflug = 1;
							break;
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][3 + N + putting + R_Jig].PId[A_Supports[1][3 + N + putting + R_Jig].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + R_Jig].Length++;
							break;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					Fix(fp2, L_Jigbangou, L_use_parts, hidarite);//付ける fix
					A_Supports[1][3 + N + putting + L_Jig].Id = A_Jigus[L_Jig].Jnum;
					A_Supports[1][3 + N + putting + L_Jig].Flag = 1;
					for (k = 0; k < A_Supports[1][3 + N + putting + L_Jig].Length; k++)//治具と親部品の支えの関係をつくる(左手)
					{
						//A_Supports[0][Te].PId = use_parts;
						if (A_Supports[1][3 + N + putting + L_Jig].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
						{
							supportflug = 1;
							break;
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][3 + N + putting + L_Jig].PId[A_Supports[1][3 + N + putting + L_Jig].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + L_Jig].Length++;
							break;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == tsukamu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					WGripping(fp2, L_use_parts, R_use_parts);//掴む
					//Gripping(fp2, TyuPa, Te);//掴む

					if (A_Supports[1][hidarite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][hidarite].Flag = 1;
						A_Supports[1][hidarite].PId[0] = L_use_parts;
						A_Supports[1][hidarite].Length++;
					}
					else
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;
						A_Supports[1][hidarite].Flag = 1;
						for (k = 0; k < A_Supports[1][hidarite].Length; k++)
						{
							//A_Supports[0][hidarite].PId = use_parts;
							if (A_Supports[1][hidarite].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][hidarite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

					if (A_Supports[1][migite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][migite].Flag = 1;
						A_Supports[1][migite].PId[0] = R_use_parts;
						A_Supports[1][migite].Length++;
					}
					else
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;
						A_Supports[1][migite].Flag = 1;
						for (k = 0; k < A_Supports[1][migite].Length; k++)
						{
							//A_Supports[0][migite].PId = use_parts;
							if (A_Supports[1][migite].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][migite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					Gripping(fp2, R_use_parts, migite);
					if (A_Supports[1][migite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][migite].Flag = 1;
						A_Supports[1][migite].PId[0] = R_use_parts;
						A_Supports[1][migite].Length++;
					}
					else
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;
						A_Supports[1][migite].Flag = 1;
						for (k = 0; k < A_Supports[1][migite].Length; k++)
						{
							//A_Supports[0][migite].PId = use_parts;
							if (A_Supports[1][migite].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][migite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					Gripping(fp2, L_use_parts, hidarite);
					if (A_Supports[1][hidarite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][hidarite].Flag = 1;
						A_Supports[1][hidarite].PId[0] = L_use_parts;
						A_Supports[1][hidarite].Length++;
					}
					else
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;
						A_Supports[1][hidarite].Flag = 1;
						for (k = 0; k < A_Supports[1][hidarite].Length; k++)
						{
							//A_Supports[0][hidarite].PId = use_parts;
							if (A_Supports[1][hidarite].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][hidarite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == tsukamitoru)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					//右側の部品に関して
					if (JigKobuhin == R_use_parts || JigKobuhin2 == R_use_parts || ChangeJig == R_use_parts || ChangeJig2 == R_use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == R_use_parts)
								{
									BeforeJigR = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					//左側の部品に関して
					if (JigKobuhin == L_use_parts || JigKobuhin2 == L_use_parts || ChangeJig == L_use_parts || ChangeJig2 == L_use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == L_use_parts)
								{
									BeforeJigL = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					for (i = 0; i < Bboxnum; i++)
					{
						for (k = 0; k < A_Supports[1][i + 2].Length; k++)
						{
							if (A_Supports[1][i + 2].PId[k] == L_use_parts || A_Supports[1][i + 2].PId[k] == R_use_parts) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
							   //A_Supports[1][i + 2].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i + 2].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i + 2].Length;
								A_Supports[1][i + 2].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if ((temp[supportlength] != L_use_parts && A_Supports[1][i + 2].PId[k] == L_use_parts) ||
										(temp[supportlength] != R_use_parts && A_Supports[1][i + 2].PId[k] == R_use_parts))//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i + 2].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i + 2].Length == 0)
								{
									A_Supports[1][i + 2].Flag = 0;
								}
								break;
							}
						}
					}
					for (i = 0; i < putting; i++)
					{//中間製品置き場からとるとき、支えの関係を切る
						//if (A_Supports[0][3 + N + i].PId == OyaPa)
						/*if (A_Supports[0][3 + N + i].PId == use_parts)
						{
							A_Supports[1][3 + N + i].Flag = 0;
							A_Supports[1][3 + N + i].PId = 0;
						}*/
						for (k = 0; k < A_Supports[1][3 + N + i].Length; k++)
						{
							if (A_Supports[1][3 + N + i].PId[k] == L_use_parts || A_Supports[1][3 + N + i].PId[k] == R_use_parts)//右手で扱う部品か左手で扱う部品の時
							{
								//A_Supports[1][3 + N + i].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][3 + N + i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][3 + N + i].Length;
								A_Supports[1][3 + N + i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if ((temp[supportlength] != L_use_parts && A_Supports[1][3 + N + i].PId[k] == L_use_parts) ||
										(temp[supportlength] != R_use_parts && A_Supports[1][3 + N + i].PId[k] == R_use_parts))//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = temp[supportlength];//データの移行
										A_Supports[1][3 + N + i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][3 + N + i].Length == 0)
								{
									A_Supports[1][3 + N + i].Flag = 0;
								}
								break;
							}
						}
					}

					if (A_Supports[1][hidarite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][hidarite].Flag = 1;
						A_Supports[1][hidarite].PId[0] = L_use_parts;
						A_Supports[1][hidarite].Length++;
					}
					else
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;
						A_Supports[1][hidarite].Flag = 1;
						for (k = 0; k < A_Supports[1][hidarite].Length; k++)
						{
							//A_Supports[0][hidarite].PId = use_parts;
							if (A_Supports[1][hidarite].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][hidarite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

					if (A_Supports[1][migite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][migite].Flag = 1;
						A_Supports[1][migite].PId[0] = R_use_parts;
						A_Supports[1][migite].Length++;
					}
					else
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;
						A_Supports[1][migite].Flag = 1;
						for (k = 0; k < A_Supports[1][migite].Length; k++)
						{
							//A_Supports[0][migite].PId = use_parts;
							if (A_Supports[1][migite].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][migite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

					WGrip(fp2, L_use_parts, R_use_parts, BeforeJigL, BeforeJigR);
					BeforeJigL = BeforeJigR = 0;
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					if (JigKobuhin == R_use_parts || JigKobuhin2 == R_use_parts || ChangeJig == R_use_parts || ChangeJig2 == R_use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == R_use_parts)
								{
									BeforeJigR = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					for (i = 0; i < Bboxnum; i++)
					{
						for (k = 0; k < A_Supports[1][i + 2].Length; k++)
						{
							if (A_Supports[1][i + 2].PId[k] == R_use_parts) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
							   //A_Supports[1][i + 2].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i + 2].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i + 2].Length;
								A_Supports[1][i + 2].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != R_use_parts && A_Supports[1][i + 2].PId[k] == R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i + 2].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i + 2].Length == 0)
								{
									A_Supports[1][i + 2].Flag = 0;
								}
								break;
							}
						}
					}
					for (i = 0; i < putting; i++)
					{//中間製品置き場からとるとき、支えの関係を切る
						//if (A_Supports[0][3 + N + i].PId == OyaPa)
						/*if (A_Supports[0][3 + N + i].PId == use_parts)
						{
							A_Supports[1][3 + N + i].Flag = 0;
							A_Supports[1][3 + N + i].PId = 0;
						}*/
						for (k = 0; k < A_Supports[1][3 + N + i].Length; k++)
						{
							if (A_Supports[1][3 + N + i].PId[k] == R_use_parts)//右手で扱う部品か左手で扱う部品の時
							{
								//A_Supports[1][3 + N + i].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][3 + N + i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][3 + N + i].Length;
								A_Supports[1][3 + N + i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != R_use_parts && A_Supports[1][3 + N + i].PId[k] == R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = temp[supportlength];//データの移行
										A_Supports[1][3 + N + i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][3 + N + i].Length == 0)
								{
									A_Supports[1][3 + N + i].Flag = 0;
								}
								break;
							}
						}
					}
					if (A_Supports[1][migite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][migite].Flag = 1;
						A_Supports[1][migite].PId[0] = use_parts;
						A_Supports[1][migite].Length++;
					}
					else
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;
						A_Supports[1][migite].Flag = 1;
						for (k = 0; k < A_Supports[1][migite].Length; k++)
						{
							//A_Supports[0][migite].PId = use_parts;
							if (A_Supports[1][migite].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][migite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
					Grip(fp2, R_use_parts, BeforeJigR, migite);
					BeforeJigR = 0;
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					if (JigKobuhin == L_use_parts || JigKobuhin2 == L_use_parts || ChangeJig == L_use_parts || ChangeJig2 == L_use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == L_use_parts)
								{
									BeforeJigL = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					for (i = 0; i < Bboxnum; i++)
					{
						for (k = 0; k < A_Supports[1][i + 2].Length; k++)
						{
							if (A_Supports[1][i + 2].PId[k] == L_use_parts) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
							   //A_Supports[1][i + 2].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i + 2].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i + 2].Length;
								A_Supports[1][i + 2].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != L_use_parts && A_Supports[1][i + 2].PId[k] == L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i + 2].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i + 2].Length == 0)
								{
									A_Supports[1][i + 2].Flag = 0;
								}
								break;
							}
						}
					}
					for (i = 0; i < putting; i++)
					{//中間製品置き場からとるとき、支えの関係を切る
						//if (A_Supports[0][3 + N + i].PId == OyaPa)
						/*if (A_Supports[0][3 + N + i].PId == use_parts)
						{
							A_Supports[1][3 + N + i].Flag = 0;
							A_Supports[1][3 + N + i].PId = 0;
						}*/
						for (k = 0; k < A_Supports[1][3 + N + i].Length; k++)
						{
							if (A_Supports[1][3 + N + i].PId[k] == L_use_parts)//右手で扱う部品か左手で扱う部品の時
							{
								//A_Supports[1][3 + N + i].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][3 + N + i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][3 + N + i].Length;
								A_Supports[1][3 + N + i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != L_use_parts && A_Supports[1][3 + N + i].PId[k] == L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = temp[supportlength];//データの移行
										A_Supports[1][3 + N + i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][3 + N + i].Length == 0)
								{
									A_Supports[1][3 + N + i].Flag = 0;
								}
								break;
							}
						}
					}

					if (A_Supports[1][hidarite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][hidarite].Flag = 1;
						A_Supports[1][hidarite].PId[0] = use_parts;
						A_Supports[1][hidarite].Length++;
					}
					else
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;
						A_Supports[1][hidarite].Flag = 1;
						for (k = 0; k < A_Supports[1][hidarite].Length; k++)
						{
							//A_Supports[0][hidarite].PId = use_parts;
							if (A_Supports[1][hidarite].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][hidarite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

					Grip(fp2, L_use_parts, BeforeJigL, hidarite);
					BeforeJigL = 0;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == okihanasu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					Wleave(fp2, L_use_parts, R_use_parts);//置き放す leave
					//leave(fp2, TyuPa, Te);//置き放す leave

					for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
					{//左手、右手、冶具の支えの関係を切る
						//if (A_Supports[1][i].PId == TyuPa)
						f = A_Supports[1][i].Length;//支えている数を保存
						for (k = 0; k < f; k++)
						{
							/*if (A_Supports[1][i].PId == use_parts)
							{
								A_Supports[1][i].Flag = 0;
								A_Supports[1][i].PId = 0;
							}*/
							if (A_Supports[1][i].PId[k] == L_use_parts || A_Supports[1][i].PId[k] == R_use_parts)//組立後に部品を支えていてはいけないのでA_Supports[1][i].PId
							{
								for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i].Length;
								A_Supports[1][i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if ((temp[supportlength] != L_use_parts && A_Supports[1][3 + N + i].PId[k] == L_use_parts) ||
										(temp[supportlength] != R_use_parts && A_Supports[1][3 + N + i].PId[k] == R_use_parts))//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i].PId[A_Supports[1][i].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i].Length == 0)
								{
									A_Supports[1][i].Flag = 0;
								}
								break;
							}
						}

						if (i == Tnum - 1 + N + 3)
						{//中間製品置き場と中間製品の支えの関係を作る
							A_Supports[1][i].Flag = 1;
							//A_Supports[1][i].PId = use_parts;
							//A_Supports[1][i].PId = TyuPa;
							for (k = 0; k < A_Supports[1][i].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][i].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = supportflug + 1;//左手で扱う部品を持っている時は＋1する
								}
								else if (A_Supports[1][i].PId[k] == R_use_parts)
								{
									supportflug = supportflug + 2;//右手で扱う部品を持っている時は＋2する
								}
							}
							if (supportflug == 0)//まだ支えられていない時
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = L_use_parts;//中間製品置き場と左手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;

								A_Supports[1][i].PId[A_Supports[1][i].Length] = R_use_parts;//中間製品置き場と右手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else if (supportflug == 1)//左手で扱う部品がすでに支えられているとき(一応の作業)
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = R_use_parts;//中間製品置き場と中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else if (supportflug == 2)//右手で扱う部品がすでに支えられているとき(一応の作業)
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = L_use_parts;//中間製品置き場と左手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else
							{
								supportflug = 0;
							}
						}
					}

				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					leave(fp2, R_use_parts, migite);
					for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
					{//右手、冶具の支えの関係を切る
						//if (A_Supports[1][i].PId == TyuPa)
						f = A_Supports[1][i].Length;//支えている数を保存
						for (k = 0; k < f; k++)
						{
							/*if (A_Supports[1][i].PId == use_parts)
							{
								A_Supports[1][i].Flag = 0;
								A_Supports[1][i].PId = 0;
							}*/
							if (A_Supports[1][i].PId[k] == R_use_parts)//組立後に部品を支えていてはいけないのでA_Supports[1][i].PId
							{
								for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i].Length;
								A_Supports[1][i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != R_use_parts && A_Supports[1][3 + N + i].PId[k] == R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i].PId[A_Supports[1][i].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i].Length == 0)
								{
									A_Supports[1][i].Flag = 0;
								}
								break;
							}
						}

						if (i == Tnum - 1 + N + 3)
						{//中間製品置き場と中間製品の支えの関係を作る
							A_Supports[1][i].Flag = 1;
							//A_Supports[1][i].PId = use_parts;
							//A_Supports[1][i].PId = TyuPa;
							for (k = 0; k < A_Supports[1][i].Length; k++)
							{
								if (A_Supports[1][i].PId[k] == R_use_parts)
								{
									supportflug = supportflug + 2;//右手で扱う部品を持っている時は＋2する
								}
							}
							if (supportflug == 0)//まだ支えられていない時
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = R_use_parts;//中間製品置き場と右手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else
							{
								supportflug = 0;
							}
						}
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					leave(fp2, L_use_parts, hidarite);
					for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
					{//左手、右手、冶具の支えの関係を切る
						//if (A_Supports[1][i].PId == TyuPa)
						f = A_Supports[1][i].Length;//支えている数を保存
						for (k = 0; k < f; k++)
						{
							/*if (A_Supports[1][i].PId == use_parts)
							{
								A_Supports[1][i].Flag = 0;
								A_Supports[1][i].PId = 0;
							}*/
							if (A_Supports[1][i].PId[k] == L_use_parts)//組立後に部品を支えていてはいけないのでA_Supports[1][i].PId
							{
								for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i].Length;
								A_Supports[1][i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != L_use_parts && A_Supports[1][3 + N + i].PId[k] == L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i].PId[A_Supports[1][i].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i].Length == 0)
								{
									A_Supports[1][i].Flag = 0;
								}
								break;
							}
						}

						if (i == Tnum - 1 + N + 3)
						{//中間製品置き場と中間製品の支えの関係を作る
							A_Supports[1][i].Flag = 1;
							//A_Supports[1][i].PId = use_parts;
							//A_Supports[1][i].PId = TyuPa;
							for (k = 0; k < A_Supports[1][i].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][i].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = supportflug + 1;//左手で扱う部品を持っている時は＋1する
								}
							}
							if (supportflug == 0)//まだ支えられていない時
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = L_use_parts;//中間製品置き場と左手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else
							{
								supportflug = 0;
							}
						}
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == hanasu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					WRelease(fp2, L_use_parts, R_use_parts);//両手で放すrelease

					for (supportlength = 0; supportlength < A_Supports[1][hidarite].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][hidarite].PId[supportlength];//値を移す
						A_Supports[1][hidarite].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][hidarite].Length;
					A_Supports[1][hidarite].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != L_use_parts)
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = temp[k];
							A_Supports[1][hidarite].Length++;
						}
					}
					if (A_Supports[1][hidarite].Length == 0)
					{
						A_Supports[1][hidarite].Flag = 0;
					}

					for (supportlength = 0; supportlength < A_Supports[1][migite].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][migite].PId[supportlength];//値を移す
						A_Supports[1][migite].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][migite].Length;
					A_Supports[1][migite].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != use_parts)
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = temp[k];
							A_Supports[1][migite].Length++;
						}
					}
					if (A_Supports[1][migite].Length == 0)
					{
						A_Supports[1][migite].Flag = 0;
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					Release(fp2, R_use_parts, migite);//右手で放すrelease
					for (supportlength = 0; supportlength < A_Supports[1][migite].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][migite].PId[supportlength];//値を移す
						A_Supports[1][migite].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][migite].Length;
					A_Supports[1][migite].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != use_parts)
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = temp[k];
							A_Supports[1][migite].Length++;
						}
					}
					if (A_Supports[1][migite].Length == 0)
					{
						A_Supports[1][migite].Flag = 0;
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					Release(fp2, L_use_parts, hidarite);//左手で放すrelease
					for (supportlength = 0; supportlength < A_Supports[1][hidarite].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][hidarite].PId[supportlength];//値を移す
						A_Supports[1][hidarite].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][hidarite].Length;
					A_Supports[1][hidarite].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != L_use_parts)
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = temp[k];
							A_Supports[1][hidarite].Length++;
						}
					}
					if (A_Supports[1][hidarite].Length == 0)
					{
						A_Supports[1][hidarite].Flag = 0;
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == kumitateru)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					oya_hoji = A_Jigus[Jig].Jnum;
					if (R_line < L_line)
					{
						Kumitate(fp2, A_Supports[1][N + putting + 3 + R_Jig].Id, TyuPa, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
						Kumitate(fp2, A_Supports[1][N + putting + 3 + L_Jig].Id, TyuPa2, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
					}
					else
					{
						Kumitate(fp2, A_Supports[1][N + putting + 3 + L_Jig].Id, TyuPa, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
						Kumitate(fp2, A_Supports[1][N + putting + 3 + R_Jig].Id, TyuPa2, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					oya_hoji = A_Jigus[Jig].Jnum;
					if (R_line < L_line)
					{
						Kumitate(fp2, A_Supports[1][N + putting + 3 + R_Jig].Id, TyuPa, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[L_line].jig - 1].Id, TyuPa2, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
					}
					else
					{
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[L_line].jig - 1].Id, TyuPa, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
						Kumitate(fp2, A_Supports[1][N + putting + 3 + R_Jig].Id, TyuPa2, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
					}

				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					oya_hoji = A_Jigus[Jig].Jnum;
					if (R_line < L_line)
					{
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[R_line].jig - 1].Id, TyuPa, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
						Kumitate(fp2, A_Supports[1][N + putting + 3 + L_Jig].Id, TyuPa2, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
					}
					else
					{
						Kumitate(fp2, A_Supports[1][N + putting + 3 + L_Jig].Id, TyuPa, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[R_line].jig - 1].Id, TyuPa2, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == motinaosu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					L_Turn0X = A_Objects[0][L_use_object].DirX;
					L_Turn1X = A_Objects[1][L_use_object].DirX;
					L_Turn0Y = A_Objects[0][L_use_object].DirY;
					L_Turn1Y = A_Objects[1][L_use_object].DirY;
					L_Turn0Z = A_Objects[0][L_use_object].DirZ;
					L_Turn1Z = A_Objects[1][L_use_object].DirZ;

					R_Turn0X = A_Objects[0][R_use_object].DirX;
					R_Turn1X = A_Objects[1][R_use_object].DirX;
					R_Turn0Y = A_Objects[0][R_use_object].DirY;
					R_Turn1Y = A_Objects[1][R_use_object].DirY;
					R_Turn0Z = A_Objects[0][R_use_object].DirZ;
					R_Turn1Z = A_Objects[1][R_use_object].DirZ;

					WTurn(fp2, L_use_parts, L_Turn0X, L_Turn0Y, L_Turn0Z, L_Turn1X, L_Turn1Y, L_Turn1Z, R_use_parts, R_Turn0X, R_Turn0Y, R_Turn0Z, R_Turn1X, R_Turn1Y, R_Turn1Z);//左手で回転させるturn
					if (M_pattern[movetype].Move[migite][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(R_Turn0X - R_Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(R_Turn0Y - R_Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(R_Turn0Z - R_Turn1Z) + Oyakaitenkakudo;
					}
					if (M_pattern[movetype].Move[hidarite][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(L_Turn0X - L_Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(L_Turn0Y - L_Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(L_Turn0Z - L_Turn1Z) + Oyakaitenkakudo;
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					R_Turn0X = A_Objects[0][R_use_object].DirX;
					R_Turn1X = A_Objects[1][R_use_object].DirX;
					R_Turn0Y = A_Objects[0][R_use_object].DirY;
					R_Turn1Y = A_Objects[1][R_use_object].DirY;
					R_Turn0Z = A_Objects[0][R_use_object].DirZ;
					R_Turn1Z = A_Objects[1][R_use_object].DirZ;

					Turn(fp2, R_use_parts, R_Turn0X, R_Turn0Y, R_Turn0Z, R_Turn1X, R_Turn1Y, R_Turn1Z, migite);//回転させるturn
					if (M_pattern[movetype].Move[migite][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(R_Turn0X - R_Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(R_Turn0Y - R_Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(R_Turn0Z - R_Turn1Z) + Oyakaitenkakudo;
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					L_Turn0X = A_Objects[0][L_use_object].DirX;
					L_Turn1X = A_Objects[1][L_use_object].DirX;
					L_Turn0Y = A_Objects[0][L_use_object].DirY;
					L_Turn1Y = A_Objects[1][L_use_object].DirY;
					L_Turn0Z = A_Objects[0][L_use_object].DirZ;
					L_Turn1Z = A_Objects[1][L_use_object].DirZ;
					Turn(fp2, L_use_parts, L_Turn0X, L_Turn0Y, L_Turn0Z, L_Turn1X, L_Turn1Y, L_Turn1Z, hidarite);
					if (M_pattern[movetype].Move[hidarite][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(L_Turn0X - L_Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(L_Turn0Y - L_Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(L_Turn0Z - L_Turn1Z) + Oyakaitenkakudo;
					}
				}
			}
		}
	}
	for (i = 0; i < 2; i++)
	{
		//手の最終座標を合わせる
		A_Objects[1][2 * N - 1 + i].IchiX = A_Objects[0][2 * N - 1 + i].IchiX;
		A_Objects[1][2 * N - 1 + i].IchiY = A_Objects[0][2 * N - 1 + i].IchiY;
		A_Objects[1][2 * N - 1 + i].IchiZ = A_Objects[0][2 * N - 1 + i].IchiZ;
	}
	if (kumijun[line].kougu != 0)//工具を用いる時
	{
		A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiX = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiX;//工具の座標を更新
		A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiY = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY;
		A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY;
	}
}

void kumitatego_to_karioki(FILE* fp2, int line, int movetype)
{
	int i = 0, R_length = 0, L_length = 0, length = 0, /*movetype = 0,*/ Te = 0, nowmove = 0, Jig = 0;
	int OyaPa, KoPa, TyuPa, Jigbangou = 0;//親部品番号,子部品番号,中間製品
	double IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Turn0X, Turn0Y, Turn0Z, Turn1X, Turn1Y, Turn1Z;
	int Oyanum = 0;//親部品が何番目にあるか
	int use_parts = 0/*使用する部品番号*/, use_object = 0/*使用する部品がobjectでどこにあるか*/;
	int R_use_parts = 0/*右手で使用する部品番号*/, R_use_object = 0;/*右手で使用する部品がobjectでどこにあるか*/
	int L_use_parts = 0/*左手で使用する部品番号*/, L_use_object = 0;/*左手で使用する部品がobjectでどこにあるか*/
	double R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2, R_Turn0X, R_Turn0Y, R_Turn0Z, R_Turn1X, R_Turn1Y, R_Turn1Z;
	double L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, L_Turn0X, L_Turn0Y, L_Turn0Z, L_Turn1X, L_Turn1Y, L_Turn1Z;
	int temp[MaxSupport], templength = 0;

	int R_Jig = 0, L_Jig = 0, R_Jigbangou = 0, L_Jigbangou = 0, R_TyuPa = 0, L_TyuPa = 0, TyuPa2 = 0, R_line = 0/*両手の時右手の組付けが一行目か二行目かどうかを保管*/, L_line = 0/*両手の時右手の組付けが一行目か二行目かどうかを保管*/;
	int supportlength = 0, k = 0, supportflug = 0, f = 0;
	int KouguBnum = 0, Kougunum = 0, KouguPnum = 0;//KouguBnum：レイアウト情報での工具の番号、Kougunum：工具番号,KouguPnum：工具がobjectsでどこにあるか
	int ChangeKouguBnum = 0, ChangeKougunum = 0, ChangeKouguPnum = 0;//ChangeKouguBnum：レイアウト情報での交換する工具の番号、ChangeKougunum：交換する工具番号,ChangeKouguPnum：交換する工具がobjectsでどこにあるか
	int TempKougunum = 0;
	int BeforeJig = 0;
	int BeforeJigR = 0, BeforeJigL = 0;

	TyuPa2 = kumijun[line + 1].tyukan;

	R_length = M_pattern[movetype].length[migite];
	L_length = M_pattern[movetype].length[hidarite];
	KoPa = kumijun[line].ko;
	OyaPa = kumijun[line].oya;
	TyuPa = kumijun[line].tyukan;
	if (NewNOS0 == 0)
	{
		Jig = kumijun[line].jig - 1;
		Kougunum = kumijun[line].kougu - 1;
		ChangeKougunum = kumijun[line - 1].kougu - 1;
	}
	else
	{
		for (i = 0; i < Jigu; i++)
		{
			if (A_Objects[0][3 * N + 2 + i + putting].Id == kumijun[line].jig)
			{
				Jig = i;
				break;
			}
		}
		for (i = 0; i < Kougu; i++)
		{
			if (A_Objects[0][3 * N + 2 + i + putting + Jigu].Id == kumijun[line].kougu)
			{
				Kougunum = i;
				break;
			}
		}
		for (i = 0; i < Kougu; i++)
		{
			if (A_Objects[0][3 * N + 2 + i + putting + Jigu].Id == kumijun[line - 1].kougu)
			{
				ChangeKougunum = i;
				break;
			}
		}
	}
	Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
	//Kougunum = kumijun[line].kougu;
	KouguBnum = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].Id;
	//ChangeKougunum = kumijun[line-1].kougu;
	ChangeKouguBnum = A_Objects[0][3 * N + 2 + ChangeKougunum + putting + Jigu].Id;

	if (R_length > L_length)
	{
		length = R_length;
	}
	else
	{
		length = L_length;
	}

	for (nowmove = 0; nowmove <= length; nowmove++)
	{
		if (M_pattern[movetype].Move[migite][nowmove][move] != none && M_pattern[movetype].Move[hidarite][nowmove][move] != none)//右手左手両方に同時に動作がある時
		{
			Te = ryoute;
		}
		else if (M_pattern[movetype].Move[migite][nowmove][move] != none)//右手に作業がある時
		{
			Te = migite;
		}
		else if (M_pattern[movetype].Move[hidarite][nowmove][move] != none)//左手に動作がある時
		{
			Te = hidarite;
		}

		//どの部品を対象とするかを調べる
		if (Te == migite || Te == hidarite)//両手で同時に作業をしない時
		{
			if (M_pattern[movetype].Move[Te][nowmove][target] == Oya)//対象製品が親部品
			{
				if (Oya2flag == 1)//基準部品が最初の部品の時
				{//2番目の部品が対象の部品になる
					use_parts = kumijun[line + 1].oya;
					use_object = OyaPnum;
				}
				else if (Oya2flag == 2)//基準部品が2番目の部品の時
				{//最初の部品が対象の部品になる
					use_parts = kumijun[line].oya;
					use_object = OyaPnum1;
				}
				else
				{
					use_parts = OyaPa;
					if (kumijun[line].scene_type == oya1ko2)
					{
						use_object = OyaPnum1;
					}
					else
					{
						use_object = OyaPnum;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Ko)//対象製品が子部品
			{
				use_parts = KoPa;
				use_object = KoPnum;
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Tyukan)//対象製品が中間製品
			{
				use_parts = TyuPa;
				use_object = TyuPnum;
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Start_P)//手を初期位置に戻すとき、対象製品は使用する手
			{
				use_object = 2 * N - 1 + Te;
			}

			else if (M_pattern[movetype].Move[Te][nowmove][target] == Ko1)//両手2部品の時の右手で扱う子部品
			{
				use_parts = A_Objects[0][R_KoPnum].Id;
				use_object = R_KoPnum;
				if (Oya2flag == 2)
				{
					use_object = KoPnum1;
				}
				else if (Oya2flag == 1)
				{
					use_object = KoPnum1;
				}
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].ko == R_use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						OyaPa = kumijun[i].oya;
						KoPa = kumijun[i].ko;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Oya1)//両手2部品の時の右手で扱う親部品
			{
				use_parts = A_Objects[0][R_OyaPnum].Id;
				use_object = R_OyaPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].oya == R_use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Tyukan1)//両手2部品の時の右手で扱う中間製品部品
			{
				use_parts = A_Objects[0][R_TyuPnum].Id;
				use_object = R_TyuPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].tyukan == use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Ko2)//両手2部品の時の左手で扱う子部品
			{
				use_parts = A_Objects[0][L_KoPnum].Id;
				use_object = L_KoPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].ko == use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						OyaPa = kumijun[i].oya;
						KoPa = kumijun[i].ko;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[line].jig - 1;
						}
						else
						{
							for (i = 0; i < Jigu; i++)
							{
								if (A_Objects[0][3 * N + 2 + i + putting].Id == kumijun[line].jig)
								{
									Jig = i;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Oya2)//両手2部品の時の左手で扱う親部品
			{
				use_parts = A_Objects[0][L_OyaPnum].Id;
				use_object = L_OyaPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].oya == use_parts)
					{
						OyaPa = kumijun[i].oya;
						KoPa = kumijun[line].ko;
						TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Tyukan2)//両手2部品の時の左手で扱う中間製品部品
			{
				use_parts = A_Objects[0][L_TyuPnum].Id;
				use_object = L_TyuPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].tyukan == L_use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)
			{
				use_parts = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].Id;
				use_object = 3 * N + 2 + Kougunum + putting + Jigu;
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == ChangeKOUGU)
			{
				use_parts = A_Objects[0][3 * N + 2 + ChangeKougunum + putting + Jigu].Id;
				use_object = 3 * N + 2 + ChangeKougunum + putting + Jigu;
			}

			if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == nobasu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{//Te = M_pattern[movetype].kobuhin[nowmove][Hand];
				//もともと治具に付いている部品(親部品)に手を伸ばす
					IchiX1 = A_Objects[0][2 * N - 1 + Te].IchiX;//使用する手の現在の位置
					IchiY1 = A_Objects[0][2 * N - 1 + Te].IchiY;
					IchiZ1 = A_Objects[0][2 * N - 1 + Te].IchiZ;
					if (M_pattern[movetype].Move[Te][nowmove][target] == Start_P)
					{
						IchiX2 = A_Objects[1][use_object].IchiX;
						IchiY2 = A_Objects[1][use_object].IchiY;
						IchiZ2 = A_Objects[1][use_object].IchiZ;
					}
					else
					{
						IchiX2 = A_Objects[0][use_object].IchiX;
						IchiY2 = A_Objects[0][use_object].IchiY;
						IchiZ2 = A_Objects[0][use_object].IchiZ;
					}
					/*IchiX2 = A_Objects[0][OyaPnum].IchiX;
					IchiY2 = A_Objects[0][OyaPnum].IchiY;
					IchiZ2 = A_Objects[0][OyaPnum].IchiZ;*/

					Reach(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);

					A_Objects[0][2 * N - 1 + Te].IchiX = IchiX2;//手の座標を更新
					A_Objects[0][2 * N - 1 + Te].IchiY = IchiY2;
					A_Objects[0][2 * N - 1 + Te].IchiZ = IchiZ2;
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == tsukamu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = Te;//部品を持っている手を記録
					if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)//対象が工具の時は工具を使用していることを記録しておく
					{
						Kouguflag = KouguBnum;
					}
					Gripping(fp2, use_parts, Te);//掴む
					//Gripping(fp2, TyuPa, Te);//掴む
					if (A_Supports[1][Te].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][Te].Id = A_Hands[Te].Hnum;//部品と手の支えの関係をつくる
						A_Supports[1][Te].Flag = 1;
						A_Supports[1][Te].PId[0] = use_parts;
						A_Supports[1][Te].Length++;
					}
					else
					{
						A_Supports[1][Te].Id = A_Hands[Te].Hnum;
						A_Supports[1][Te].Flag = 1;
						for (k = 0; k < A_Supports[1][Te].Length; k++)
						{
							//A_Supports[0][Te].PId = use_parts;
							if (A_Supports[1][Te].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][Te].PId[A_Supports[1][Te].Length] = use_parts;//部品と手の支えの関係をつくる
							A_Supports[1][Te].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
					//A_Supports[1][Te].PId = TyuPa;
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == tsukamitoru)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = Te;//部品を持っている手を記録
					if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)//対象が工具の時は工具を使用していることを記録しておく
					{
						Kouguflag = KouguBnum;
					}

					if (JigKobuhin == use_parts || JigKobuhin2 == use_parts || ChangeJig == use_parts || ChangeJig2 == use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == use_parts)
								{
									BeforeJig = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					//部品箱の支えの関係を切る
					for (i = 0; i < Bboxnum; i++)
					{
						for (k = 0; k < A_Supports[1][i + 2].Length; k++)
						{
							if (A_Supports[1][i + 2].PId[k] == use_parts) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
							   //A_Supports[1][i + 2].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i + 2].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i + 2].Length;
								A_Supports[1][i + 2].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i + 2].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i + 2].Length == 0)
								{
									A_Supports[1][i + 2].Flag = 0;
								}
								break;
							}
						}
					}
					for (i = 0; i < putting; i++)
					{//中間製品置き場からとるとき、支えの関係を切る
						//if (A_Supports[0][3 + N + i].PId == OyaPa)
						/*if (A_Supports[0][3 + N + i].PId == use_parts)
						{
							A_Supports[1][3 + N + i].Flag = 0;
							A_Supports[1][3 + N + i].PId = 0;
						}*/
						for (k = 0; k < A_Supports[1][3 + N + i].Length; k++)
						{
							if (A_Supports[1][3 + N + i].PId[k] == use_parts) {//A_Supports[][0],A_Supports[][1]には
							   //A_Supports[1][3 + N + i].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][3 + N + i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][3 + N + i].Length;
								A_Supports[1][3 + N + i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = temp[supportlength];//データの移行
										A_Supports[1][3 + N + i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][3 + N + i].Length == 0)
								{
									A_Supports[1][3 + N + i].Flag = 0;
								}
								break;
							}
						}
					}

					if (A_Supports[1][Te].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][Te].Id = A_Hands[Te].Hnum;//部品と手の支えの関係をつくる
						A_Supports[1][Te].Flag = 1;
						A_Supports[1][Te].PId[0] = use_parts;
						A_Supports[1][Te].Length++;
					}
					else
					{
						A_Supports[1][Te].Id = A_Hands[Te].Hnum;
						A_Supports[1][Te].Flag = 1;
						for (k = 0; k < A_Supports[1][Te].Length; k++)
						{
							//A_Supports[0][Te].PId = use_parts;
							if (A_Supports[1][Te].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][Te].PId[A_Supports[1][Te].Length] = use_parts;//部品と手の支えの関係をつくる
							A_Supports[1][Te].Length++;
						}
						else
						{
							supportflug = 0;
						}

					}
					//A_Supports[0][Te].PId = OyaPa;

					Grip(fp2, use_parts, BeforeJig, Te);//掴み取る grip
					//Grip(fp2, OyaPa, Te);//掴み取る grip
					BeforeJig = 0;
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == hakobu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					//Te = M_pattern[movetype].kobuhin[nowmove][Hand];

					IchiX1 = A_Objects[0][2 * N - 1 + Te].IchiX;
					IchiY1 = A_Objects[0][2 * N - 1 + Te].IchiY;
					IchiZ1 = A_Objects[0][2 * N - 1 + Te].IchiZ;
					IchiX2 = A_Objects[1][use_object].IchiX;
					IchiY2 = A_Objects[1][use_object].IchiY;
					IchiZ2 = A_Objects[1][use_object].IchiZ;
					/*IchiX2 = A_Objects[1][TyuPnum].IchiX;
					IchiY2 = A_Objects[1][TyuPnum].IchiY;
					IchiZ2 = A_Objects[1][TyuPnum].IchiZ;*/

					Carry(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);//左手で運ぶ carry

					A_Objects[0][2 * N - 1 + Te].IchiX = IchiX2;//手の座標を更新
					A_Objects[0][2 * N - 1 + Te].IchiY = IchiY2;
					A_Objects[0][2 * N - 1 + Te].IchiZ = IchiZ2;

					A_Objects[0][use_object].IchiX = IchiX2;//部品の座標を更新
					A_Objects[0][use_object].IchiY = IchiY2;
					A_Objects[0][use_object].IchiZ = IchiZ2;

					if ((Kouguflag != 0 && M_pattern[movetype].Move[Te][nowmove][target] == Ko) || M_pattern[movetype].Move[Te][nowmove][target] == KOUGU || M_pattern[movetype].Move[Te][nowmove][target] == ChangeKOUGU)//工具を用いて部品を運ぶ場合は工具の座標も変更
					{
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiX = IchiX2;//工具の座標を更新
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY = IchiY2;
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = IchiZ2;
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == okihanasu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = -1;//部品を持っている手がないことを記録
					if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)//対象が工具の時は工具を使用していないのでフラグを0に戻す
					{
						Kouguflag = 0;
					}

					for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
					{//左手、右手、冶具の支えの関係を切る
						//if (A_Supports[1][i].PId == TyuPa)
						f = A_Supports[1][i].Length;//支えている数を保存
						for (k = 0; k < f; k++)
						{
							/*if (A_Supports[1][i].PId == use_parts)
							{
								A_Supports[1][i].Flag = 0;
								A_Supports[1][i].PId = 0;
							}*/
							if (A_Supports[1][i].PId[k] == use_parts)//組立後に部品を支えていてはいけないのでA_Supports[1][i].PId
							{
								for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i].Length;
								A_Supports[1][i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != use_parts)//一致する部品は支えない部品なのでカウントしない
									{
										A_Supports[1][i].PId[A_Supports[1][i].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i].Length == 0)
								{
									A_Supports[1][i].Flag = 0;
								}
								break;
							}
						}

						if (i == Tnum - 1 + N + 3)
						{//中間製品置き場と中間製品の支えの関係を作る
							A_Supports[1][i].Flag = 1;
							//A_Supports[1][i].PId = use_parts;
							//A_Supports[1][i].PId = TyuPa;
							for (k = 0; k < A_Supports[1][i].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][i].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = 1;
									break;
								}
							}
							if (supportflug == 0)//まだ支えられていない時
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = use_parts;//親部品と手の支えの関係をつくる
								A_Supports[1][i].Length++;
							}
							else
							{
								supportflug = 0;
							}
						}
					}

					leave(fp2, use_parts, Te);//置き放す leave
					//leave(fp2, TyuPa, Te);//置き放す leave
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == tsukeru)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = Te;//部品を持っている手を記録

					if (M_pattern[movetype].Move[Te][nowmove][destination] == KOUGU)//付ける対象が工具の時は工具に付ける
					{
						Fix(fp2, KouguBnum, use_parts, Te);//付ける fix
						//Fix(fp2, Jigbangou, OyaPa, Te);//付ける fix

						//工具と親部品の支えの関係をつくる
						A_Supports[1][N + 3 + putting + Jigu + Kougunum].Id = A_Kougus[Kougunum].Bnum;
						A_Supports[1][N + 3 + putting + Jigu + Kougunum].Flag = 1;

						if (A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length == 0)
						{
							A_Supports[1][N + 3 + putting + Jigu + Kougunum].PId[A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length] = use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length++;
						}
						else
						{
							for (k = 0; k < A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][N + 3 + putting + Jigu + Kougunum].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = 1;
									break;
								}

								if (supportflug == 0)//まだ支えられていない時
								{
									A_Supports[1][N + 3 + putting + Jigu + Kougunum].PId[A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length] = use_parts;//親部品と手の支えの関係をつくる
									A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length++;
									break;
								}
								else
								{
									supportflug = 0;
								}
							}
						}
					}
					else
					{
						Fix(fp2, Jigbangou, use_parts, Te);//付ける fix
					   //Fix(fp2, Jigbangou, OyaPa, Te);//付ける fix

					   //治具と親部品の支えの関係をつくる
						A_Supports[1][3 + N + putting + Jig].Id = A_Jigus[Jig].Jnum;
						A_Supports[1][3 + N + putting + Jig].Flag = 1;
						//A_Supports[1][3 + N + putting + Jig].PId = use_parts;
						//A_Supports[1][3 + N + putting + Jig].PId = OyaPa;

						if (A_Supports[1][3 + N + putting + Jig].Length == 0)
						{
							A_Supports[1][3 + N + putting + Jig].PId[A_Supports[1][3 + N + putting + Jig].Length] = use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + Jig].Length++;
						}
						else
						{
							for (k = 0; k < A_Supports[1][3 + N + putting + Jig].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][3 + N + putting + Jig].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = 1;
									break;
								}

								if (supportflug == 0)//まだ支えられていない時
								{
									A_Supports[1][3 + N + putting + Jig].PId[A_Supports[1][3 + N + putting + Jig].Length] = use_parts;//親部品と手の支えの関係をつくる
									A_Supports[1][3 + N + putting + Jig].Length++;
									break;
								}
								else
								{
									supportflug = 0;
								}
							}
						}
						oya_hoji = A_Jigus[Jig].Jnum;
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == hazusu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					if (M_pattern[movetype].Move[Te][nowmove][destination] == KOUGU || M_pattern[movetype].Move[Te][nowmove][destination] == ChangeKOUGU)
					{
						if (M_pattern[movetype].Move[Te][nowmove][destination] == ChangeKOUGU)
						{
							TempKougunum = ChangeKougunum;
						}
						else
						{
							TempKougunum = Kougunum;
						}

						Remove(fp2, A_Objects[0][3 * N + 2 + TempKougunum + putting + Jigu].Id, use_parts, Te);//外す remove
						//Remove(fp2, Jigbangou, TyuPa, Te);//外す remove
						//治具と親部品の支えの関係を切る
						//A_Supports[1][3 + N + putting + Jig].PId = 0;

						for (supportlength = 0; supportlength < A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length; supportlength++)
						{
							temp[supportlength] = 0;//配列の初期化
							temp[supportlength] = A_Supports[1][N + 3 + putting + Jigu + TempKougunum].PId[supportlength];//値を移す
							A_Supports[1][N + 3 + putting + Jigu + TempKougunum].PId[supportlength] = 0;//配列の初期化
						}
						templength = 0;
						templength = A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length;
						A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length = 0;//一旦0にする
						for (k = 0; k < templength; k++)
						{
							if (temp[k] != use_parts)
							{
								A_Supports[1][N + 3 + putting + Jigu + TempKougunum].PId[A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length] = temp[k];
								A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length++;
							}
						}
						if (A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length == 0)
						{
							A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Flag = 0;
						}
					}
					else
					{
						Remove(fp2, Jigbangou, use_parts, Te);//外す remove
						//Remove(fp2, Jigbangou, TyuPa, Te);//外す remove
						//治具と親部品の支えの関係を切る
						//A_Supports[1][3 + N + putting + Jig].PId = 0;

						for (supportlength = 0; supportlength < A_Supports[1][3 + N + putting + Jig].Length; supportlength++)
						{
							temp[supportlength] = 0;//配列の初期化
							temp[supportlength] = A_Supports[1][3 + N + putting + Jig].PId[supportlength];//値を移す
							A_Supports[1][3 + N + putting + Jig].PId[supportlength] = 0;//配列の初期化
						}
						templength = 0;
						templength = A_Supports[1][3 + N + putting + Jig].Length;
						A_Supports[1][3 + N + putting + Jig].Length = 0;//一旦0にする
						for (k = 0; k < templength; k++)
						{
							if (temp[k] != use_parts)
							{
								A_Supports[1][3 + N + putting + Jig].PId[A_Supports[1][3 + N + putting + Jig].Length] = temp[k];
								A_Supports[1][3 + N + putting + Jig].Length++;
							}
						}
						if (A_Supports[1][3 + N + putting + Jig].Length == 0)
						{
							A_Supports[1][3 + N + putting + Jig].Flag = 0;
						}
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == hanasu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = -1;//部品を持っている手がないことを記録
					if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)//対象が工具の時は工具を使用していないのでフラグを0に戻す
					{
						Kouguflag = 0;
					}
					Release(fp2, use_parts, Te);//放すrelease
					//Release(fp2, OyaPa, Te);//放すrelease
					//親部品と手の支えの関係を切る
					//A_Supports[0][Te].Flag = 0;
					//A_Supports[0][Te].PId = 0;
					for (supportlength = 0; supportlength < A_Supports[1][Te].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][Te].PId[supportlength];//値を移す
						A_Supports[1][Te].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][Te].Length;
					A_Supports[1][Te].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != use_parts)
						{
							A_Supports[1][Te].PId[A_Supports[1][Te].Length] = temp[k];
							A_Supports[1][Te].Length++;
						}
					}
					if (A_Supports[1][Te].Length == 0)
					{
						A_Supports[1][Te].Flag = 0;
					}

					if (Kouguflag != 0)
					{
						for (supportlength = 0; supportlength < A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length; supportlength++)
						{
							temp[supportlength] = 0;//配列の初期化
							temp[supportlength] = A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId[supportlength];//値を移す
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId[supportlength] = 0;//配列の初期化
						}
						templength = 0;
						templength = A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length;
						A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length = 0;//一旦0にする
						for (k = 0; k < templength; k++)
						{
							if (temp[k] != use_parts)
							{
								A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId[A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length] = temp[k];
								A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length++;
							}
						}
						if (A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length == 0)
						{
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].Flag = 0;
						}
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == motinaosu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					Turn0X = A_Objects[0][use_object].DirX;
					Turn1X = A_Objects[1][use_object].DirX;
					Turn0Y = A_Objects[0][use_object].DirY;
					Turn1Y = A_Objects[1][use_object].DirY;
					Turn0Z = A_Objects[0][use_object].DirZ;
					Turn1Z = A_Objects[1][use_object].DirZ;

					Turn(fp2, use_parts, Turn0X, Turn0Y, Turn0Z, Turn1X, Turn1Y, Turn1Z, Te);//左手で回転させるturn
					if (M_pattern[movetype].Move[Te][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(Turn0X - Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(Turn0Y - Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(Turn0Z - Turn1Z) + Oyakaitenkakudo;
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == kumitateidou)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = Te;//部品を持っている手を記録
					/*IchiX1 = A_Objects[1][KoPnum].IchiX;
					IchiY1 = A_Objects[1][KoPnum].IchiY;
					IchiZ1 = A_Objects[1][KoPnum].IchiZ;*/
					IchiX1 = A_Objects[0][2 * N - 1 + Te].IchiX;
					IchiY1 = A_Objects[0][2 * N - 1 + Te].IchiY;
					IchiZ1 = A_Objects[0][2 * N - 1 + Te].IchiZ;

					if (kumijun[line].scene_type == oya2ko1)
					{
						/*if (Oya2flag == 1 || Oya2flag == 3)
						{
							IchiX2 = KIdo_X1;
							IchiY2 = KIdo_Y1;
							IchiZ2 = KIdo_Z1;
						}
						else if (Oya2flag == 2)
						{
							IchiX2 = KIdo_X;
							IchiY2 = KIdo_Y;
							IchiZ2 = KIdo_Z;
						}*/
						IchiX2 = KIdo_X1;
						IchiY2 = KIdo_Y1;
						IchiZ2 = KIdo_Z1;
					}
					else
					{
						IchiX2 = KIdo_X;
						IchiY2 = KIdo_Y;
						IchiZ2 = KIdo_Z;
					}

					Kumimove(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);//組立移動Kumimove

					A_Objects[0][2 * N - 1 + Te].IchiX = IchiX2;//手の座標を更新
					A_Objects[0][2 * N - 1 + Te].IchiY = IchiY2;
					A_Objects[0][2 * N - 1 + Te].IchiZ = IchiZ2;

					A_Objects[0][use_object].IchiX = IchiX2;//部品の座標を更新
					A_Objects[0][use_object].IchiY = IchiY2;
					A_Objects[0][use_object].IchiZ = IchiZ2;

					A_Objects[1][use_object].IchiX = IchiX2;//部品の座標を更新
					A_Objects[1][use_object].IchiY = IchiY2;
					A_Objects[1][use_object].IchiZ = IchiZ2;

					if ((Kouguflag != 0 && M_pattern[movetype].Move[Te][nowmove][target] == Ko) || M_pattern[movetype].Move[Te][nowmove][target] == KOUGU || M_pattern[movetype].Move[Te][nowmove][target] == ChangeKOUGU)//工具を用いて部品を運ぶ場合は工具の座標も変更
					{
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiX = IchiX2;//部品の座標を更新
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY = IchiY2;
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = IchiZ2;
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == kumitateru)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					//Te = M_pattern[movetype].kobuhin[nowmove][Hand];
					/*if (kumijun[line].scene_type == oya2ko1)
					{
						Kumitate(fp2, A_Supports[0][N + putting + 3 + kumijun[line].jig - 1].Id, kumijun[line].tyukan, kumijun[line].oya, kumijun[line].ko, Te);//右手で組立Kumitate
						Kumitate(fp2, A_Supports[0][N + putting + 3 + kumijun[line + 1].jig - 1].Id, kumijun[line + 1].tyukan, kumijun[line + 1].oya, kumijun[line + 1].ko, Te);//右手で組立Kumitate
					}*/
					if (kumijun[line].kougu != 0)//工具を用いて組立を行う時
					{
						KouguKumi(fp2, Jigbangou, KouguBnum, TyuPa, OyaPa, KoPa);
					}
					else
					{
						Kumitate(fp2, Jigbangou, TyuPa, OyaPa, KoPa, Te);//組立Kumitate
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == sentanhenkou)
			{
				Tipmove(fp2, line, M_pattern[movetype].Move[Te][nowmove][target], Te);
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == hakobu_tsuika)
			{
				IchiX1 = A_Objects[0][2 * N - 1 + Te].IchiX;
				IchiY1 = A_Objects[0][2 * N - 1 + Te].IchiY;
				IchiZ1 = A_Objects[0][2 * N - 1 + Te].IchiZ;
				IchiX2 = A_Objects[1][use_object].IchiX + M_pattern[movetype].Move_addition[Te][nowmove][0];
				IchiY2 = A_Objects[1][use_object].IchiY + M_pattern[movetype].Move_addition[Te][nowmove][1];
				IchiZ2 = A_Objects[1][use_object].IchiZ + M_pattern[movetype].Move_addition[Te][nowmove][2];

				Carry(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);//左手で運ぶ carry

				A_Objects[0][2 * N - 1 + Te].IchiX = IchiX2;//手の座標を更新
				A_Objects[0][2 * N - 1 + Te].IchiY = IchiY2;
				A_Objects[0][2 * N - 1 + Te].IchiZ = IchiZ2;

				A_Objects[0][use_object].IchiX = IchiX2;//部品の座標を更新
				A_Objects[0][use_object].IchiY = IchiY2;
				A_Objects[0][use_object].IchiZ = IchiZ2;


				if ((Kouguflag != 0 && M_pattern[movetype].Move[Te][nowmove][target] == Ko) || M_pattern[movetype].Move[Te][nowmove][target] == KOUGU || M_pattern[movetype].Move[Te][nowmove][target] == ChangeKOUGU)//工具を用いて部品を運ぶ場合は工具の座標も変更
				{
					A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiX = IchiX2;//部品の座標を更新
					A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY = IchiY2;
					A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = IchiZ2;
				}

			}
		}
		else if (Te == ryoute)
		{
			//右手の対象を決める
			if (M_pattern[movetype].Move[migite][nowmove][target] == Oya)//対象製品が親部品
			{

				if (Oya2flag == 1)//基準部品が最初の部品の時
				{//2番目の部品が対象の部品になる
					R_use_parts = kumijun[line + 1].oya;
					R_use_object = OyaPnum;
				}
				else if (Oya2flag == 2)//基準部品が2番目の部品の時
				{//最初の部品が対象の部品になる
					R_use_parts = kumijun[line].oya;
					R_use_object = OyaPnum1;
				}
				else
				{
					R_use_parts = OyaPa;
					R_use_object = OyaPnum;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Ko)//対象製品が子部品
			{
				R_use_parts = KoPa;
				R_use_object = KoPnum;
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Tyukan)//対象製品が中間製品
			{
				R_use_parts = TyuPa;
				R_use_object = TyuPnum;
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Start_P)//手を初期位置に戻すとき、対象製品は使用する手
			{
				R_use_object = 2 * N - 1 + migite;
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Ko1)//両手2部品の時の右手で扱う子部品
			{
				R_use_parts = A_Objects[0][R_KoPnum].Id;
				R_use_object = R_KoPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].ko == R_use_parts)
					{
						R_TyuPa = kumijun[i].tyukan;
						R_line = i;
						if (NewNOS0 == 0)
						{
							R_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									R_Jig = k;
									break;
								}

							}
						}

						R_Jigbangou = A_Supports[0][N + putting + 3 + R_Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Oya1)//両手2部品の時の右手で扱う親部品
			{
				R_use_parts = A_Objects[0][R_OyaPnum].Id;
				R_use_object = R_OyaPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].oya == R_use_parts)
					{
						R_TyuPa = kumijun[i].tyukan;
						R_line = i;
						if (NewNOS0 == 0)
						{
							R_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									R_Jig = k;
									break;
								}

							}
						}
						R_Jigbangou = A_Supports[0][N + putting + 3 + R_Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Tyukan1)//両手2部品の時の右手で扱う中間製品部品
			{
				R_use_parts = A_Objects[0][R_TyuPnum].Id;
				R_use_object = R_TyuPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].tyukan == R_use_parts)
					{
						R_TyuPa = kumijun[i].tyukan;
						R_line = i;
						if (NewNOS0 == 0)
						{
							R_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									R_Jig = k;
									break;
								}

							}
						}
						R_Jigbangou = A_Supports[0][N + putting + 3 + R_Jig].Id;
					}
				}
			}

			//左手の対象を決める
			if (M_pattern[movetype].Move[hidarite][nowmove][target] == Oya)//対象製品が親部品
			{
				if (Oya2flag == 1)//基準部品が最初の部品の時
				{//2番目の部品が対象の部品になる
					L_use_parts = kumijun[line + 1].oya;
					L_use_object = OyaPnum;
				}
				else if (Oya2flag == 2)//基準部品が2番目の部品の時
				{//最初の部品が対象の部品になる
					L_use_parts = kumijun[line].oya;
					L_use_object = OyaPnum1;
				}
				else
				{
					L_use_parts = OyaPa;
					L_use_object = OyaPnum;
				}
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Ko)//対象製品が子部品
			{
				L_use_parts = KoPa;
				L_use_object = KoPnum;
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Tyukan)//対象製品が中間製品
			{
				L_use_parts = TyuPa;
				L_use_object = TyuPnum;
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Start_P)//手を初期位置に戻すとき、対象製品は使用する手
			{
				L_use_object = 2 * N - 1 + hidarite;
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Ko2)//両手2部品の時の左手で扱う子部品
			{
				L_use_parts = A_Objects[0][L_KoPnum].Id;
				L_use_object = L_KoPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].ko == L_use_parts)
					{
						L_TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							L_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									L_Jig = k;
									break;
								}

							}
						}
						L_Jigbangou = A_Supports[0][N + putting + 3 + L_Jig].Id;
						L_line = i;
					}
				}
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Oya2)//両手2部品の時の左手で扱う親部品
			{
				L_use_parts = A_Objects[0][L_OyaPnum].Id;
				L_use_object = L_OyaPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].oya == L_use_parts)
					{
						L_TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							L_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									L_Jig = k;
									break;
								}

							}
						}
						L_Jigbangou = A_Supports[0][N + putting + 3 + L_Jig].Id;
						L_line = i;
					}
				}
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Tyukan2)//両手2部品の時の左手で扱う中間製品部品
			{
				L_use_parts = A_Objects[0][L_TyuPnum].Id;
				L_use_object = L_TyuPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].tyukan == L_use_parts)
					{
						L_TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							L_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									L_Jig = k;
									break;
								}

							}
						}
						L_Jigbangou = A_Supports[0][N + putting + 3 + L_Jig].Id;
						L_line = i;
					}
				}
			}

			if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[hidarite][nowmove][move]) == nobasu)//右手と左手が同じ動作で伸ばすの時
			{
				//右手と左手の部品に回転があるときに必要、もしくは右手と左手にこの動作が指定されているとき
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{//Te = M_pattern[movetype].kobuhin[nowmove][Hand];
				//もともと治具に付いている部品(親部品)に手を伸ばす

					L_IchiX1 = A_Objects[0][2 * N - 1 + hidarite].IchiX;//使用する手の現在の位置
					L_IchiY1 = A_Objects[0][2 * N - 1 + hidarite].IchiY;
					L_IchiZ1 = A_Objects[0][2 * N - 1 + hidarite].IchiZ;
					L_IchiX2 = A_Objects[0][L_use_object].IchiX;
					L_IchiY2 = A_Objects[0][L_use_object].IchiY;
					L_IchiZ2 = A_Objects[0][L_use_object].IchiZ;

					R_IchiX1 = A_Objects[0][2 * N - 1 + migite].IchiX;//使用する手の現在の位置
					R_IchiY1 = A_Objects[0][2 * N - 1 + migite].IchiY;
					R_IchiZ1 = A_Objects[0][2 * N - 1 + migite].IchiZ;
					R_IchiX2 = A_Objects[0][R_use_object].IchiX;
					R_IchiY2 = A_Objects[0][R_use_object].IchiY;
					R_IchiZ2 = A_Objects[0][R_use_object].IchiZ;
					/*IchiX2 = A_Objects[0][OyaPnum].IchiX;
					IchiY2 = A_Objects[0][OyaPnum].IchiY;
					IchiZ2 = A_Objects[0][OyaPnum].IchiZ;*/

					WReach(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					R_IchiX1 = A_Objects[0][2 * N - 1 + migite].IchiX;//使用する手の現在の位置
					R_IchiY1 = A_Objects[0][2 * N - 1 + migite].IchiY;
					R_IchiZ1 = A_Objects[0][2 * N - 1 + migite].IchiZ;
					R_IchiX2 = A_Objects[0][R_use_object].IchiX;
					R_IchiY2 = A_Objects[0][R_use_object].IchiY;
					R_IchiZ2 = A_Objects[0][R_use_object].IchiZ;

					Reach(fp2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2, migite);

					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;

				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					L_IchiX1 = A_Objects[0][2 * N - 1 + hidarite].IchiX;//使用する手の現在の位置
					L_IchiY1 = A_Objects[0][2 * N - 1 + hidarite].IchiY;
					L_IchiZ1 = A_Objects[0][2 * N - 1 + hidarite].IchiZ;
					L_IchiX2 = A_Objects[0][L_use_object].IchiX;
					L_IchiY2 = A_Objects[0][L_use_object].IchiY;
					L_IchiZ2 = A_Objects[0][L_use_object].IchiZ;

					Reach(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, hidarite);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == hakobu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					//Te = M_pattern[movetype].kobuhin[nowmove][Hand];

					L_IchiX1 = A_Objects[0][2 * N - 1 + hidarite].IchiX;
					L_IchiY1 = A_Objects[0][2 * N - 1 + hidarite].IchiY;
					L_IchiZ1 = A_Objects[0][2 * N - 1 + hidarite].IchiZ;
					L_IchiX2 = A_Objects[1][L_use_object].IchiX;
					L_IchiY2 = A_Objects[1][L_use_object].IchiY;
					L_IchiZ2 = A_Objects[1][L_use_object].IchiZ;

					R_IchiX1 = A_Objects[0][2 * N - 1 + migite].IchiX;
					R_IchiY1 = A_Objects[0][2 * N - 1 + migite].IchiY;
					R_IchiZ1 = A_Objects[0][2 * N - 1 + migite].IchiZ;
					R_IchiX2 = A_Objects[1][R_use_object].IchiX;
					R_IchiY2 = A_Objects[1][R_use_object].IchiY;
					R_IchiZ2 = A_Objects[1][R_use_object].IchiZ;
					/*IchiX2 = A_Objects[1][TyuPnum].IchiX;
					IchiY2 = A_Objects[1][TyuPnum].IchiY;
					IchiZ2 = A_Objects[1][TyuPnum].IchiZ;*/

					WCarry(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2);//両手で運ぶ carry

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;

					A_Objects[0][R_use_object].IchiX = R_IchiX2;//部品の座標を更新
					A_Objects[0][R_use_object].IchiY = R_IchiY2;
					A_Objects[0][R_use_object].IchiZ = R_IchiZ2;
					A_Objects[0][L_use_object].IchiX = L_IchiX2;//部品の座標を更新
					A_Objects[0][L_use_object].IchiY = L_IchiY2;
					A_Objects[0][L_use_object].IchiZ = L_IchiZ2;
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					R_IchiX1 = A_Objects[0][2 * N - 1 + migite].IchiX;
					R_IchiY1 = A_Objects[0][2 * N - 1 + migite].IchiY;
					R_IchiZ1 = A_Objects[0][2 * N - 1 + migite].IchiZ;
					R_IchiX2 = A_Objects[1][R_use_object].IchiX;
					R_IchiY2 = A_Objects[1][R_use_object].IchiY;
					R_IchiZ2 = A_Objects[1][R_use_object].IchiZ;

					Carry(fp2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2, migite);

					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;

					A_Objects[0][R_use_object].IchiX = R_IchiX2;//部品の座標を更新
					A_Objects[0][R_use_object].IchiY = R_IchiY2;
					A_Objects[0][R_use_object].IchiZ = R_IchiZ2;

				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					L_IchiX1 = A_Objects[0][2 * N - 1 + hidarite].IchiX;
					L_IchiY1 = A_Objects[0][2 * N - 1 + hidarite].IchiY;
					L_IchiZ1 = A_Objects[0][2 * N - 1 + hidarite].IchiZ;
					L_IchiX2 = A_Objects[1][L_use_object].IchiX;
					L_IchiY2 = A_Objects[1][L_use_object].IchiY;
					L_IchiZ2 = A_Objects[1][L_use_object].IchiZ;

					Carry(fp2, L_IchiX1, L_IchiY1, R_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, hidarite);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					A_Objects[0][L_use_object].IchiX = L_IchiX2;//部品の座標を更新
					A_Objects[0][L_use_object].IchiY = L_IchiY2;
					A_Objects[0][L_use_object].IchiZ = L_IchiZ2;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == kumitateidou)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					hold_hands = migite;//部品を持っている手を記録
					/*IchiX1 = A_Objects[1][KoPnum].IchiX;
					IchiY1 = A_Objects[1][KoPnum].IchiY;
					IchiZ1 = A_Objects[1][KoPnum].IchiZ;*/
					L_IchiX1 = A_Objects[1][L_use_object].IchiX;
					L_IchiY1 = A_Objects[1][L_use_object].IchiY;
					L_IchiZ1 = A_Objects[1][L_use_object].IchiZ;

					R_IchiX1 = A_Objects[1][R_use_object].IchiX;
					R_IchiY1 = A_Objects[1][R_use_object].IchiY;
					R_IchiZ1 = A_Objects[1][R_use_object].IchiZ;

					if (kumijun[line].scene_type == oya1ko2 || kumijun[line].scene_type == oya2ko2)
					{
						if (R_line < L_line)
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
						else
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
					}
					else if (kumijun[line].scene_type == oya2ko1)
					{
						if (Oya2flag == 1)//組立順序の最初の部品が基準部品の場合
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
						else if (Oya2flag == 2 || Oya2flag == 3)
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
					}
					else
					{
						R_IchiX2 = KIdo_X;
						R_IchiY2 = KIdo_Y;
						R_IchiZ2 = KIdo_Z;

						L_IchiX2 = KIdo_X;
						L_IchiY2 = KIdo_Y;
						L_IchiZ2 = KIdo_Z;
					}

					WKumimove(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;

					//部品の座標の更新
					A_Objects[1][L_use_object].IchiX = L_IchiX2;
					A_Objects[1][L_use_object].IchiY = L_IchiX2;
					A_Objects[1][L_use_object].IchiZ = L_IchiX2;

					A_Objects[1][R_use_object].IchiX = R_IchiX2;
					A_Objects[1][R_use_object].IchiY = R_IchiY2;
					A_Objects[1][R_use_object].IchiZ = R_IchiZ2;
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					R_IchiX1 = A_Objects[1][R_use_object].IchiX;
					R_IchiY1 = A_Objects[1][R_use_object].IchiY;
					R_IchiZ1 = A_Objects[1][R_use_object].IchiZ;

					if (kumijun[line].scene_type == oya1ko2 || kumijun[line].scene_type == oya2ko2)
					{
						if (R_line < L_line)
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
						else
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
					}
					else if (kumijun[line].scene_type == oya2ko1)
					{
						if (Oya2flag == 1)//組立順序の最初の部品が基準部品の場合
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
						else if (Oya2flag == 2 || Oya2flag == 3)
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
					}
					else
					{
						R_IchiX2 = KIdo_X;
						R_IchiY2 = KIdo_Y;
						R_IchiZ2 = KIdo_Z;

						L_IchiX2 = KIdo_X;
						L_IchiY2 = KIdo_Y;
						L_IchiZ2 = KIdo_Z;
					}

					Kumimove(fp2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2, migite);

					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;
					A_Objects[1][R_use_object].IchiX = R_IchiX2;//部品の座標の更新
					A_Objects[1][R_use_object].IchiY = R_IchiY2;
					A_Objects[1][R_use_object].IchiZ = R_IchiZ2;
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					L_IchiX1 = A_Objects[1][L_use_object].IchiX;
					L_IchiY1 = A_Objects[1][L_use_object].IchiY;
					L_IchiZ1 = A_Objects[1][L_use_object].IchiZ;

					if (kumijun[line].scene_type == oya1ko2 || kumijun[line].scene_type == oya2ko2)
					{
						if (R_line < L_line)
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
						else
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
					}
					else if (kumijun[line].scene_type == oya2ko1)
					{
						if (Oya2flag == 1)//組立順序の最初の部品が基準部品の場合
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
						else if (Oya2flag == 2 || Oya2flag == 3)
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
					}
					else
					{
						R_IchiX2 = KIdo_X;
						R_IchiY2 = KIdo_Y;
						R_IchiZ2 = KIdo_Z;

						L_IchiX2 = KIdo_X;
						L_IchiY2 = KIdo_Y;
						L_IchiZ2 = KIdo_Z;
					}

					Kumimove(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, hidarite);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					//部品の座標の更新
					A_Objects[1][L_use_object].IchiX = L_IchiX2;
					A_Objects[1][L_use_object].IchiY = L_IchiX2;
					A_Objects[1][L_use_object].IchiZ = L_IchiX2;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == tsukeru)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					WFix(fp2, L_Jigbangou, R_Jigbangou, L_use_parts, R_use_parts);//付ける fix

					//治具と親部品の支えの関係をつくる
					A_Supports[1][3 + N + putting + R_Jig].Id = A_Jigus[R_Jig].Jnum;
					A_Supports[1][3 + N + putting + R_Jig].Flag = 1;

					A_Supports[1][3 + N + putting + L_Jig].Id = A_Jigus[L_Jig].Jnum;
					A_Supports[1][3 + N + putting + L_Jig].Flag = 1;

					for (k = 0; k < A_Supports[1][3 + N + putting + R_Jig].Length; k++)//治具と親部品の支えの関係をつくる(右手)
					{
						//A_Supports[0][Te].PId = use_parts;
						if (A_Supports[1][3 + N + putting + R_Jig].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
						{
							supportflug = 1;
							break;
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][3 + N + putting + R_Jig].PId[A_Supports[1][3 + N + putting + R_Jig].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + R_Jig].Length++;
							break;
						}
						else
						{
							supportflug = 0;
						}
					}

					for (k = 0; k < A_Supports[1][3 + N + putting + L_Jig].Length; k++)//治具と親部品の支えの関係をつくる(左手)
					{
						//A_Supports[0][Te].PId = use_parts;
						if (A_Supports[1][3 + N + putting + L_Jig].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
						{
							supportflug = 1;
							break;
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][3 + N + putting + L_Jig].PId[A_Supports[1][3 + N + putting + L_Jig].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + L_Jig].Length++;
							break;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					Fix(fp2, R_Jigbangou, R_use_parts, migite);//付ける fix

					//治具と親部品の支えの関係をつくる
					A_Supports[1][3 + N + putting + R_Jig].Id = A_Jigus[R_Jig].Jnum;
					A_Supports[1][3 + N + putting + R_Jig].Flag = 1;
					for (k = 0; k < A_Supports[1][3 + N + putting + R_Jig].Length; k++)//治具と親部品の支えの関係をつくる(右手)
					{
						//A_Supports[0][Te].PId = use_parts;
						if (A_Supports[1][3 + N + putting + R_Jig].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
						{
							supportflug = 1;
							break;
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][3 + N + putting + R_Jig].PId[A_Supports[1][3 + N + putting + R_Jig].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + R_Jig].Length++;
							break;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					Fix(fp2, L_Jigbangou, L_use_parts, hidarite);//付ける fix
					A_Supports[1][3 + N + putting + L_Jig].Id = A_Jigus[L_Jig].Jnum;
					A_Supports[1][3 + N + putting + L_Jig].Flag = 1;
					for (k = 0; k < A_Supports[1][3 + N + putting + L_Jig].Length; k++)//治具と親部品の支えの関係をつくる(左手)
					{
						//A_Supports[0][Te].PId = use_parts;
						if (A_Supports[1][3 + N + putting + L_Jig].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
						{
							supportflug = 1;
							break;
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][3 + N + putting + L_Jig].PId[A_Supports[1][3 + N + putting + L_Jig].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + L_Jig].Length++;
							break;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == tsukamu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					WGripping(fp2, L_use_parts, R_use_parts);//掴む
					//Gripping(fp2, TyuPa, Te);//掴む

					if (A_Supports[1][hidarite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][hidarite].Flag = 1;
						A_Supports[1][hidarite].PId[0] = L_use_parts;
						A_Supports[1][hidarite].Length++;
					}
					else
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;
						A_Supports[1][hidarite].Flag = 1;
						for (k = 0; k < A_Supports[1][hidarite].Length; k++)
						{
							//A_Supports[0][hidarite].PId = use_parts;
							if (A_Supports[1][hidarite].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][hidarite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

					if (A_Supports[1][migite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][migite].Flag = 1;
						A_Supports[1][migite].PId[0] = R_use_parts;
						A_Supports[1][migite].Length++;
					}
					else
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;
						A_Supports[1][migite].Flag = 1;
						for (k = 0; k < A_Supports[1][migite].Length; k++)
						{
							//A_Supports[0][migite].PId = use_parts;
							if (A_Supports[1][migite].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][migite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					Gripping(fp2, R_use_parts, migite);
					if (A_Supports[1][migite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][migite].Flag = 1;
						A_Supports[1][migite].PId[0] = R_use_parts;
						A_Supports[1][migite].Length++;
					}
					else
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;
						A_Supports[1][migite].Flag = 1;
						for (k = 0; k < A_Supports[1][migite].Length; k++)
						{
							//A_Supports[0][migite].PId = use_parts;
							if (A_Supports[1][migite].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][migite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					Gripping(fp2, L_use_parts, hidarite);
					if (A_Supports[1][hidarite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][hidarite].Flag = 1;
						A_Supports[1][hidarite].PId[0] = L_use_parts;
						A_Supports[1][hidarite].Length++;
					}
					else
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;
						A_Supports[1][hidarite].Flag = 1;
						for (k = 0; k < A_Supports[1][hidarite].Length; k++)
						{
							//A_Supports[0][hidarite].PId = use_parts;
							if (A_Supports[1][hidarite].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][hidarite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == tsukamitoru)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					//右側の部品に関して
					if (JigKobuhin == R_use_parts || JigKobuhin2 == R_use_parts || ChangeJig == R_use_parts || ChangeJig2 == R_use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == R_use_parts)
								{
									BeforeJigR = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					//左側の部品に関して
					if (JigKobuhin == L_use_parts || JigKobuhin2 == L_use_parts || ChangeJig == L_use_parts || ChangeJig2 == L_use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == L_use_parts)
								{
									BeforeJigL = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					for (i = 0; i < Bboxnum; i++)
					{
						for (k = 0; k < A_Supports[1][i + 2].Length; k++)
						{
							if (A_Supports[1][i + 2].PId[k] == L_use_parts || A_Supports[1][i + 2].PId[k] == R_use_parts) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
							   //A_Supports[1][i + 2].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i + 2].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i + 2].Length;
								A_Supports[1][i + 2].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if ((temp[supportlength] != L_use_parts && A_Supports[1][i + 2].PId[k] == L_use_parts) ||
										(temp[supportlength] != R_use_parts && A_Supports[1][i + 2].PId[k] == R_use_parts))//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i + 2].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i + 2].Length == 0)
								{
									A_Supports[1][i + 2].Flag = 0;
								}
								break;
							}
						}
					}
					for (i = 0; i < putting; i++)
					{//中間製品置き場からとるとき、支えの関係を切る
						//if (A_Supports[0][3 + N + i].PId == OyaPa)
						/*if (A_Supports[0][3 + N + i].PId == use_parts)
						{
							A_Supports[1][3 + N + i].Flag = 0;
							A_Supports[1][3 + N + i].PId = 0;
						}*/
						for (k = 0; k < A_Supports[1][3 + N + i].Length; k++)
						{
							if (A_Supports[1][3 + N + i].PId[k] == L_use_parts || A_Supports[1][3 + N + i].PId[k] == R_use_parts)//右手で扱う部品か左手で扱う部品の時
							{
								//A_Supports[1][3 + N + i].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][3 + N + i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][3 + N + i].Length;
								A_Supports[1][3 + N + i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if ((temp[supportlength] != L_use_parts && A_Supports[1][3 + N + i].PId[k] == L_use_parts) ||
										(temp[supportlength] != R_use_parts && A_Supports[1][3 + N + i].PId[k] == R_use_parts))//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = temp[supportlength];//データの移行
										A_Supports[1][3 + N + i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][3 + N + i].Length == 0)
								{
									A_Supports[1][3 + N + i].Flag = 0;
								}
								break;
							}
						}
					}

					if (A_Supports[1][hidarite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][hidarite].Flag = 1;
						A_Supports[1][hidarite].PId[0] = L_use_parts;
						A_Supports[1][hidarite].Length++;
					}
					else
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;
						A_Supports[1][hidarite].Flag = 1;
						for (k = 0; k < A_Supports[1][hidarite].Length; k++)
						{
							//A_Supports[0][hidarite].PId = use_parts;
							if (A_Supports[1][hidarite].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][hidarite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

					if (A_Supports[1][migite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][migite].Flag = 1;
						A_Supports[1][migite].PId[0] = R_use_parts;
						A_Supports[1][migite].Length++;
					}
					else
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;
						A_Supports[1][migite].Flag = 1;
						for (k = 0; k < A_Supports[1][migite].Length; k++)
						{
							//A_Supports[0][migite].PId = use_parts;
							if (A_Supports[1][migite].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][migite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

					WGrip(fp2, L_use_parts, R_use_parts, BeforeJigL, BeforeJigR);
					BeforeJigL = BeforeJigR = 0;
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					if (JigKobuhin == R_use_parts || JigKobuhin2 == R_use_parts || ChangeJig == R_use_parts || ChangeJig2 == R_use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == R_use_parts)
								{
									BeforeJigR = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					for (i = 0; i < Bboxnum; i++)
					{
						for (k = 0; k < A_Supports[1][i + 2].Length; k++)
						{
							if (A_Supports[1][i + 2].PId[k] == R_use_parts) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
							   //A_Supports[1][i + 2].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i + 2].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i + 2].Length;
								A_Supports[1][i + 2].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != R_use_parts && A_Supports[1][i + 2].PId[k] == R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i + 2].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i + 2].Length == 0)
								{
									A_Supports[1][i + 2].Flag = 0;
								}
								break;
							}
						}
					}
					for (i = 0; i < putting; i++)
					{//中間製品置き場からとるとき、支えの関係を切る
						//if (A_Supports[0][3 + N + i].PId == OyaPa)
						/*if (A_Supports[0][3 + N + i].PId == use_parts)
						{
							A_Supports[1][3 + N + i].Flag = 0;
							A_Supports[1][3 + N + i].PId = 0;
						}*/
						for (k = 0; k < A_Supports[1][3 + N + i].Length; k++)
						{
							if (A_Supports[1][3 + N + i].PId[k] == R_use_parts)//右手で扱う部品か左手で扱う部品の時
							{
								//A_Supports[1][3 + N + i].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][3 + N + i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][3 + N + i].Length;
								A_Supports[1][3 + N + i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != R_use_parts && A_Supports[1][3 + N + i].PId[k] == R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = temp[supportlength];//データの移行
										A_Supports[1][3 + N + i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][3 + N + i].Length == 0)
								{
									A_Supports[1][3 + N + i].Flag = 0;
								}
								break;
							}
						}
					}
					if (A_Supports[1][migite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][migite].Flag = 1;
						A_Supports[1][migite].PId[0] = use_parts;
						A_Supports[1][migite].Length++;
					}
					else
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;
						A_Supports[1][migite].Flag = 1;
						for (k = 0; k < A_Supports[1][migite].Length; k++)
						{
							//A_Supports[0][migite].PId = use_parts;
							if (A_Supports[1][migite].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][migite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
					Grip(fp2, R_use_parts, BeforeJigR, migite);
					BeforeJigR = 0;
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					if (JigKobuhin == L_use_parts || JigKobuhin2 == L_use_parts || ChangeJig == L_use_parts || ChangeJig2 == L_use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == L_use_parts)
								{
									BeforeJigL = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					for (i = 0; i < Bboxnum; i++)
					{
						for (k = 0; k < A_Supports[1][i + 2].Length; k++)
						{
							if (A_Supports[1][i + 2].PId[k] == L_use_parts) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
							   //A_Supports[1][i + 2].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i + 2].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i + 2].Length;
								A_Supports[1][i + 2].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != L_use_parts && A_Supports[1][i + 2].PId[k] == L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i + 2].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i + 2].Length == 0)
								{
									A_Supports[1][i + 2].Flag = 0;
								}
								break;
							}
						}
					}
					for (i = 0; i < putting; i++)
					{//中間製品置き場からとるとき、支えの関係を切る
						//if (A_Supports[0][3 + N + i].PId == OyaPa)
						/*if (A_Supports[0][3 + N + i].PId == use_parts)
						{
							A_Supports[1][3 + N + i].Flag = 0;
							A_Supports[1][3 + N + i].PId = 0;
						}*/
						for (k = 0; k < A_Supports[1][3 + N + i].Length; k++)
						{
							if (A_Supports[1][3 + N + i].PId[k] == L_use_parts)//右手で扱う部品か左手で扱う部品の時
							{
								//A_Supports[1][3 + N + i].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][3 + N + i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][3 + N + i].Length;
								A_Supports[1][3 + N + i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != L_use_parts && A_Supports[1][3 + N + i].PId[k] == L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = temp[supportlength];//データの移行
										A_Supports[1][3 + N + i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][3 + N + i].Length == 0)
								{
									A_Supports[1][3 + N + i].Flag = 0;
								}
								break;
							}
						}
					}

					if (A_Supports[1][hidarite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][hidarite].Flag = 1;
						A_Supports[1][hidarite].PId[0] = use_parts;
						A_Supports[1][hidarite].Length++;
					}
					else
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;
						A_Supports[1][hidarite].Flag = 1;
						for (k = 0; k < A_Supports[1][hidarite].Length; k++)
						{
							//A_Supports[0][hidarite].PId = use_parts;
							if (A_Supports[1][hidarite].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][hidarite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

					Grip(fp2, L_use_parts, BeforeJigL, hidarite);
					BeforeJigL = 0;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == okihanasu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					Wleave(fp2, L_use_parts, R_use_parts);//置き放す leave
					//leave(fp2, TyuPa, Te);//置き放す leave

					for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
					{//左手、右手、冶具の支えの関係を切る
						//if (A_Supports[1][i].PId == TyuPa)
						f = A_Supports[1][i].Length;//支えている数を保存
						for (k = 0; k < f; k++)
						{
							/*if (A_Supports[1][i].PId == use_parts)
							{
								A_Supports[1][i].Flag = 0;
								A_Supports[1][i].PId = 0;
							}*/
							if (A_Supports[1][i].PId[k] == L_use_parts || A_Supports[1][i].PId[k] == R_use_parts)//組立後に部品を支えていてはいけないのでA_Supports[1][i].PId
							{
								for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i].Length;
								A_Supports[1][i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if ((temp[supportlength] != L_use_parts && A_Supports[1][3 + N + i].PId[k] == L_use_parts) ||
										(temp[supportlength] != R_use_parts && A_Supports[1][3 + N + i].PId[k] == R_use_parts))//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i].PId[A_Supports[1][i].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i].Length == 0)
								{
									A_Supports[1][i].Flag = 0;
								}
								break;
							}
						}

						if (i == Tnum - 1 + N + 3)
						{//中間製品置き場と中間製品の支えの関係を作る
							A_Supports[1][i].Flag = 1;
							//A_Supports[1][i].PId = use_parts;
							//A_Supports[1][i].PId = TyuPa;
							for (k = 0; k < A_Supports[1][i].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][i].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = supportflug + 1;//左手で扱う部品を持っている時は＋1する
								}
								else if (A_Supports[1][i].PId[k] == R_use_parts)
								{
									supportflug = supportflug + 2;//右手で扱う部品を持っている時は＋2する
								}
							}
							if (supportflug == 0)//まだ支えられていない時
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = L_use_parts;//中間製品置き場と左手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;

								A_Supports[1][i].PId[A_Supports[1][i].Length] = R_use_parts;//中間製品置き場と右手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else if (supportflug == 1)//左手で扱う部品がすでに支えられているとき(一応の作業)
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = R_use_parts;//中間製品置き場と中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else if (supportflug == 2)//右手で扱う部品がすでに支えられているとき(一応の作業)
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = L_use_parts;//中間製品置き場と左手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else
							{
								supportflug = 0;
							}
						}
					}

				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					leave(fp2, R_use_parts, migite);
					for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
					{//右手、冶具の支えの関係を切る
						//if (A_Supports[1][i].PId == TyuPa)
						f = A_Supports[1][i].Length;//支えている数を保存
						for (k = 0; k < f; k++)
						{
							/*if (A_Supports[1][i].PId == use_parts)
							{
								A_Supports[1][i].Flag = 0;
								A_Supports[1][i].PId = 0;
							}*/
							if (A_Supports[1][i].PId[k] == R_use_parts)//組立後に部品を支えていてはいけないのでA_Supports[1][i].PId
							{
								for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i].Length;
								A_Supports[1][i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != R_use_parts && A_Supports[1][3 + N + i].PId[k] == R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i].PId[A_Supports[1][i].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i].Length == 0)
								{
									A_Supports[1][i].Flag = 0;
								}
								break;
							}
						}

						if (i == Tnum - 1 + N + 3)
						{//中間製品置き場と中間製品の支えの関係を作る
							A_Supports[1][i].Flag = 1;
							//A_Supports[1][i].PId = use_parts;
							//A_Supports[1][i].PId = TyuPa;
							for (k = 0; k < A_Supports[1][i].Length; k++)
							{
								if (A_Supports[1][i].PId[k] == R_use_parts)
								{
									supportflug = supportflug + 2;//右手で扱う部品を持っている時は＋2する
								}
							}
							if (supportflug == 0)//まだ支えられていない時
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = R_use_parts;//中間製品置き場と右手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else
							{
								supportflug = 0;
							}
						}
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					leave(fp2, L_use_parts, hidarite);
					for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
					{//左手、右手、冶具の支えの関係を切る
						//if (A_Supports[1][i].PId == TyuPa)
						f = A_Supports[1][i].Length;//支えている数を保存
						for (k = 0; k < f; k++)
						{
							/*if (A_Supports[1][i].PId == use_parts)
							{
								A_Supports[1][i].Flag = 0;
								A_Supports[1][i].PId = 0;
							}*/
							if (A_Supports[1][i].PId[k] == L_use_parts)//組立後に部品を支えていてはいけないのでA_Supports[1][i].PId
							{
								for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i].Length;
								A_Supports[1][i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != L_use_parts && A_Supports[1][3 + N + i].PId[k] == L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i].PId[A_Supports[1][i].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i].Length == 0)
								{
									A_Supports[1][i].Flag = 0;
								}
								break;
							}
						}

						if (i == Tnum - 1 + N + 3)
						{//中間製品置き場と中間製品の支えの関係を作る
							A_Supports[1][i].Flag = 1;
							//A_Supports[1][i].PId = use_parts;
							//A_Supports[1][i].PId = TyuPa;
							for (k = 0; k < A_Supports[1][i].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][i].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = supportflug + 1;//左手で扱う部品を持っている時は＋1する
								}
							}
							if (supportflug == 0)//まだ支えられていない時
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = L_use_parts;//中間製品置き場と左手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else
							{
								supportflug = 0;
							}
						}
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == hanasu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					WRelease(fp2, L_use_parts, R_use_parts);//両手で放すrelease

					for (supportlength = 0; supportlength < A_Supports[1][hidarite].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][hidarite].PId[supportlength];//値を移す
						A_Supports[1][hidarite].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][hidarite].Length;
					A_Supports[1][hidarite].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != L_use_parts)
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = temp[k];
							A_Supports[1][hidarite].Length++;
						}
					}
					if (A_Supports[1][hidarite].Length == 0)
					{
						A_Supports[1][hidarite].Flag = 0;
					}

					for (supportlength = 0; supportlength < A_Supports[1][migite].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][migite].PId[supportlength];//値を移す
						A_Supports[1][migite].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][migite].Length;
					A_Supports[1][migite].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != use_parts)
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = temp[k];
							A_Supports[1][migite].Length++;
						}
					}
					if (A_Supports[1][migite].Length == 0)
					{
						A_Supports[1][migite].Flag = 0;
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					Release(fp2, R_use_parts, migite);//右手で放すrelease
					for (supportlength = 0; supportlength < A_Supports[1][migite].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][migite].PId[supportlength];//値を移す
						A_Supports[1][migite].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][migite].Length;
					A_Supports[1][migite].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != use_parts)
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = temp[k];
							A_Supports[1][migite].Length++;
						}
					}
					if (A_Supports[1][migite].Length == 0)
					{
						A_Supports[1][migite].Flag = 0;
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					Release(fp2, L_use_parts, hidarite);//左手で放すrelease
					for (supportlength = 0; supportlength < A_Supports[1][hidarite].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][hidarite].PId[supportlength];//値を移す
						A_Supports[1][hidarite].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][hidarite].Length;
					A_Supports[1][hidarite].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != L_use_parts)
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = temp[k];
							A_Supports[1][hidarite].Length++;
						}
					}
					if (A_Supports[1][hidarite].Length == 0)
					{
						A_Supports[1][hidarite].Flag = 0;
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == kumitateru)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					oya_hoji = A_Jigus[Jig].Jnum;
					if (R_line < L_line)
					{
						Kumitate(fp2, A_Supports[1][N + putting + 3 + R_Jig].Id, TyuPa, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
						Kumitate(fp2, A_Supports[1][N + putting + 3 + L_Jig].Id, TyuPa2, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
					}
					else
					{
						Kumitate(fp2, A_Supports[1][N + putting + 3 + L_Jig].Id, TyuPa, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
						Kumitate(fp2, A_Supports[1][N + putting + 3 + R_Jig].Id, TyuPa2, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					oya_hoji = A_Jigus[Jig].Jnum;
					if (R_line < L_line)
					{
						Kumitate(fp2, A_Supports[1][N + putting + 3 + R_Jig].Id, TyuPa, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[L_line].jig - 1].Id, TyuPa2, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
					}
					else
					{
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[L_line].jig - 1].Id, TyuPa, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
						Kumitate(fp2, A_Supports[1][N + putting + 3 + R_Jig].Id, TyuPa2, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
					}

				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					oya_hoji = A_Jigus[Jig].Jnum;
					if (R_line < L_line)
					{
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[R_line].jig - 1].Id, TyuPa, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
						Kumitate(fp2, A_Supports[1][N + putting + 3 + L_Jig].Id, TyuPa2, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
					}
					else
					{
						Kumitate(fp2, A_Supports[1][N + putting + 3 + L_Jig].Id, TyuPa, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[R_line].jig - 1].Id, TyuPa2, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == motinaosu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					L_Turn0X = A_Objects[0][L_use_object].DirX;
					L_Turn1X = A_Objects[1][L_use_object].DirX;
					L_Turn0Y = A_Objects[0][L_use_object].DirY;
					L_Turn1Y = A_Objects[1][L_use_object].DirY;
					L_Turn0Z = A_Objects[0][L_use_object].DirZ;
					L_Turn1Z = A_Objects[1][L_use_object].DirZ;

					R_Turn0X = A_Objects[0][R_use_object].DirX;
					R_Turn1X = A_Objects[1][R_use_object].DirX;
					R_Turn0Y = A_Objects[0][R_use_object].DirY;
					R_Turn1Y = A_Objects[1][R_use_object].DirY;
					R_Turn0Z = A_Objects[0][R_use_object].DirZ;
					R_Turn1Z = A_Objects[1][R_use_object].DirZ;

					WTurn(fp2, L_use_parts, L_Turn0X, L_Turn0Y, L_Turn0Z, L_Turn1X, L_Turn1Y, L_Turn1Z, R_use_parts, R_Turn0X, R_Turn0Y, R_Turn0Z, R_Turn1X, R_Turn1Y, R_Turn1Z);//左手で回転させるturn
					if (M_pattern[movetype].Move[migite][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(R_Turn0X - R_Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(R_Turn0Y - R_Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(R_Turn0Z - R_Turn1Z) + Oyakaitenkakudo;
					}
					if (M_pattern[movetype].Move[hidarite][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(L_Turn0X - L_Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(L_Turn0Y - L_Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(L_Turn0Z - L_Turn1Z) + Oyakaitenkakudo;
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					R_Turn0X = A_Objects[0][R_use_object].DirX;
					R_Turn1X = A_Objects[1][R_use_object].DirX;
					R_Turn0Y = A_Objects[0][R_use_object].DirY;
					R_Turn1Y = A_Objects[1][R_use_object].DirY;
					R_Turn0Z = A_Objects[0][R_use_object].DirZ;
					R_Turn1Z = A_Objects[1][R_use_object].DirZ;

					Turn(fp2, R_use_parts, R_Turn0X, R_Turn0Y, R_Turn0Z, R_Turn1X, R_Turn1Y, R_Turn1Z, migite);//回転させるturn
					if (M_pattern[movetype].Move[migite][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(R_Turn0X - R_Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(R_Turn0Y - R_Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(R_Turn0Z - R_Turn1Z) + Oyakaitenkakudo;
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					L_Turn0X = A_Objects[0][L_use_object].DirX;
					L_Turn1X = A_Objects[1][L_use_object].DirX;
					L_Turn0Y = A_Objects[0][L_use_object].DirY;
					L_Turn1Y = A_Objects[1][L_use_object].DirY;
					L_Turn0Z = A_Objects[0][L_use_object].DirZ;
					L_Turn1Z = A_Objects[1][L_use_object].DirZ;
					Turn(fp2, L_use_parts, L_Turn0X, L_Turn0Y, L_Turn0Z, L_Turn1X, L_Turn1Y, L_Turn1Z, hidarite);
					if (M_pattern[movetype].Move[hidarite][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(L_Turn0X - L_Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(L_Turn0Y - L_Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(L_Turn0Z - L_Turn1Z) + Oyakaitenkakudo;
					}
				}
			}
		}
	}
	for (i = 0; i < 2; i++)
	{
		//手の最終座標を合わせる
		A_Objects[1][2 * N - 1 + i].IchiX = A_Objects[0][2 * N - 1 + i].IchiX;
		A_Objects[1][2 * N - 1 + i].IchiY = A_Objects[0][2 * N - 1 + i].IchiY;
		A_Objects[1][2 * N - 1 + i].IchiZ = A_Objects[0][2 * N - 1 + i].IchiZ;
	}
	if (kumijun[line].kougu != 0)//工具を用いる時
	{
		A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiX = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiX;//工具の座標を更新
		A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiY = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY;
		A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY;
	}
}

void karioki_to_kumitatemae(FILE* fp2, int line, int movetype)
{
	int i = 0, R_length = 0, L_length = 0, length = 0, /*movetype = 0,*/ Te = 0, nowmove = 0, Jig = 0;
	int OyaPa, KoPa, TyuPa, Jigbangou = 0;//親部品番号,子部品番号,中間製品
	double IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Turn0X, Turn0Y, Turn0Z, Turn1X, Turn1Y, Turn1Z;
	int Oyanum = 0;//親部品が何番目にあるか
	int use_parts = 0/*使用する部品番号*/, use_object = 0/*使用する部品がobjectでどこにあるか*/;
	int R_use_parts = 0/*右手で使用する部品番号*/, R_use_object = 0;/*右手で使用する部品がobjectでどこにあるか*/
	int L_use_parts = 0/*左手で使用する部品番号*/, L_use_object = 0;/*左手で使用する部品がobjectでどこにあるか*/
	double R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2, R_Turn0X, R_Turn0Y, R_Turn0Z, R_Turn1X, R_Turn1Y, R_Turn1Z;
	double L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, L_Turn0X, L_Turn0Y, L_Turn0Z, L_Turn1X, L_Turn1Y, L_Turn1Z;
	int temp[MaxSupport], templength = 0;

	int R_Jig = 0, L_Jig = 0, R_Jigbangou = 0, L_Jigbangou = 0, R_TyuPa = 0, L_TyuPa = 0, TyuPa2 = 0, R_line = 0/*両手の時右手の組付けが一行目か二行目かどうかを保管*/, L_line = 0/*両手の時右手の組付けが一行目か二行目かどうかを保管*/;
	int supportlength = 0, k = 0, supportflug = 0, f = 0;
	int KouguBnum = 0, Kougunum = 0, KouguPnum = 0;//KouguBnum：レイアウト情報での工具の番号、Kougunum：工具番号,KouguPnum：工具がobjectsでどこにあるか
	int ChangeKouguBnum = 0, ChangeKougunum = 0, ChangeKouguPnum = 0;//ChangeKouguBnum：レイアウト情報での交換する工具の番号、ChangeKougunum：交換する工具番号,ChangeKouguPnum：交換する工具がobjectsでどこにあるか
	int TempKougunum = 0;
	int BeforeJig = 0;
	int BeforeJigR = 0, BeforeJigL = 0;

	TyuPa2 = kumijun[line + 1].tyukan;

	R_length = M_pattern[movetype].length[migite];
	L_length = M_pattern[movetype].length[hidarite];
	KoPa = kumijun[line].ko;
	OyaPa = kumijun[line].oya;
	TyuPa = kumijun[line].tyukan;
	if (NewNOS0 == 0)
	{
		Jig = kumijun[line].jig - 1;
		Kougunum = kumijun[line].kougu - 1;
		ChangeKougunum = kumijun[line - 1].kougu - 1;
	}
	else
	{
		for (i = 0; i < Jigu; i++)
		{
			if (A_Objects[0][3 * N + 2 + i + putting].Id == kumijun[line].jig)
			{
				Jig = i;
				break;
			}
		}
		for (i = 0; i < Kougu; i++)
		{
			if (A_Objects[0][3 * N + 2 + i + putting + Jigu].Id == kumijun[line].kougu)
			{
				Kougunum = i;
				break;
			}
		}
		for (i = 0; i < Kougu; i++)
		{
			if (A_Objects[0][3 * N + 2 + i + putting + Jigu].Id == kumijun[line - 1].kougu)
			{
				ChangeKougunum = i;
				break;
			}
		}
	}
	Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
	//Kougunum = kumijun[line].kougu;
	KouguBnum = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].Id;
	//ChangeKougunum = kumijun[line-1].kougu;
	ChangeKouguBnum = A_Objects[0][3 * N + 2 + ChangeKougunum + putting + Jigu].Id;

	if (R_length > L_length)
	{
		length = R_length;
	}
	else
	{
		length = L_length;
	}
	for (nowmove = 0; nowmove <= length; nowmove++)
	{
		if (M_pattern[movetype].Move[migite][nowmove][move] != none && M_pattern[movetype].Move[hidarite][nowmove][move] != none)//右手左手両方に同時に動作がある時
		{
			Te = ryoute;
		}
		else if (M_pattern[movetype].Move[migite][nowmove][move] != none)//右手に作業がある時
		{
			Te = migite;
		}
		else if (M_pattern[movetype].Move[hidarite][nowmove][move] != none)//左手に動作がある時
		{
			Te = hidarite;
		}

		//どの部品を対象とするかを調べる
		if (Te == migite || Te == hidarite)//両手で同時に作業をしない時
		{
			if (M_pattern[movetype].Move[Te][nowmove][target] == Oya)//対象製品が親部品
			{
				if (Oya2flag == 1)//基準部品が最初の部品の時
				{//2番目の部品が対象の部品になる
					use_parts = kumijun[line + 1].oya;
					use_object = OyaPnum;
				}
				else if (Oya2flag == 2)//基準部品が2番目の部品の時
				{//最初の部品が対象の部品になる
					use_parts = kumijun[line].oya;
					use_object = OyaPnum1;
				}
				else
				{
					use_parts = OyaPa;
					if (kumijun[line].scene_type == oya1ko2)
					{
						use_object = OyaPnum1;
					}
					else
					{
						use_object = OyaPnum;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Ko)//対象製品が子部品
			{
				use_parts = KoPa;
				use_object = KoPnum;
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Tyukan)//対象製品が中間製品
			{
				use_parts = TyuPa;
				use_object = TyuPnum;
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Start_P)//手を初期位置に戻すとき、対象製品は使用する手
			{
				use_object = 2 * N - 1 + Te;
			}

			else if (M_pattern[movetype].Move[Te][nowmove][target] == Ko1)//両手2部品の時の右手で扱う子部品
			{
				use_parts = A_Objects[0][R_KoPnum].Id;
				use_object = R_KoPnum;
				if (Oya2flag == 2)
				{
					use_object = KoPnum1;
				}
				else if (Oya2flag == 1)
				{
					use_object = KoPnum1;
				}
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].ko == R_use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						OyaPa = kumijun[i].oya;
						KoPa = kumijun[i].ko;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Oya1)//両手2部品の時の右手で扱う親部品
			{
				use_parts = A_Objects[0][R_OyaPnum].Id;
				use_object = R_OyaPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].oya == R_use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Tyukan1)//両手2部品の時の右手で扱う中間製品部品
			{
				use_parts = A_Objects[0][R_TyuPnum].Id;
				use_object = R_TyuPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].tyukan == use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Ko2)//両手2部品の時の左手で扱う子部品
			{
				use_parts = A_Objects[0][L_KoPnum].Id;
				use_object = L_KoPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].ko == use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						OyaPa = kumijun[i].oya;
						KoPa = kumijun[i].ko;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[line].jig - 1;
						}
						else
						{
							for (i = 0; i < Jigu; i++)
							{
								if (A_Objects[0][3 * N + 2 + i + putting].Id == kumijun[line].jig)
								{
									Jig = i;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Oya2)//両手2部品の時の左手で扱う親部品
			{
				use_parts = A_Objects[0][L_OyaPnum].Id;
				use_object = L_OyaPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].oya == use_parts)
					{
						OyaPa = kumijun[i].oya;
						KoPa = kumijun[line].ko;
						TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Tyukan2)//両手2部品の時の左手で扱う中間製品部品
			{
				use_parts = A_Objects[0][L_TyuPnum].Id;
				use_object = L_TyuPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].tyukan == L_use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)
			{
				use_parts = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].Id;
				use_object = 3 * N + 2 + Kougunum + putting + Jigu;
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == ChangeKOUGU)
			{
				use_parts = A_Objects[0][3 * N + 2 + ChangeKougunum + putting + Jigu].Id;
				use_object = 3 * N + 2 + ChangeKougunum + putting + Jigu;
			}

			if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == nobasu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{//Te = M_pattern[movetype].kobuhin[nowmove][Hand];
				//もともと治具に付いている部品(親部品)に手を伸ばす
					IchiX1 = A_Objects[0][2 * N - 1 + Te].IchiX;//使用する手の現在の位置
					IchiY1 = A_Objects[0][2 * N - 1 + Te].IchiY;
					IchiZ1 = A_Objects[0][2 * N - 1 + Te].IchiZ;
					if (M_pattern[movetype].Move[Te][nowmove][target] == Start_P)
					{
						IchiX2 = A_Objects[1][use_object].IchiX;
						IchiY2 = A_Objects[1][use_object].IchiY;
						IchiZ2 = A_Objects[1][use_object].IchiZ;
					}
					else
					{
						IchiX2 = A_Objects[0][use_object].IchiX;
						IchiY2 = A_Objects[0][use_object].IchiY;
						IchiZ2 = A_Objects[0][use_object].IchiZ;
					}
					/*IchiX2 = A_Objects[0][OyaPnum].IchiX;
					IchiY2 = A_Objects[0][OyaPnum].IchiY;
					IchiZ2 = A_Objects[0][OyaPnum].IchiZ;*/

					Reach(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);

					A_Objects[0][2 * N - 1 + Te].IchiX = IchiX2;//手の座標を更新
					A_Objects[0][2 * N - 1 + Te].IchiY = IchiY2;
					A_Objects[0][2 * N - 1 + Te].IchiZ = IchiZ2;
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == tsukamu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = Te;//部品を持っている手を記録
					if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)//対象が工具の時は工具を使用していることを記録しておく
					{
						Kouguflag = KouguBnum;
					}
					Gripping(fp2, use_parts, Te);//掴む
					//Gripping(fp2, TyuPa, Te);//掴む
					if (A_Supports[1][Te].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][Te].Id = A_Hands[Te].Hnum;//部品と手の支えの関係をつくる
						A_Supports[1][Te].Flag = 1;
						A_Supports[1][Te].PId[0] = use_parts;
						A_Supports[1][Te].Length++;
					}
					else
					{
						A_Supports[1][Te].Id = A_Hands[Te].Hnum;
						A_Supports[1][Te].Flag = 1;
						for (k = 0; k < A_Supports[1][Te].Length; k++)
						{
							//A_Supports[0][Te].PId = use_parts;
							if (A_Supports[1][Te].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][Te].PId[A_Supports[1][Te].Length] = use_parts;//部品と手の支えの関係をつくる
							A_Supports[1][Te].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
					//A_Supports[1][Te].PId = TyuPa;
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == tsukamitoru)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = Te;//部品を持っている手を記録
					if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)//対象が工具の時は工具を使用していることを記録しておく
					{
						Kouguflag = KouguBnum;
					}

					if (JigKobuhin == use_parts || JigKobuhin2 == use_parts || ChangeJig == use_parts || ChangeJig2 == use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == use_parts)
								{
									BeforeJig = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					//部品箱の支えの関係を切る
					for (i = 0; i < Bboxnum; i++)
					{
						for (k = 0; k < A_Supports[1][i + 2].Length; k++)
						{
							if (A_Supports[1][i + 2].PId[k] == use_parts) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
							   //A_Supports[1][i + 2].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i + 2].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i + 2].Length;
								A_Supports[1][i + 2].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i + 2].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i + 2].Length == 0)
								{
									A_Supports[1][i + 2].Flag = 0;
								}
								break;
							}
						}
					}
					for (i = 0; i < putting; i++)
					{//中間製品置き場からとるとき、支えの関係を切る
						//if (A_Supports[0][3 + N + i].PId == OyaPa)
						/*if (A_Supports[0][3 + N + i].PId == use_parts)
						{
							A_Supports[1][3 + N + i].Flag = 0;
							A_Supports[1][3 + N + i].PId = 0;
						}*/
						for (k = 0; k < A_Supports[1][3 + N + i].Length; k++)
						{
							if (A_Supports[1][3 + N + i].PId[k] == use_parts) {//A_Supports[][0],A_Supports[][1]には
							   //A_Supports[1][3 + N + i].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][3 + N + i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][3 + N + i].Length;
								A_Supports[1][3 + N + i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = temp[supportlength];//データの移行
										A_Supports[1][3 + N + i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][3 + N + i].Length == 0)
								{
									A_Supports[1][3 + N + i].Flag = 0;
								}
								break;
							}
						}
					}

					if (A_Supports[1][Te].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][Te].Id = A_Hands[Te].Hnum;//部品と手の支えの関係をつくる
						A_Supports[1][Te].Flag = 1;
						A_Supports[1][Te].PId[0] = use_parts;
						A_Supports[1][Te].Length++;
					}
					else
					{
						A_Supports[1][Te].Id = A_Hands[Te].Hnum;
						A_Supports[1][Te].Flag = 1;
						for (k = 0; k < A_Supports[1][Te].Length; k++)
						{
							//A_Supports[0][Te].PId = use_parts;
							if (A_Supports[1][Te].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][Te].PId[A_Supports[1][Te].Length] = use_parts;//部品と手の支えの関係をつくる
							A_Supports[1][Te].Length++;
						}
						else
						{
							supportflug = 0;
						}

					}
					//A_Supports[0][Te].PId = OyaPa;

					Grip(fp2, use_parts, BeforeJig, Te);//掴み取る grip
					//Grip(fp2, OyaPa, Te);//掴み取る grip
					BeforeJig = 0;
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == hakobu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					//Te = M_pattern[movetype].kobuhin[nowmove][Hand];

					IchiX1 = A_Objects[0][2 * N - 1 + Te].IchiX;
					IchiY1 = A_Objects[0][2 * N - 1 + Te].IchiY;
					IchiZ1 = A_Objects[0][2 * N - 1 + Te].IchiZ;
					IchiX2 = A_Objects[1][use_object].IchiX;
					IchiY2 = A_Objects[1][use_object].IchiY;
					IchiZ2 = A_Objects[1][use_object].IchiZ;
					/*IchiX2 = A_Objects[1][TyuPnum].IchiX;
					IchiY2 = A_Objects[1][TyuPnum].IchiY;
					IchiZ2 = A_Objects[1][TyuPnum].IchiZ;*/

					Carry(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);//左手で運ぶ carry

					A_Objects[0][2 * N - 1 + Te].IchiX = IchiX2;//手の座標を更新
					A_Objects[0][2 * N - 1 + Te].IchiY = IchiY2;
					A_Objects[0][2 * N - 1 + Te].IchiZ = IchiZ2;

					A_Objects[0][use_object].IchiX = IchiX2;//部品の座標を更新
					A_Objects[0][use_object].IchiY = IchiY2;
					A_Objects[0][use_object].IchiZ = IchiZ2;

					if ((Kouguflag != 0 && M_pattern[movetype].Move[Te][nowmove][target] == Ko) || M_pattern[movetype].Move[Te][nowmove][target] == KOUGU || M_pattern[movetype].Move[Te][nowmove][target] == ChangeKOUGU)//工具を用いて部品を運ぶ場合は工具の座標も変更
					{
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiX = IchiX2;//工具の座標を更新
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY = IchiY2;
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = IchiZ2;
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == okihanasu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = -1;//部品を持っている手がないことを記録
					if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)//対象が工具の時は工具を使用していないのでフラグを0に戻す
					{
						Kouguflag = 0;
					}

					for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
					{//左手、右手、冶具の支えの関係を切る
						//if (A_Supports[1][i].PId == TyuPa)
						f = A_Supports[1][i].Length;//支えている数を保存
						for (k = 0; k < f; k++)
						{
							/*if (A_Supports[1][i].PId == use_parts)
							{
								A_Supports[1][i].Flag = 0;
								A_Supports[1][i].PId = 0;
							}*/
							if (A_Supports[1][i].PId[k] == use_parts)//組立後に部品を支えていてはいけないのでA_Supports[1][i].PId
							{
								for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i].Length;
								A_Supports[1][i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != use_parts)//一致する部品は支えない部品なのでカウントしない
									{
										A_Supports[1][i].PId[A_Supports[1][i].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i].Length == 0)
								{
									A_Supports[1][i].Flag = 0;
								}
								break;
							}
						}

						if (i == Tnum - 1 + N + 3)
						{//中間製品置き場と中間製品の支えの関係を作る
							A_Supports[1][i].Flag = 1;
							//A_Supports[1][i].PId = use_parts;
							//A_Supports[1][i].PId = TyuPa;
							for (k = 0; k < A_Supports[1][i].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][i].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = 1;
									break;
								}
							}
							if (supportflug == 0)//まだ支えられていない時
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = use_parts;//親部品と手の支えの関係をつくる
								A_Supports[1][i].Length++;
							}
							else
							{
								supportflug = 0;
							}
						}
					}

					leave(fp2, use_parts, Te);//置き放す leave
					//leave(fp2, TyuPa, Te);//置き放す leave
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == tsukeru)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = Te;//部品を持っている手を記録

					if (M_pattern[movetype].Move[Te][nowmove][destination] == KOUGU)//付ける対象が工具の時は工具に付ける
					{
						Fix(fp2, KouguBnum, use_parts, Te);//付ける fix
						//Fix(fp2, Jigbangou, OyaPa, Te);//付ける fix

						//工具と親部品の支えの関係をつくる
						A_Supports[1][N + 3 + putting + Jigu + Kougunum].Id = A_Kougus[Kougunum].Bnum;
						A_Supports[1][N + 3 + putting + Jigu + Kougunum].Flag = 1;

						if (A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length == 0)
						{
							A_Supports[1][N + 3 + putting + Jigu + Kougunum].PId[A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length] = use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length++;
						}
						else
						{
							for (k = 0; k < A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][N + 3 + putting + Jigu + Kougunum].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = 1;
									break;
								}

								if (supportflug == 0)//まだ支えられていない時
								{
									A_Supports[1][N + 3 + putting + Jigu + Kougunum].PId[A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length] = use_parts;//親部品と手の支えの関係をつくる
									A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length++;
									break;
								}
								else
								{
									supportflug = 0;
								}
							}
						}
					}
					else
					{
						Fix(fp2, Jigbangou, use_parts, Te);//付ける fix
					   //Fix(fp2, Jigbangou, OyaPa, Te);//付ける fix

					   //治具と親部品の支えの関係をつくる
						A_Supports[1][3 + N + putting + Jig].Id = A_Jigus[Jig].Jnum;
						A_Supports[1][3 + N + putting + Jig].Flag = 1;
						//A_Supports[1][3 + N + putting + Jig].PId = use_parts;
						//A_Supports[1][3 + N + putting + Jig].PId = OyaPa;

						if (A_Supports[1][3 + N + putting + Jig].Length == 0)
						{
							A_Supports[1][3 + N + putting + Jig].PId[A_Supports[1][3 + N + putting + Jig].Length] = use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + Jig].Length++;
						}
						else
						{
							for (k = 0; k < A_Supports[1][3 + N + putting + Jig].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][3 + N + putting + Jig].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = 1;
									break;
								}

								if (supportflug == 0)//まだ支えられていない時
								{
									A_Supports[1][3 + N + putting + Jig].PId[A_Supports[1][3 + N + putting + Jig].Length] = use_parts;//親部品と手の支えの関係をつくる
									A_Supports[1][3 + N + putting + Jig].Length++;
									break;
								}
								else
								{
									supportflug = 0;
								}
							}
						}
						oya_hoji = A_Jigus[Jig].Jnum;
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == hazusu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					if (M_pattern[movetype].Move[Te][nowmove][destination] == KOUGU || M_pattern[movetype].Move[Te][nowmove][destination] == ChangeKOUGU)
					{
						if (M_pattern[movetype].Move[Te][nowmove][destination] == ChangeKOUGU)
						{
							TempKougunum = ChangeKougunum;
						}
						else
						{
							TempKougunum = Kougunum;
						}

						Remove(fp2, A_Objects[0][3 * N + 2 + TempKougunum + putting + Jigu].Id, use_parts, Te);//外す remove
						//Remove(fp2, Jigbangou, TyuPa, Te);//外す remove
						//治具と親部品の支えの関係を切る
						//A_Supports[1][3 + N + putting + Jig].PId = 0;

						for (supportlength = 0; supportlength < A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length; supportlength++)
						{
							temp[supportlength] = 0;//配列の初期化
							temp[supportlength] = A_Supports[1][N + 3 + putting + Jigu + TempKougunum].PId[supportlength];//値を移す
							A_Supports[1][N + 3 + putting + Jigu + TempKougunum].PId[supportlength] = 0;//配列の初期化
						}
						templength = 0;
						templength = A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length;
						A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length = 0;//一旦0にする
						for (k = 0; k < templength; k++)
						{
							if (temp[k] != use_parts)
							{
								A_Supports[1][N + 3 + putting + Jigu + TempKougunum].PId[A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length] = temp[k];
								A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length++;
							}
						}
						if (A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length == 0)
						{
							A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Flag = 0;
						}
					}
					else
					{
						Remove(fp2, Jigbangou, use_parts, Te);//外す remove
						//Remove(fp2, Jigbangou, TyuPa, Te);//外す remove
						//治具と親部品の支えの関係を切る
						//A_Supports[1][3 + N + putting + Jig].PId = 0;

						for (supportlength = 0; supportlength < A_Supports[1][3 + N + putting + Jig].Length; supportlength++)
						{
							temp[supportlength] = 0;//配列の初期化
							temp[supportlength] = A_Supports[1][3 + N + putting + Jig].PId[supportlength];//値を移す
							A_Supports[1][3 + N + putting + Jig].PId[supportlength] = 0;//配列の初期化
						}
						templength = 0;
						templength = A_Supports[1][3 + N + putting + Jig].Length;
						A_Supports[1][3 + N + putting + Jig].Length = 0;//一旦0にする
						for (k = 0; k < templength; k++)
						{
							if (temp[k] != use_parts)
							{
								A_Supports[1][3 + N + putting + Jig].PId[A_Supports[1][3 + N + putting + Jig].Length] = temp[k];
								A_Supports[1][3 + N + putting + Jig].Length++;
							}
						}
						if (A_Supports[1][3 + N + putting + Jig].Length == 0)
						{
							A_Supports[1][3 + N + putting + Jig].Flag = 0;
						}
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == hanasu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = -1;//部品を持っている手がないことを記録
					if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)//対象が工具の時は工具を使用していないのでフラグを0に戻す
					{
						Kouguflag = 0;
					}
					Release(fp2, use_parts, Te);//放すrelease
					//Release(fp2, OyaPa, Te);//放すrelease
					//親部品と手の支えの関係を切る
					//A_Supports[0][Te].Flag = 0;
					//A_Supports[0][Te].PId = 0;
					for (supportlength = 0; supportlength < A_Supports[1][Te].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][Te].PId[supportlength];//値を移す
						A_Supports[1][Te].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][Te].Length;
					A_Supports[1][Te].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != use_parts)
						{
							A_Supports[1][Te].PId[A_Supports[1][Te].Length] = temp[k];
							A_Supports[1][Te].Length++;
						}
					}
					if (A_Supports[1][Te].Length == 0)
					{
						A_Supports[1][Te].Flag = 0;
					}

					if (Kouguflag != 0)
					{
						for (supportlength = 0; supportlength < A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length; supportlength++)
						{
							temp[supportlength] = 0;//配列の初期化
							temp[supportlength] = A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId[supportlength];//値を移す
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId[supportlength] = 0;//配列の初期化
						}
						templength = 0;
						templength = A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length;
						A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length = 0;//一旦0にする
						for (k = 0; k < templength; k++)
						{
							if (temp[k] != use_parts)
							{
								A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId[A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length] = temp[k];
								A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length++;
							}
						}
						if (A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length == 0)
						{
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].Flag = 0;
						}
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == motinaosu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					Turn0X = A_Objects[0][use_object].DirX;
					Turn1X = A_Objects[1][use_object].DirX;
					Turn0Y = A_Objects[0][use_object].DirY;
					Turn1Y = A_Objects[1][use_object].DirY;
					Turn0Z = A_Objects[0][use_object].DirZ;
					Turn1Z = A_Objects[1][use_object].DirZ;

					Turn(fp2, use_parts, Turn0X, Turn0Y, Turn0Z, Turn1X, Turn1Y, Turn1Z, Te);//左手で回転させるturn
					if (M_pattern[movetype].Move[Te][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(Turn0X - Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(Turn0Y - Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(Turn0Z - Turn1Z) + Oyakaitenkakudo;
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == kumitateidou)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = Te;//部品を持っている手を記録
					/*IchiX1 = A_Objects[1][KoPnum].IchiX;
					IchiY1 = A_Objects[1][KoPnum].IchiY;
					IchiZ1 = A_Objects[1][KoPnum].IchiZ;*/
					IchiX1 = A_Objects[0][2 * N - 1 + Te].IchiX;
					IchiY1 = A_Objects[0][2 * N - 1 + Te].IchiY;
					IchiZ1 = A_Objects[0][2 * N - 1 + Te].IchiZ;

					if (kumijun[line].scene_type == oya2ko1)
					{
						/*if (Oya2flag == 1 || Oya2flag == 3)
						{
							IchiX2 = KIdo_X1;
							IchiY2 = KIdo_Y1;
							IchiZ2 = KIdo_Z1;
						}
						else if (Oya2flag == 2)
						{
							IchiX2 = KIdo_X;
							IchiY2 = KIdo_Y;
							IchiZ2 = KIdo_Z;
						}*/
						IchiX2 = KIdo_X1;
						IchiY2 = KIdo_Y1;
						IchiZ2 = KIdo_Z1;
					}
					else
					{
						IchiX2 = KIdo_X;
						IchiY2 = KIdo_Y;
						IchiZ2 = KIdo_Z;
					}

					Kumimove(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);//組立移動Kumimove

					A_Objects[0][2 * N - 1 + Te].IchiX = IchiX2;//手の座標を更新
					A_Objects[0][2 * N - 1 + Te].IchiY = IchiY2;
					A_Objects[0][2 * N - 1 + Te].IchiZ = IchiZ2;

					A_Objects[0][use_object].IchiX = IchiX2;//部品の座標を更新
					A_Objects[0][use_object].IchiY = IchiY2;
					A_Objects[0][use_object].IchiZ = IchiZ2;

					A_Objects[1][use_object].IchiX = IchiX2;//部品の座標を更新
					A_Objects[1][use_object].IchiY = IchiY2;
					A_Objects[1][use_object].IchiZ = IchiZ2;

					if ((Kouguflag != 0 && M_pattern[movetype].Move[Te][nowmove][target] == Ko) || M_pattern[movetype].Move[Te][nowmove][target] == KOUGU || M_pattern[movetype].Move[Te][nowmove][target] == ChangeKOUGU)//工具を用いて部品を運ぶ場合は工具の座標も変更
					{
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiX = IchiX2;//部品の座標を更新
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY = IchiY2;
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = IchiZ2;
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == kumitateru)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					//Te = M_pattern[movetype].kobuhin[nowmove][Hand];
					/*if (kumijun[line].scene_type == oya2ko1)
					{
						Kumitate(fp2, A_Supports[0][N + putting + 3 + kumijun[line].jig - 1].Id, kumijun[line].tyukan, kumijun[line].oya, kumijun[line].ko, Te);//右手で組立Kumitate
						Kumitate(fp2, A_Supports[0][N + putting + 3 + kumijun[line + 1].jig - 1].Id, kumijun[line + 1].tyukan, kumijun[line + 1].oya, kumijun[line + 1].ko, Te);//右手で組立Kumitate
					}*/
					if (kumijun[line].kougu != 0)//工具を用いて組立を行う時
					{
						KouguKumi(fp2, Jigbangou, KouguBnum, TyuPa, OyaPa, KoPa);
					}
					else
					{
						Kumitate(fp2, Jigbangou, TyuPa, OyaPa, KoPa, Te);//組立Kumitate
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == sentanhenkou)
			{
				Tipmove(fp2, line, M_pattern[movetype].Move[Te][nowmove][target], Te);
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == hakobu_tsuika)
			{
				IchiX1 = A_Objects[0][2 * N - 1 + Te].IchiX;
				IchiY1 = A_Objects[0][2 * N - 1 + Te].IchiY;
				IchiZ1 = A_Objects[0][2 * N - 1 + Te].IchiZ;
				IchiX2 = A_Objects[1][use_object].IchiX + M_pattern[movetype].Move_addition[Te][nowmove][0];
				IchiY2 = A_Objects[1][use_object].IchiY + M_pattern[movetype].Move_addition[Te][nowmove][1];
				IchiZ2 = A_Objects[1][use_object].IchiZ + M_pattern[movetype].Move_addition[Te][nowmove][2];

				Carry(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);//左手で運ぶ carry

				A_Objects[0][2 * N - 1 + Te].IchiX = IchiX2;//手の座標を更新
				A_Objects[0][2 * N - 1 + Te].IchiY = IchiY2;
				A_Objects[0][2 * N - 1 + Te].IchiZ = IchiZ2;

				A_Objects[0][use_object].IchiX = IchiX2;//部品の座標を更新
				A_Objects[0][use_object].IchiY = IchiY2;
				A_Objects[0][use_object].IchiZ = IchiZ2;


				if ((Kouguflag != 0 && M_pattern[movetype].Move[Te][nowmove][target] == Ko) || M_pattern[movetype].Move[Te][nowmove][target] == KOUGU || M_pattern[movetype].Move[Te][nowmove][target] == ChangeKOUGU)//工具を用いて部品を運ぶ場合は工具の座標も変更
				{
					A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiX = IchiX2;//部品の座標を更新
					A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY = IchiY2;
					A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = IchiZ2;
				}

			}
		}
		else if (Te == ryoute)
		{
			//右手の対象を決める
			if (M_pattern[movetype].Move[migite][nowmove][target] == Oya)//対象製品が親部品
			{

				if (Oya2flag == 1)//基準部品が最初の部品の時
				{//2番目の部品が対象の部品になる
					R_use_parts = kumijun[line + 1].oya;
					R_use_object = OyaPnum;
				}
				else if (Oya2flag == 2)//基準部品が2番目の部品の時
				{//最初の部品が対象の部品になる
					R_use_parts = kumijun[line].oya;
					R_use_object = OyaPnum1;
				}
				else
				{
					R_use_parts = OyaPa;
					R_use_object = OyaPnum;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Ko)//対象製品が子部品
			{
				R_use_parts = KoPa;
				R_use_object = KoPnum;
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Tyukan)//対象製品が中間製品
			{
				R_use_parts = TyuPa;
				R_use_object = TyuPnum;
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Start_P)//手を初期位置に戻すとき、対象製品は使用する手
			{
				R_use_object = 2 * N - 1 + migite;
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Ko1)//両手2部品の時の右手で扱う子部品
			{
				R_use_parts = A_Objects[0][R_KoPnum].Id;
				R_use_object = R_KoPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].ko == R_use_parts)
					{
						R_TyuPa = kumijun[i].tyukan;
						R_line = i;
						if (NewNOS0 == 0)
						{
							R_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									R_Jig = k;
									break;
								}

							}
						}

						R_Jigbangou = A_Supports[0][N + putting + 3 + R_Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Oya1)//両手2部品の時の右手で扱う親部品
			{
				R_use_parts = A_Objects[0][R_OyaPnum].Id;
				R_use_object = R_OyaPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].oya == R_use_parts)
					{
						R_TyuPa = kumijun[i].tyukan;
						R_line = i;
						if (NewNOS0 == 0)
						{
							R_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									R_Jig = k;
									break;
								}

							}
						}
						R_Jigbangou = A_Supports[0][N + putting + 3 + R_Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Tyukan1)//両手2部品の時の右手で扱う中間製品部品
			{
				R_use_parts = A_Objects[0][R_TyuPnum].Id;
				R_use_object = R_TyuPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].tyukan == R_use_parts)
					{
						R_TyuPa = kumijun[i].tyukan;
						R_line = i;
						if (NewNOS0 == 0)
						{
							R_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									R_Jig = k;
									break;
								}

							}
						}
						R_Jigbangou = A_Supports[0][N + putting + 3 + R_Jig].Id;
					}
				}
			}

			//左手の対象を決める
			if (M_pattern[movetype].Move[hidarite][nowmove][target] == Oya)//対象製品が親部品
			{
				if (Oya2flag == 1)//基準部品が最初の部品の時
				{//2番目の部品が対象の部品になる
					L_use_parts = kumijun[line + 1].oya;
					L_use_object = OyaPnum;
				}
				else if (Oya2flag == 2)//基準部品が2番目の部品の時
				{//最初の部品が対象の部品になる
					L_use_parts = kumijun[line].oya;
					L_use_object = OyaPnum1;
				}
				else
				{
					L_use_parts = OyaPa;
					L_use_object = OyaPnum;
				}
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Ko)//対象製品が子部品
			{
				L_use_parts = KoPa;
				L_use_object = KoPnum;
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Tyukan)//対象製品が中間製品
			{
				L_use_parts = TyuPa;
				L_use_object = TyuPnum;
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Start_P)//手を初期位置に戻すとき、対象製品は使用する手
			{
				L_use_object = 2 * N - 1 + hidarite;
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Ko2)//両手2部品の時の左手で扱う子部品
			{
				L_use_parts = A_Objects[0][L_KoPnum].Id;
				L_use_object = L_KoPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].ko == L_use_parts)
					{
						L_TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							L_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									L_Jig = k;
									break;
								}

							}
						}
						L_Jigbangou = A_Supports[0][N + putting + 3 + L_Jig].Id;
						L_line = i;
					}
				}
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Oya2)//両手2部品の時の左手で扱う親部品
			{
				L_use_parts = A_Objects[0][L_OyaPnum].Id;
				L_use_object = L_OyaPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].oya == L_use_parts)
					{
						L_TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							L_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									L_Jig = k;
									break;
								}

							}
						}
						L_Jigbangou = A_Supports[0][N + putting + 3 + L_Jig].Id;
						L_line = i;
					}
				}
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Tyukan2)//両手2部品の時の左手で扱う中間製品部品
			{
				L_use_parts = A_Objects[0][L_TyuPnum].Id;
				L_use_object = L_TyuPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].tyukan == L_use_parts)
					{
						L_TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							L_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									L_Jig = k;
									break;
								}

							}
						}
						L_Jigbangou = A_Supports[0][N + putting + 3 + L_Jig].Id;
						L_line = i;
					}
				}
			}

			if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[hidarite][nowmove][move]) == nobasu)//右手と左手が同じ動作で伸ばすの時
			{
				//右手と左手の部品に回転があるときに必要、もしくは右手と左手にこの動作が指定されているとき
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{//Te = M_pattern[movetype].kobuhin[nowmove][Hand];
				//もともと治具に付いている部品(親部品)に手を伸ばす

					L_IchiX1 = A_Objects[0][2 * N - 1 + hidarite].IchiX;//使用する手の現在の位置
					L_IchiY1 = A_Objects[0][2 * N - 1 + hidarite].IchiY;
					L_IchiZ1 = A_Objects[0][2 * N - 1 + hidarite].IchiZ;
					L_IchiX2 = A_Objects[0][L_use_object].IchiX;
					L_IchiY2 = A_Objects[0][L_use_object].IchiY;
					L_IchiZ2 = A_Objects[0][L_use_object].IchiZ;

					R_IchiX1 = A_Objects[0][2 * N - 1 + migite].IchiX;//使用する手の現在の位置
					R_IchiY1 = A_Objects[0][2 * N - 1 + migite].IchiY;
					R_IchiZ1 = A_Objects[0][2 * N - 1 + migite].IchiZ;
					R_IchiX2 = A_Objects[0][R_use_object].IchiX;
					R_IchiY2 = A_Objects[0][R_use_object].IchiY;
					R_IchiZ2 = A_Objects[0][R_use_object].IchiZ;
					/*IchiX2 = A_Objects[0][OyaPnum].IchiX;
					IchiY2 = A_Objects[0][OyaPnum].IchiY;
					IchiZ2 = A_Objects[0][OyaPnum].IchiZ;*/

					WReach(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					R_IchiX1 = A_Objects[0][2 * N - 1 + migite].IchiX;//使用する手の現在の位置
					R_IchiY1 = A_Objects[0][2 * N - 1 + migite].IchiY;
					R_IchiZ1 = A_Objects[0][2 * N - 1 + migite].IchiZ;
					R_IchiX2 = A_Objects[0][R_use_object].IchiX;
					R_IchiY2 = A_Objects[0][R_use_object].IchiY;
					R_IchiZ2 = A_Objects[0][R_use_object].IchiZ;

					Reach(fp2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2, migite);

					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;

				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					L_IchiX1 = A_Objects[0][2 * N - 1 + hidarite].IchiX;//使用する手の現在の位置
					L_IchiY1 = A_Objects[0][2 * N - 1 + hidarite].IchiY;
					L_IchiZ1 = A_Objects[0][2 * N - 1 + hidarite].IchiZ;
					L_IchiX2 = A_Objects[0][L_use_object].IchiX;
					L_IchiY2 = A_Objects[0][L_use_object].IchiY;
					L_IchiZ2 = A_Objects[0][L_use_object].IchiZ;

					Reach(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, hidarite);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == hakobu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					//Te = M_pattern[movetype].kobuhin[nowmove][Hand];

					L_IchiX1 = A_Objects[0][2 * N - 1 + hidarite].IchiX;
					L_IchiY1 = A_Objects[0][2 * N - 1 + hidarite].IchiY;
					L_IchiZ1 = A_Objects[0][2 * N - 1 + hidarite].IchiZ;
					L_IchiX2 = A_Objects[1][L_use_object].IchiX;
					L_IchiY2 = A_Objects[1][L_use_object].IchiY;
					L_IchiZ2 = A_Objects[1][L_use_object].IchiZ;

					R_IchiX1 = A_Objects[0][2 * N - 1 + migite].IchiX;
					R_IchiY1 = A_Objects[0][2 * N - 1 + migite].IchiY;
					R_IchiZ1 = A_Objects[0][2 * N - 1 + migite].IchiZ;
					R_IchiX2 = A_Objects[1][R_use_object].IchiX;
					R_IchiY2 = A_Objects[1][R_use_object].IchiY;
					R_IchiZ2 = A_Objects[1][R_use_object].IchiZ;
					/*IchiX2 = A_Objects[1][TyuPnum].IchiX;
					IchiY2 = A_Objects[1][TyuPnum].IchiY;
					IchiZ2 = A_Objects[1][TyuPnum].IchiZ;*/

					WCarry(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2);//両手で運ぶ carry

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;

					A_Objects[0][R_use_object].IchiX = R_IchiX2;//部品の座標を更新
					A_Objects[0][R_use_object].IchiY = R_IchiY2;
					A_Objects[0][R_use_object].IchiZ = R_IchiZ2;
					A_Objects[0][L_use_object].IchiX = L_IchiX2;//部品の座標を更新
					A_Objects[0][L_use_object].IchiY = L_IchiY2;
					A_Objects[0][L_use_object].IchiZ = L_IchiZ2;
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					R_IchiX1 = A_Objects[0][2 * N - 1 + migite].IchiX;
					R_IchiY1 = A_Objects[0][2 * N - 1 + migite].IchiY;
					R_IchiZ1 = A_Objects[0][2 * N - 1 + migite].IchiZ;
					R_IchiX2 = A_Objects[1][R_use_object].IchiX;
					R_IchiY2 = A_Objects[1][R_use_object].IchiY;
					R_IchiZ2 = A_Objects[1][R_use_object].IchiZ;

					Carry(fp2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2, migite);

					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;

					A_Objects[0][R_use_object].IchiX = R_IchiX2;//部品の座標を更新
					A_Objects[0][R_use_object].IchiY = R_IchiY2;
					A_Objects[0][R_use_object].IchiZ = R_IchiZ2;

				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					L_IchiX1 = A_Objects[0][2 * N - 1 + hidarite].IchiX;
					L_IchiY1 = A_Objects[0][2 * N - 1 + hidarite].IchiY;
					L_IchiZ1 = A_Objects[0][2 * N - 1 + hidarite].IchiZ;
					L_IchiX2 = A_Objects[1][L_use_object].IchiX;
					L_IchiY2 = A_Objects[1][L_use_object].IchiY;
					L_IchiZ2 = A_Objects[1][L_use_object].IchiZ;

					Carry(fp2, L_IchiX1, L_IchiY1, R_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, hidarite);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					A_Objects[0][L_use_object].IchiX = L_IchiX2;//部品の座標を更新
					A_Objects[0][L_use_object].IchiY = L_IchiY2;
					A_Objects[0][L_use_object].IchiZ = L_IchiZ2;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == kumitateidou)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					hold_hands = migite;//部品を持っている手を記録
					/*IchiX1 = A_Objects[1][KoPnum].IchiX;
					IchiY1 = A_Objects[1][KoPnum].IchiY;
					IchiZ1 = A_Objects[1][KoPnum].IchiZ;*/
					L_IchiX1 = A_Objects[1][L_use_object].IchiX;
					L_IchiY1 = A_Objects[1][L_use_object].IchiY;
					L_IchiZ1 = A_Objects[1][L_use_object].IchiZ;

					R_IchiX1 = A_Objects[1][R_use_object].IchiX;
					R_IchiY1 = A_Objects[1][R_use_object].IchiY;
					R_IchiZ1 = A_Objects[1][R_use_object].IchiZ;

					if (kumijun[line].scene_type == oya1ko2 || kumijun[line].scene_type == oya2ko2)
					{
						if (R_line < L_line)
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
						else
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
					}
					else if (kumijun[line].scene_type == oya2ko1)
					{
						if (Oya2flag == 1)//組立順序の最初の部品が基準部品の場合
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
						else if (Oya2flag == 2 || Oya2flag == 3)
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
					}
					else
					{
						R_IchiX2 = KIdo_X;
						R_IchiY2 = KIdo_Y;
						R_IchiZ2 = KIdo_Z;

						L_IchiX2 = KIdo_X;
						L_IchiY2 = KIdo_Y;
						L_IchiZ2 = KIdo_Z;
					}

					WKumimove(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;

					//部品の座標の更新
					A_Objects[1][L_use_object].IchiX = L_IchiX2;
					A_Objects[1][L_use_object].IchiY = L_IchiX2;
					A_Objects[1][L_use_object].IchiZ = L_IchiX2;

					A_Objects[1][R_use_object].IchiX = R_IchiX2;
					A_Objects[1][R_use_object].IchiY = R_IchiY2;
					A_Objects[1][R_use_object].IchiZ = R_IchiZ2;
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					R_IchiX1 = A_Objects[1][R_use_object].IchiX;
					R_IchiY1 = A_Objects[1][R_use_object].IchiY;
					R_IchiZ1 = A_Objects[1][R_use_object].IchiZ;

					if (kumijun[line].scene_type == oya1ko2 || kumijun[line].scene_type == oya2ko2)
					{
						if (R_line < L_line)
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
						else
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
					}
					else if (kumijun[line].scene_type == oya2ko1)
					{
						if (Oya2flag == 1)//組立順序の最初の部品が基準部品の場合
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
						else if (Oya2flag == 2 || Oya2flag == 3)
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
					}
					else
					{
						R_IchiX2 = KIdo_X;
						R_IchiY2 = KIdo_Y;
						R_IchiZ2 = KIdo_Z;

						L_IchiX2 = KIdo_X;
						L_IchiY2 = KIdo_Y;
						L_IchiZ2 = KIdo_Z;
					}

					Kumimove(fp2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2, migite);

					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;
					A_Objects[1][R_use_object].IchiX = R_IchiX2;//部品の座標の更新
					A_Objects[1][R_use_object].IchiY = R_IchiY2;
					A_Objects[1][R_use_object].IchiZ = R_IchiZ2;
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					L_IchiX1 = A_Objects[1][L_use_object].IchiX;
					L_IchiY1 = A_Objects[1][L_use_object].IchiY;
					L_IchiZ1 = A_Objects[1][L_use_object].IchiZ;

					if (kumijun[line].scene_type == oya1ko2 || kumijun[line].scene_type == oya2ko2)
					{
						if (R_line < L_line)
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
						else
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
					}
					else if (kumijun[line].scene_type == oya2ko1)
					{
						if (Oya2flag == 1)//組立順序の最初の部品が基準部品の場合
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
						else if (Oya2flag == 2 || Oya2flag == 3)
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
					}
					else
					{
						R_IchiX2 = KIdo_X;
						R_IchiY2 = KIdo_Y;
						R_IchiZ2 = KIdo_Z;

						L_IchiX2 = KIdo_X;
						L_IchiY2 = KIdo_Y;
						L_IchiZ2 = KIdo_Z;
					}

					Kumimove(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, hidarite);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					//部品の座標の更新
					A_Objects[1][L_use_object].IchiX = L_IchiX2;
					A_Objects[1][L_use_object].IchiY = L_IchiX2;
					A_Objects[1][L_use_object].IchiZ = L_IchiX2;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == tsukeru)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					WFix(fp2, L_Jigbangou, R_Jigbangou, L_use_parts, R_use_parts);//付ける fix

					//治具と親部品の支えの関係をつくる
					A_Supports[1][3 + N + putting + R_Jig].Id = A_Jigus[R_Jig].Jnum;
					A_Supports[1][3 + N + putting + R_Jig].Flag = 1;

					A_Supports[1][3 + N + putting + L_Jig].Id = A_Jigus[L_Jig].Jnum;
					A_Supports[1][3 + N + putting + L_Jig].Flag = 1;

					for (k = 0; k < A_Supports[1][3 + N + putting + R_Jig].Length; k++)//治具と親部品の支えの関係をつくる(右手)
					{
						//A_Supports[0][Te].PId = use_parts;
						if (A_Supports[1][3 + N + putting + R_Jig].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
						{
							supportflug = 1;
							break;
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][3 + N + putting + R_Jig].PId[A_Supports[1][3 + N + putting + R_Jig].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + R_Jig].Length++;
							break;
						}
						else
						{
							supportflug = 0;
						}
					}

					for (k = 0; k < A_Supports[1][3 + N + putting + L_Jig].Length; k++)//治具と親部品の支えの関係をつくる(左手)
					{
						//A_Supports[0][Te].PId = use_parts;
						if (A_Supports[1][3 + N + putting + L_Jig].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
						{
							supportflug = 1;
							break;
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][3 + N + putting + L_Jig].PId[A_Supports[1][3 + N + putting + L_Jig].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + L_Jig].Length++;
							break;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					Fix(fp2, R_Jigbangou, R_use_parts, migite);//付ける fix

					//治具と親部品の支えの関係をつくる
					A_Supports[1][3 + N + putting + R_Jig].Id = A_Jigus[R_Jig].Jnum;
					A_Supports[1][3 + N + putting + R_Jig].Flag = 1;
					for (k = 0; k < A_Supports[1][3 + N + putting + R_Jig].Length; k++)//治具と親部品の支えの関係をつくる(右手)
					{
						//A_Supports[0][Te].PId = use_parts;
						if (A_Supports[1][3 + N + putting + R_Jig].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
						{
							supportflug = 1;
							break;
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][3 + N + putting + R_Jig].PId[A_Supports[1][3 + N + putting + R_Jig].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + R_Jig].Length++;
							break;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					Fix(fp2, L_Jigbangou, L_use_parts, hidarite);//付ける fix
					A_Supports[1][3 + N + putting + L_Jig].Id = A_Jigus[L_Jig].Jnum;
					A_Supports[1][3 + N + putting + L_Jig].Flag = 1;
					for (k = 0; k < A_Supports[1][3 + N + putting + L_Jig].Length; k++)//治具と親部品の支えの関係をつくる(左手)
					{
						//A_Supports[0][Te].PId = use_parts;
						if (A_Supports[1][3 + N + putting + L_Jig].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
						{
							supportflug = 1;
							break;
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][3 + N + putting + L_Jig].PId[A_Supports[1][3 + N + putting + L_Jig].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + L_Jig].Length++;
							break;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == tsukamu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					WGripping(fp2, L_use_parts, R_use_parts);//掴む
					//Gripping(fp2, TyuPa, Te);//掴む

					if (A_Supports[1][hidarite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][hidarite].Flag = 1;
						A_Supports[1][hidarite].PId[0] = L_use_parts;
						A_Supports[1][hidarite].Length++;
					}
					else
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;
						A_Supports[1][hidarite].Flag = 1;
						for (k = 0; k < A_Supports[1][hidarite].Length; k++)
						{
							//A_Supports[0][hidarite].PId = use_parts;
							if (A_Supports[1][hidarite].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][hidarite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

					if (A_Supports[1][migite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][migite].Flag = 1;
						A_Supports[1][migite].PId[0] = R_use_parts;
						A_Supports[1][migite].Length++;
					}
					else
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;
						A_Supports[1][migite].Flag = 1;
						for (k = 0; k < A_Supports[1][migite].Length; k++)
						{
							//A_Supports[0][migite].PId = use_parts;
							if (A_Supports[1][migite].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][migite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					Gripping(fp2, R_use_parts, migite);
					if (A_Supports[1][migite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][migite].Flag = 1;
						A_Supports[1][migite].PId[0] = R_use_parts;
						A_Supports[1][migite].Length++;
					}
					else
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;
						A_Supports[1][migite].Flag = 1;
						for (k = 0; k < A_Supports[1][migite].Length; k++)
						{
							//A_Supports[0][migite].PId = use_parts;
							if (A_Supports[1][migite].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][migite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					Gripping(fp2, L_use_parts, hidarite);
					if (A_Supports[1][hidarite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][hidarite].Flag = 1;
						A_Supports[1][hidarite].PId[0] = L_use_parts;
						A_Supports[1][hidarite].Length++;
					}
					else
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;
						A_Supports[1][hidarite].Flag = 1;
						for (k = 0; k < A_Supports[1][hidarite].Length; k++)
						{
							//A_Supports[0][hidarite].PId = use_parts;
							if (A_Supports[1][hidarite].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][hidarite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == tsukamitoru)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					//右側の部品に関して
					if (JigKobuhin == R_use_parts || JigKobuhin2 == R_use_parts || ChangeJig == R_use_parts || ChangeJig2 == R_use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == R_use_parts)
								{
									BeforeJigR = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					//左側の部品に関して
					if (JigKobuhin == L_use_parts || JigKobuhin2 == L_use_parts || ChangeJig == L_use_parts || ChangeJig2 == L_use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == L_use_parts)
								{
									BeforeJigL = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					for (i = 0; i < Bboxnum; i++)
					{
						for (k = 0; k < A_Supports[1][i + 2].Length; k++)
						{
							if (A_Supports[1][i + 2].PId[k] == L_use_parts || A_Supports[1][i + 2].PId[k] == R_use_parts) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
							   //A_Supports[1][i + 2].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i + 2].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i + 2].Length;
								A_Supports[1][i + 2].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if ((temp[supportlength] != L_use_parts && A_Supports[1][i + 2].PId[k] == L_use_parts) ||
										(temp[supportlength] != R_use_parts && A_Supports[1][i + 2].PId[k] == R_use_parts))//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i + 2].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i + 2].Length == 0)
								{
									A_Supports[1][i + 2].Flag = 0;
								}
								break;
							}
						}
					}
					for (i = 0; i < putting; i++)
					{//中間製品置き場からとるとき、支えの関係を切る
						//if (A_Supports[0][3 + N + i].PId == OyaPa)
						/*if (A_Supports[0][3 + N + i].PId == use_parts)
						{
							A_Supports[1][3 + N + i].Flag = 0;
							A_Supports[1][3 + N + i].PId = 0;
						}*/
						for (k = 0; k < A_Supports[1][3 + N + i].Length; k++)
						{
							if (A_Supports[1][3 + N + i].PId[k] == L_use_parts || A_Supports[1][3 + N + i].PId[k] == R_use_parts)//右手で扱う部品か左手で扱う部品の時
							{
								//A_Supports[1][3 + N + i].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][3 + N + i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][3 + N + i].Length;
								A_Supports[1][3 + N + i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if ((temp[supportlength] != L_use_parts && A_Supports[1][3 + N + i].PId[k] == L_use_parts) ||
										(temp[supportlength] != R_use_parts && A_Supports[1][3 + N + i].PId[k] == R_use_parts))//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = temp[supportlength];//データの移行
										A_Supports[1][3 + N + i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][3 + N + i].Length == 0)
								{
									A_Supports[1][3 + N + i].Flag = 0;
								}
								break;
							}
						}
					}

					if (A_Supports[1][hidarite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][hidarite].Flag = 1;
						A_Supports[1][hidarite].PId[0] = L_use_parts;
						A_Supports[1][hidarite].Length++;
					}
					else
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;
						A_Supports[1][hidarite].Flag = 1;
						for (k = 0; k < A_Supports[1][hidarite].Length; k++)
						{
							//A_Supports[0][hidarite].PId = use_parts;
							if (A_Supports[1][hidarite].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][hidarite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

					if (A_Supports[1][migite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][migite].Flag = 1;
						A_Supports[1][migite].PId[0] = R_use_parts;
						A_Supports[1][migite].Length++;
					}
					else
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;
						A_Supports[1][migite].Flag = 1;
						for (k = 0; k < A_Supports[1][migite].Length; k++)
						{
							//A_Supports[0][migite].PId = use_parts;
							if (A_Supports[1][migite].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][migite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

					WGrip(fp2, L_use_parts, R_use_parts, BeforeJigL, BeforeJigR);
					BeforeJigL = BeforeJigR = 0;
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					if (JigKobuhin == R_use_parts || JigKobuhin2 == R_use_parts || ChangeJig == R_use_parts || ChangeJig2 == R_use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == R_use_parts)
								{
									BeforeJigR = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					for (i = 0; i < Bboxnum; i++)
					{
						for (k = 0; k < A_Supports[1][i + 2].Length; k++)
						{
							if (A_Supports[1][i + 2].PId[k] == R_use_parts) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
							   //A_Supports[1][i + 2].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i + 2].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i + 2].Length;
								A_Supports[1][i + 2].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != R_use_parts && A_Supports[1][i + 2].PId[k] == R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i + 2].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i + 2].Length == 0)
								{
									A_Supports[1][i + 2].Flag = 0;
								}
								break;
							}
						}
					}
					for (i = 0; i < putting; i++)
					{//中間製品置き場からとるとき、支えの関係を切る
						//if (A_Supports[0][3 + N + i].PId == OyaPa)
						/*if (A_Supports[0][3 + N + i].PId == use_parts)
						{
							A_Supports[1][3 + N + i].Flag = 0;
							A_Supports[1][3 + N + i].PId = 0;
						}*/
						for (k = 0; k < A_Supports[1][3 + N + i].Length; k++)
						{
							if (A_Supports[1][3 + N + i].PId[k] == R_use_parts)//右手で扱う部品か左手で扱う部品の時
							{
								//A_Supports[1][3 + N + i].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][3 + N + i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][3 + N + i].Length;
								A_Supports[1][3 + N + i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != R_use_parts && A_Supports[1][3 + N + i].PId[k] == R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = temp[supportlength];//データの移行
										A_Supports[1][3 + N + i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][3 + N + i].Length == 0)
								{
									A_Supports[1][3 + N + i].Flag = 0;
								}
								break;
							}
						}
					}
					if (A_Supports[1][migite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][migite].Flag = 1;
						A_Supports[1][migite].PId[0] = use_parts;
						A_Supports[1][migite].Length++;
					}
					else
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;
						A_Supports[1][migite].Flag = 1;
						for (k = 0; k < A_Supports[1][migite].Length; k++)
						{
							//A_Supports[0][migite].PId = use_parts;
							if (A_Supports[1][migite].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][migite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
					Grip(fp2, R_use_parts, BeforeJigR, migite);
					BeforeJigR = 0;
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					if (JigKobuhin == L_use_parts || JigKobuhin2 == L_use_parts || ChangeJig == L_use_parts || ChangeJig2 == L_use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == L_use_parts)
								{
									BeforeJigL = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					for (i = 0; i < Bboxnum; i++)
					{
						for (k = 0; k < A_Supports[1][i + 2].Length; k++)
						{
							if (A_Supports[1][i + 2].PId[k] == L_use_parts) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
							   //A_Supports[1][i + 2].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i + 2].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i + 2].Length;
								A_Supports[1][i + 2].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != L_use_parts && A_Supports[1][i + 2].PId[k] == L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i + 2].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i + 2].Length == 0)
								{
									A_Supports[1][i + 2].Flag = 0;
								}
								break;
							}
						}
					}
					for (i = 0; i < putting; i++)
					{//中間製品置き場からとるとき、支えの関係を切る
						//if (A_Supports[0][3 + N + i].PId == OyaPa)
						/*if (A_Supports[0][3 + N + i].PId == use_parts)
						{
							A_Supports[1][3 + N + i].Flag = 0;
							A_Supports[1][3 + N + i].PId = 0;
						}*/
						for (k = 0; k < A_Supports[1][3 + N + i].Length; k++)
						{
							if (A_Supports[1][3 + N + i].PId[k] == L_use_parts)//右手で扱う部品か左手で扱う部品の時
							{
								//A_Supports[1][3 + N + i].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][3 + N + i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][3 + N + i].Length;
								A_Supports[1][3 + N + i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != L_use_parts && A_Supports[1][3 + N + i].PId[k] == L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = temp[supportlength];//データの移行
										A_Supports[1][3 + N + i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][3 + N + i].Length == 0)
								{
									A_Supports[1][3 + N + i].Flag = 0;
								}
								break;
							}
						}
					}

					if (A_Supports[1][hidarite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][hidarite].Flag = 1;
						A_Supports[1][hidarite].PId[0] = use_parts;
						A_Supports[1][hidarite].Length++;
					}
					else
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;
						A_Supports[1][hidarite].Flag = 1;
						for (k = 0; k < A_Supports[1][hidarite].Length; k++)
						{
							//A_Supports[0][hidarite].PId = use_parts;
							if (A_Supports[1][hidarite].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][hidarite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

					Grip(fp2, L_use_parts, BeforeJigL, hidarite);
					BeforeJigL = 0;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == okihanasu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					Wleave(fp2, L_use_parts, R_use_parts);//置き放す leave
					//leave(fp2, TyuPa, Te);//置き放す leave

					for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
					{//左手、右手、冶具の支えの関係を切る
						//if (A_Supports[1][i].PId == TyuPa)
						f = A_Supports[1][i].Length;//支えている数を保存
						for (k = 0; k < f; k++)
						{
							/*if (A_Supports[1][i].PId == use_parts)
							{
								A_Supports[1][i].Flag = 0;
								A_Supports[1][i].PId = 0;
							}*/
							if (A_Supports[1][i].PId[k] == L_use_parts || A_Supports[1][i].PId[k] == R_use_parts)//組立後に部品を支えていてはいけないのでA_Supports[1][i].PId
							{
								for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i].Length;
								A_Supports[1][i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if ((temp[supportlength] != L_use_parts && A_Supports[1][3 + N + i].PId[k] == L_use_parts) ||
										(temp[supportlength] != R_use_parts && A_Supports[1][3 + N + i].PId[k] == R_use_parts))//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i].PId[A_Supports[1][i].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i].Length == 0)
								{
									A_Supports[1][i].Flag = 0;
								}
								break;
							}
						}

						if (i == Tnum - 1 + N + 3)
						{//中間製品置き場と中間製品の支えの関係を作る
							A_Supports[1][i].Flag = 1;
							//A_Supports[1][i].PId = use_parts;
							//A_Supports[1][i].PId = TyuPa;
							for (k = 0; k < A_Supports[1][i].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][i].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = supportflug + 1;//左手で扱う部品を持っている時は＋1する
								}
								else if (A_Supports[1][i].PId[k] == R_use_parts)
								{
									supportflug = supportflug + 2;//右手で扱う部品を持っている時は＋2する
								}
							}
							if (supportflug == 0)//まだ支えられていない時
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = L_use_parts;//中間製品置き場と左手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;

								A_Supports[1][i].PId[A_Supports[1][i].Length] = R_use_parts;//中間製品置き場と右手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else if (supportflug == 1)//左手で扱う部品がすでに支えられているとき(一応の作業)
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = R_use_parts;//中間製品置き場と中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else if (supportflug == 2)//右手で扱う部品がすでに支えられているとき(一応の作業)
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = L_use_parts;//中間製品置き場と左手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else
							{
								supportflug = 0;
							}
						}
					}

				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					leave(fp2, R_use_parts, migite);
					for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
					{//右手、冶具の支えの関係を切る
						//if (A_Supports[1][i].PId == TyuPa)
						f = A_Supports[1][i].Length;//支えている数を保存
						for (k = 0; k < f; k++)
						{
							/*if (A_Supports[1][i].PId == use_parts)
							{
								A_Supports[1][i].Flag = 0;
								A_Supports[1][i].PId = 0;
							}*/
							if (A_Supports[1][i].PId[k] == R_use_parts)//組立後に部品を支えていてはいけないのでA_Supports[1][i].PId
							{
								for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i].Length;
								A_Supports[1][i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != R_use_parts && A_Supports[1][3 + N + i].PId[k] == R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i].PId[A_Supports[1][i].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i].Length == 0)
								{
									A_Supports[1][i].Flag = 0;
								}
								break;
							}
						}

						if (i == Tnum - 1 + N + 3)
						{//中間製品置き場と中間製品の支えの関係を作る
							A_Supports[1][i].Flag = 1;
							//A_Supports[1][i].PId = use_parts;
							//A_Supports[1][i].PId = TyuPa;
							for (k = 0; k < A_Supports[1][i].Length; k++)
							{
								if (A_Supports[1][i].PId[k] == R_use_parts)
								{
									supportflug = supportflug + 2;//右手で扱う部品を持っている時は＋2する
								}
							}
							if (supportflug == 0)//まだ支えられていない時
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = R_use_parts;//中間製品置き場と右手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else
							{
								supportflug = 0;
							}
						}
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					leave(fp2, L_use_parts, hidarite);
					for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
					{//左手、右手、冶具の支えの関係を切る
						//if (A_Supports[1][i].PId == TyuPa)
						f = A_Supports[1][i].Length;//支えている数を保存
						for (k = 0; k < f; k++)
						{
							/*if (A_Supports[1][i].PId == use_parts)
							{
								A_Supports[1][i].Flag = 0;
								A_Supports[1][i].PId = 0;
							}*/
							if (A_Supports[1][i].PId[k] == L_use_parts)//組立後に部品を支えていてはいけないのでA_Supports[1][i].PId
							{
								for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i].Length;
								A_Supports[1][i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != L_use_parts && A_Supports[1][3 + N + i].PId[k] == L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i].PId[A_Supports[1][i].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i].Length == 0)
								{
									A_Supports[1][i].Flag = 0;
								}
								break;
							}
						}

						if (i == Tnum - 1 + N + 3)
						{//中間製品置き場と中間製品の支えの関係を作る
							A_Supports[1][i].Flag = 1;
							//A_Supports[1][i].PId = use_parts;
							//A_Supports[1][i].PId = TyuPa;
							for (k = 0; k < A_Supports[1][i].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][i].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = supportflug + 1;//左手で扱う部品を持っている時は＋1する
								}
							}
							if (supportflug == 0)//まだ支えられていない時
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = L_use_parts;//中間製品置き場と左手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else
							{
								supportflug = 0;
							}
						}
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == hanasu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					WRelease(fp2, L_use_parts, R_use_parts);//両手で放すrelease

					for (supportlength = 0; supportlength < A_Supports[1][hidarite].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][hidarite].PId[supportlength];//値を移す
						A_Supports[1][hidarite].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][hidarite].Length;
					A_Supports[1][hidarite].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != L_use_parts)
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = temp[k];
							A_Supports[1][hidarite].Length++;
						}
					}
					if (A_Supports[1][hidarite].Length == 0)
					{
						A_Supports[1][hidarite].Flag = 0;
					}

					for (supportlength = 0; supportlength < A_Supports[1][migite].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][migite].PId[supportlength];//値を移す
						A_Supports[1][migite].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][migite].Length;
					A_Supports[1][migite].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != use_parts)
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = temp[k];
							A_Supports[1][migite].Length++;
						}
					}
					if (A_Supports[1][migite].Length == 0)
					{
						A_Supports[1][migite].Flag = 0;
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					Release(fp2, R_use_parts, migite);//右手で放すrelease
					for (supportlength = 0; supportlength < A_Supports[1][migite].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][migite].PId[supportlength];//値を移す
						A_Supports[1][migite].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][migite].Length;
					A_Supports[1][migite].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != use_parts)
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = temp[k];
							A_Supports[1][migite].Length++;
						}
					}
					if (A_Supports[1][migite].Length == 0)
					{
						A_Supports[1][migite].Flag = 0;
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					Release(fp2, L_use_parts, hidarite);//左手で放すrelease
					for (supportlength = 0; supportlength < A_Supports[1][hidarite].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][hidarite].PId[supportlength];//値を移す
						A_Supports[1][hidarite].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][hidarite].Length;
					A_Supports[1][hidarite].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != L_use_parts)
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = temp[k];
							A_Supports[1][hidarite].Length++;
						}
					}
					if (A_Supports[1][hidarite].Length == 0)
					{
						A_Supports[1][hidarite].Flag = 0;
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == kumitateru)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					oya_hoji = A_Jigus[Jig].Jnum;
					if (R_line < L_line)
					{
						Kumitate(fp2, A_Supports[1][N + putting + 3 + R_Jig].Id, TyuPa, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
						Kumitate(fp2, A_Supports[1][N + putting + 3 + L_Jig].Id, TyuPa2, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
					}
					else
					{
						Kumitate(fp2, A_Supports[1][N + putting + 3 + L_Jig].Id, TyuPa, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
						Kumitate(fp2, A_Supports[1][N + putting + 3 + R_Jig].Id, TyuPa2, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					oya_hoji = A_Jigus[Jig].Jnum;
					if (R_line < L_line)
					{
						Kumitate(fp2, A_Supports[1][N + putting + 3 + R_Jig].Id, TyuPa, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[L_line].jig - 1].Id, TyuPa2, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
					}
					else
					{
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[L_line].jig - 1].Id, TyuPa, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
						Kumitate(fp2, A_Supports[1][N + putting + 3 + R_Jig].Id, TyuPa2, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
					}

				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					oya_hoji = A_Jigus[Jig].Jnum;
					if (R_line < L_line)
					{
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[R_line].jig - 1].Id, TyuPa, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
						Kumitate(fp2, A_Supports[1][N + putting + 3 + L_Jig].Id, TyuPa2, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
					}
					else
					{
						Kumitate(fp2, A_Supports[1][N + putting + 3 + L_Jig].Id, TyuPa, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[R_line].jig - 1].Id, TyuPa2, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == motinaosu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					L_Turn0X = A_Objects[0][L_use_object].DirX;
					L_Turn1X = A_Objects[1][L_use_object].DirX;
					L_Turn0Y = A_Objects[0][L_use_object].DirY;
					L_Turn1Y = A_Objects[1][L_use_object].DirY;
					L_Turn0Z = A_Objects[0][L_use_object].DirZ;
					L_Turn1Z = A_Objects[1][L_use_object].DirZ;

					R_Turn0X = A_Objects[0][R_use_object].DirX;
					R_Turn1X = A_Objects[1][R_use_object].DirX;
					R_Turn0Y = A_Objects[0][R_use_object].DirY;
					R_Turn1Y = A_Objects[1][R_use_object].DirY;
					R_Turn0Z = A_Objects[0][R_use_object].DirZ;
					R_Turn1Z = A_Objects[1][R_use_object].DirZ;

					WTurn(fp2, L_use_parts, L_Turn0X, L_Turn0Y, L_Turn0Z, L_Turn1X, L_Turn1Y, L_Turn1Z, R_use_parts, R_Turn0X, R_Turn0Y, R_Turn0Z, R_Turn1X, R_Turn1Y, R_Turn1Z);//左手で回転させるturn
					if (M_pattern[movetype].Move[migite][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(R_Turn0X - R_Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(R_Turn0Y - R_Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(R_Turn0Z - R_Turn1Z) + Oyakaitenkakudo;
					}
					if (M_pattern[movetype].Move[hidarite][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(L_Turn0X - L_Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(L_Turn0Y - L_Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(L_Turn0Z - L_Turn1Z) + Oyakaitenkakudo;
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					R_Turn0X = A_Objects[0][R_use_object].DirX;
					R_Turn1X = A_Objects[1][R_use_object].DirX;
					R_Turn0Y = A_Objects[0][R_use_object].DirY;
					R_Turn1Y = A_Objects[1][R_use_object].DirY;
					R_Turn0Z = A_Objects[0][R_use_object].DirZ;
					R_Turn1Z = A_Objects[1][R_use_object].DirZ;

					Turn(fp2, R_use_parts, R_Turn0X, R_Turn0Y, R_Turn0Z, R_Turn1X, R_Turn1Y, R_Turn1Z, migite);//回転させるturn
					if (M_pattern[movetype].Move[migite][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(R_Turn0X - R_Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(R_Turn0Y - R_Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(R_Turn0Z - R_Turn1Z) + Oyakaitenkakudo;
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					L_Turn0X = A_Objects[0][L_use_object].DirX;
					L_Turn1X = A_Objects[1][L_use_object].DirX;
					L_Turn0Y = A_Objects[0][L_use_object].DirY;
					L_Turn1Y = A_Objects[1][L_use_object].DirY;
					L_Turn0Z = A_Objects[0][L_use_object].DirZ;
					L_Turn1Z = A_Objects[1][L_use_object].DirZ;
					Turn(fp2, L_use_parts, L_Turn0X, L_Turn0Y, L_Turn0Z, L_Turn1X, L_Turn1Y, L_Turn1Z, hidarite);
					if (M_pattern[movetype].Move[hidarite][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(L_Turn0X - L_Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(L_Turn0Y - L_Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(L_Turn0Z - L_Turn1Z) + Oyakaitenkakudo;
					}
				}
			}
		}
	}
	for (i = 0; i < 2; i++)
	{
		//手の最終座標を合わせる
		A_Objects[1][2 * N - 1 + i].IchiX = A_Objects[0][2 * N - 1 + i].IchiX;
		A_Objects[1][2 * N - 1 + i].IchiY = A_Objects[0][2 * N - 1 + i].IchiY;
		A_Objects[1][2 * N - 1 + i].IchiZ = A_Objects[0][2 * N - 1 + i].IchiZ;
	}
	if (kumijun[line].kougu != 0)//工具を用いる時
	{
		A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiX = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiX;//工具の座標を更新
		A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiY = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY;
		A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY;
	}
}

void kumitatego_to_finish(FILE* fp2, int line, int movetype)
{
	int i = 0, R_length = 0, L_length = 0, length = 0, /*movetype = 0,*/ Te = 0, nowmove = 0, Jig = 0;
	int OyaPa, KoPa, TyuPa, Jigbangou = 0;//親部品番号,子部品番号,中間製品
	double IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Turn0X, Turn0Y, Turn0Z, Turn1X, Turn1Y, Turn1Z;
	int Oyanum = 0;//親部品が何番目にあるか
	int use_parts = 0/*使用する部品番号*/, use_object = 0/*使用する部品がobjectでどこにあるか*/;
	int R_use_parts = 0/*右手で使用する部品番号*/, R_use_object = 0;/*右手で使用する部品がobjectでどこにあるか*/
	int L_use_parts = 0/*左手で使用する部品番号*/, L_use_object = 0;/*左手で使用する部品がobjectでどこにあるか*/
	double R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2, R_Turn0X, R_Turn0Y, R_Turn0Z, R_Turn1X, R_Turn1Y, R_Turn1Z;
	double L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, L_Turn0X, L_Turn0Y, L_Turn0Z, L_Turn1X, L_Turn1Y, L_Turn1Z;
	int temp[MaxSupport], templength = 0;

	int R_Jig = 0, L_Jig = 0, R_Jigbangou = 0, L_Jigbangou = 0, R_TyuPa = 0, L_TyuPa = 0, TyuPa2 = 0, R_line = 0/*両手の時右手の組付けが一行目か二行目かどうかを保管*/, L_line = 0/*両手の時右手の組付けが一行目か二行目かどうかを保管*/;
	int supportlength = 0, k = 0, supportflug = 0, f = 0;
	int KouguBnum = 0, Kougunum = 0, KouguPnum = 0;//KouguBnum：レイアウト情報での工具の番号、Kougunum：工具番号,KouguPnum：工具がobjectsでどこにあるか
	int ChangeKouguBnum = 0, ChangeKougunum = 0, ChangeKouguPnum = 0;//ChangeKouguBnum：レイアウト情報での交換する工具の番号、ChangeKougunum：交換する工具番号,ChangeKouguPnum：交換する工具がobjectsでどこにあるか
	int TempKougunum = 0;
	int BeforeJig = 0;
	int BeforeJigR = 0, BeforeJigL = 0;

	TyuPa2 = kumijun[line + 1].tyukan;

	R_length = M_pattern[movetype].length[migite];
	L_length = M_pattern[movetype].length[hidarite];
	KoPa = kumijun[line].ko;
	OyaPa = kumijun[line].oya;
	TyuPa = kumijun[line].tyukan;
	if (NewNOS0 == 0)
	{
		Jig = kumijun[line].jig - 1;
		Kougunum = kumijun[line].kougu - 1;
		ChangeKougunum = kumijun[line - 1].kougu - 1;
	}
	else
	{
		for (i = 0; i < Jigu; i++)
		{
			if (A_Objects[0][3 * N + 2 + i + putting].Id == kumijun[line].jig)
			{
				Jig = i;
				break;
			}
		}
		for (i = 0; i < Kougu; i++)
		{
			if (A_Objects[0][3 * N + 2 + i + putting + Jigu].Id == kumijun[line].kougu)
			{
				Kougunum = i;
				break;
			}
		}
		for (i = 0; i < Kougu; i++)
		{
			if (A_Objects[0][3 * N + 2 + i + putting + Jigu].Id == kumijun[line - 1].kougu)
			{
				ChangeKougunum = i;
				break;
			}
		}
	}
	Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
	//Kougunum = kumijun[line].kougu;
	KouguBnum = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].Id;
	//ChangeKougunum = kumijun[line-1].kougu;
	ChangeKouguBnum = A_Objects[0][3 * N + 2 + ChangeKougunum + putting + Jigu].Id;

	if (R_length > L_length)
	{
		length = R_length;
	}
	else
	{
		length = L_length;
	}

	for (nowmove = 0; nowmove <= length; nowmove++)
	{
		if (M_pattern[movetype].Move[migite][nowmove][move] != none && M_pattern[movetype].Move[hidarite][nowmove][move] != none)//右手左手両方に同時に動作がある時
		{
			Te = ryoute;
		}
		else if (M_pattern[movetype].Move[migite][nowmove][move] != none)//右手に作業がある時
		{
			Te = migite;
		}
		else if (M_pattern[movetype].Move[hidarite][nowmove][move] != none)//左手に動作がある時
		{
			Te = hidarite;
		}

		//どの部品を対象とするかを調べる
		if (Te == migite || Te == hidarite)//両手で同時に作業をしない時
		{
			if (M_pattern[movetype].Move[Te][nowmove][target] == Oya)//対象製品が親部品
			{
				if (Oya2flag == 1)//基準部品が最初の部品の時
				{//2番目の部品が対象の部品になる
					use_parts = kumijun[line + 1].oya;
					use_object = OyaPnum;
				}
				else if (Oya2flag == 2)//基準部品が2番目の部品の時
				{//最初の部品が対象の部品になる
					use_parts = kumijun[line].oya;
					use_object = OyaPnum1;
				}
				else
				{
					use_parts = OyaPa;
					if (kumijun[line].scene_type == oya1ko2)
					{
						use_object = OyaPnum1;
					}
					else
					{
						use_object = OyaPnum;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Ko)//対象製品が子部品
			{
				use_parts = KoPa;
				use_object = KoPnum;
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Tyukan)//対象製品が中間製品
			{
				use_parts = TyuPa;
				use_object = TyuPnum;
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Start_P)//手を初期位置に戻すとき、対象製品は使用する手
			{
				use_object = 2 * N - 1 + Te;
			}

			else if (M_pattern[movetype].Move[Te][nowmove][target] == Ko1)//両手2部品の時の右手で扱う子部品
			{
				use_parts = A_Objects[0][R_KoPnum].Id;
				use_object = R_KoPnum;
				if (Oya2flag == 2)
				{
					use_object = KoPnum1;
				}
				else if (Oya2flag == 1)
				{
					use_object = KoPnum1;
				}
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].ko == R_use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						OyaPa = kumijun[i].oya;
						KoPa = kumijun[i].ko;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Oya1)//両手2部品の時の右手で扱う親部品
			{
				use_parts = A_Objects[0][R_OyaPnum].Id;
				use_object = R_OyaPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].oya == R_use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Tyukan1)//両手2部品の時の右手で扱う中間製品部品
			{
				use_parts = A_Objects[0][R_TyuPnum].Id;
				use_object = R_TyuPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].tyukan == use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Ko2)//両手2部品の時の左手で扱う子部品
			{
				use_parts = A_Objects[0][L_KoPnum].Id;
				use_object = L_KoPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].ko == use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						OyaPa = kumijun[i].oya;
						KoPa = kumijun[i].ko;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[line].jig - 1;
						}
						else
						{
							for (i = 0; i < Jigu; i++)
							{
								if (A_Objects[0][3 * N + 2 + i + putting].Id == kumijun[line].jig)
								{
									Jig = i;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Oya2)//両手2部品の時の左手で扱う親部品
			{
				use_parts = A_Objects[0][L_OyaPnum].Id;
				use_object = L_OyaPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].oya == use_parts)
					{
						OyaPa = kumijun[i].oya;
						KoPa = kumijun[line].ko;
						TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Tyukan2)//両手2部品の時の左手で扱う中間製品部品
			{
				use_parts = A_Objects[0][L_TyuPnum].Id;
				use_object = L_TyuPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].tyukan == L_use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)
			{
				use_parts = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].Id;
				use_object = 3 * N + 2 + Kougunum + putting + Jigu;
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == ChangeKOUGU)
			{
				use_parts = A_Objects[0][3 * N + 2 + ChangeKougunum + putting + Jigu].Id;
				use_object = 3 * N + 2 + ChangeKougunum + putting + Jigu;
			}

			if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == nobasu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{//Te = M_pattern[movetype].kobuhin[nowmove][Hand];
				//もともと治具に付いている部品(親部品)に手を伸ばす
					IchiX1 = A_Objects[0][2 * N - 1 + Te].IchiX;//使用する手の現在の位置
					IchiY1 = A_Objects[0][2 * N - 1 + Te].IchiY;
					IchiZ1 = A_Objects[0][2 * N - 1 + Te].IchiZ;
					if (M_pattern[movetype].Move[Te][nowmove][target] == Start_P)
					{
						IchiX2 = A_Objects[1][use_object].IchiX;
						IchiY2 = A_Objects[1][use_object].IchiY;
						IchiZ2 = A_Objects[1][use_object].IchiZ;
					}
					else
					{
						IchiX2 = A_Objects[0][use_object].IchiX;
						IchiY2 = A_Objects[0][use_object].IchiY;
						IchiZ2 = A_Objects[0][use_object].IchiZ;
					}
					/*IchiX2 = A_Objects[0][OyaPnum].IchiX;
					IchiY2 = A_Objects[0][OyaPnum].IchiY;
					IchiZ2 = A_Objects[0][OyaPnum].IchiZ;*/

					Reach(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);

					A_Objects[0][2 * N - 1 + Te].IchiX = IchiX2;//手の座標を更新
					A_Objects[0][2 * N - 1 + Te].IchiY = IchiY2;
					A_Objects[0][2 * N - 1 + Te].IchiZ = IchiZ2;
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == tsukamu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = Te;//部品を持っている手を記録
					if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)//対象が工具の時は工具を使用していることを記録しておく
					{
						Kouguflag = KouguBnum;
					}
					Gripping(fp2, use_parts, Te);//掴む
					//Gripping(fp2, TyuPa, Te);//掴む
					if (A_Supports[1][Te].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][Te].Id = A_Hands[Te].Hnum;//部品と手の支えの関係をつくる
						A_Supports[1][Te].Flag = 1;
						A_Supports[1][Te].PId[0] = use_parts;
						A_Supports[1][Te].Length++;
					}
					else
					{
						A_Supports[1][Te].Id = A_Hands[Te].Hnum;
						A_Supports[1][Te].Flag = 1;
						for (k = 0; k < A_Supports[1][Te].Length; k++)
						{
							//A_Supports[0][Te].PId = use_parts;
							if (A_Supports[1][Te].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][Te].PId[A_Supports[1][Te].Length] = use_parts;//部品と手の支えの関係をつくる
							A_Supports[1][Te].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
					//A_Supports[1][Te].PId = TyuPa;
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == tsukamitoru)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = Te;//部品を持っている手を記録
					if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)//対象が工具の時は工具を使用していることを記録しておく
					{
						Kouguflag = KouguBnum;
					}

					if (JigKobuhin == use_parts || JigKobuhin2 == use_parts || ChangeJig == use_parts || ChangeJig2 == use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == use_parts)
								{
									BeforeJig = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					//部品箱の支えの関係を切る
					for (i = 0; i < Bboxnum; i++)
					{
						for (k = 0; k < A_Supports[1][i + 2].Length; k++)
						{
							if (A_Supports[1][i + 2].PId[k] == use_parts) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
							   //A_Supports[1][i + 2].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i + 2].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i + 2].Length;
								A_Supports[1][i + 2].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i + 2].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i + 2].Length == 0)
								{
									A_Supports[1][i + 2].Flag = 0;
								}
								break;
							}
						}
					}
					for (i = 0; i < putting; i++)
					{//中間製品置き場からとるとき、支えの関係を切る
						//if (A_Supports[0][3 + N + i].PId == OyaPa)
						/*if (A_Supports[0][3 + N + i].PId == use_parts)
						{
							A_Supports[1][3 + N + i].Flag = 0;
							A_Supports[1][3 + N + i].PId = 0;
						}*/
						for (k = 0; k < A_Supports[1][3 + N + i].Length; k++)
						{
							if (A_Supports[1][3 + N + i].PId[k] == use_parts) {//A_Supports[][0],A_Supports[][1]には
							   //A_Supports[1][3 + N + i].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][3 + N + i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][3 + N + i].Length;
								A_Supports[1][3 + N + i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = temp[supportlength];//データの移行
										A_Supports[1][3 + N + i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][3 + N + i].Length == 0)
								{
									A_Supports[1][3 + N + i].Flag = 0;
								}
								break;
							}
						}
					}

					if (A_Supports[1][Te].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][Te].Id = A_Hands[Te].Hnum;//部品と手の支えの関係をつくる
						A_Supports[1][Te].Flag = 1;
						A_Supports[1][Te].PId[0] = use_parts;
						A_Supports[1][Te].Length++;
					}
					else
					{
						A_Supports[1][Te].Id = A_Hands[Te].Hnum;
						A_Supports[1][Te].Flag = 1;
						for (k = 0; k < A_Supports[1][Te].Length; k++)
						{
							//A_Supports[0][Te].PId = use_parts;
							if (A_Supports[1][Te].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][Te].PId[A_Supports[1][Te].Length] = use_parts;//部品と手の支えの関係をつくる
							A_Supports[1][Te].Length++;
						}
						else
						{
							supportflug = 0;
						}

					}
					//A_Supports[0][Te].PId = OyaPa;

					Grip(fp2, use_parts, BeforeJig, Te);//掴み取る grip
					//Grip(fp2, OyaPa, Te);//掴み取る grip
					BeforeJig = 0;
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == hakobu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					//Te = M_pattern[movetype].kobuhin[nowmove][Hand];

					IchiX1 = A_Objects[0][2 * N - 1 + Te].IchiX;
					IchiY1 = A_Objects[0][2 * N - 1 + Te].IchiY;
					IchiZ1 = A_Objects[0][2 * N - 1 + Te].IchiZ;
					IchiX2 = A_Objects[1][use_object].IchiX;
					IchiY2 = A_Objects[1][use_object].IchiY;
					IchiZ2 = A_Objects[1][use_object].IchiZ;
					/*IchiX2 = A_Objects[1][TyuPnum].IchiX;
					IchiY2 = A_Objects[1][TyuPnum].IchiY;
					IchiZ2 = A_Objects[1][TyuPnum].IchiZ;*/

					Carry(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);//左手で運ぶ carry

					A_Objects[0][2 * N - 1 + Te].IchiX = IchiX2;//手の座標を更新
					A_Objects[0][2 * N - 1 + Te].IchiY = IchiY2;
					A_Objects[0][2 * N - 1 + Te].IchiZ = IchiZ2;

					A_Objects[0][use_object].IchiX = IchiX2;//部品の座標を更新
					A_Objects[0][use_object].IchiY = IchiY2;
					A_Objects[0][use_object].IchiZ = IchiZ2;

					if ((Kouguflag != 0 && M_pattern[movetype].Move[Te][nowmove][target] == Ko) || M_pattern[movetype].Move[Te][nowmove][target] == KOUGU || M_pattern[movetype].Move[Te][nowmove][target] == ChangeKOUGU)//工具を用いて部品を運ぶ場合は工具の座標も変更
					{
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiX = IchiX2;//工具の座標を更新
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY = IchiY2;
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = IchiZ2;
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == okihanasu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = -1;//部品を持っている手がないことを記録
					if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)//対象が工具の時は工具を使用していないのでフラグを0に戻す
					{
						Kouguflag = 0;
					}

					for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
					{//左手、右手、冶具の支えの関係を切る
						//if (A_Supports[1][i].PId == TyuPa)
						f = A_Supports[1][i].Length;//支えている数を保存
						for (k = 0; k < f; k++)
						{
							/*if (A_Supports[1][i].PId == use_parts)
							{
								A_Supports[1][i].Flag = 0;
								A_Supports[1][i].PId = 0;
							}*/
							if (A_Supports[1][i].PId[k] == use_parts)//組立後に部品を支えていてはいけないのでA_Supports[1][i].PId
							{
								for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i].Length;
								A_Supports[1][i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != use_parts)//一致する部品は支えない部品なのでカウントしない
									{
										A_Supports[1][i].PId[A_Supports[1][i].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i].Length == 0)
								{
									A_Supports[1][i].Flag = 0;
								}
								break;
							}
						}

						if (i == Tnum - 1 + N + 3)
						{//中間製品置き場と中間製品の支えの関係を作る
							A_Supports[1][i].Flag = 1;
							//A_Supports[1][i].PId = use_parts;
							//A_Supports[1][i].PId = TyuPa;
							for (k = 0; k < A_Supports[1][i].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][i].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = 1;
									break;
								}
							}
							if (supportflug == 0)//まだ支えられていない時
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = use_parts;//親部品と手の支えの関係をつくる
								A_Supports[1][i].Length++;
							}
							else
							{
								supportflug = 0;
							}
						}
					}

					leave(fp2, use_parts, Te);//置き放す leave
					//leave(fp2, TyuPa, Te);//置き放す leave
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == tsukeru)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = Te;//部品を持っている手を記録

					if (M_pattern[movetype].Move[Te][nowmove][destination] == KOUGU)//付ける対象が工具の時は工具に付ける
					{
						Fix(fp2, KouguBnum, use_parts, Te);//付ける fix
						//Fix(fp2, Jigbangou, OyaPa, Te);//付ける fix

						//工具と親部品の支えの関係をつくる
						A_Supports[1][N + 3 + putting + Jigu + Kougunum].Id = A_Kougus[Kougunum].Bnum;
						A_Supports[1][N + 3 + putting + Jigu + Kougunum].Flag = 1;

						if (A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length == 0)
						{
							A_Supports[1][N + 3 + putting + Jigu + Kougunum].PId[A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length] = use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length++;
						}
						else
						{
							for (k = 0; k < A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][N + 3 + putting + Jigu + Kougunum].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = 1;
									break;
								}

								if (supportflug == 0)//まだ支えられていない時
								{
									A_Supports[1][N + 3 + putting + Jigu + Kougunum].PId[A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length] = use_parts;//親部品と手の支えの関係をつくる
									A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length++;
									break;
								}
								else
								{
									supportflug = 0;
								}
							}
						}
					}
					else
					{
						Fix(fp2, Jigbangou, use_parts, Te);//付ける fix
					   //Fix(fp2, Jigbangou, OyaPa, Te);//付ける fix

					   //治具と親部品の支えの関係をつくる
						A_Supports[1][3 + N + putting + Jig].Id = A_Jigus[Jig].Jnum;
						A_Supports[1][3 + N + putting + Jig].Flag = 1;
						//A_Supports[1][3 + N + putting + Jig].PId = use_parts;
						//A_Supports[1][3 + N + putting + Jig].PId = OyaPa;

						if (A_Supports[1][3 + N + putting + Jig].Length == 0)
						{
							A_Supports[1][3 + N + putting + Jig].PId[A_Supports[1][3 + N + putting + Jig].Length] = use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + Jig].Length++;
						}
						else
						{
							for (k = 0; k < A_Supports[1][3 + N + putting + Jig].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][3 + N + putting + Jig].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = 1;
									break;
								}

								if (supportflug == 0)//まだ支えられていない時
								{
									A_Supports[1][3 + N + putting + Jig].PId[A_Supports[1][3 + N + putting + Jig].Length] = use_parts;//親部品と手の支えの関係をつくる
									A_Supports[1][3 + N + putting + Jig].Length++;
									break;
								}
								else
								{
									supportflug = 0;
								}
							}
						}
						oya_hoji = A_Jigus[Jig].Jnum;
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == hazusu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					if (M_pattern[movetype].Move[Te][nowmove][destination] == KOUGU || M_pattern[movetype].Move[Te][nowmove][destination] == ChangeKOUGU)
					{
						if (M_pattern[movetype].Move[Te][nowmove][destination] == ChangeKOUGU)
						{
							TempKougunum = ChangeKougunum;
						}
						else
						{
							TempKougunum = Kougunum;
						}

						Remove(fp2, A_Objects[0][3 * N + 2 + TempKougunum + putting + Jigu].Id, use_parts, Te);//外す remove
						//Remove(fp2, Jigbangou, TyuPa, Te);//外す remove
						//治具と親部品の支えの関係を切る
						//A_Supports[1][3 + N + putting + Jig].PId = 0;

						for (supportlength = 0; supportlength < A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length; supportlength++)
						{
							temp[supportlength] = 0;//配列の初期化
							temp[supportlength] = A_Supports[1][N + 3 + putting + Jigu + TempKougunum].PId[supportlength];//値を移す
							A_Supports[1][N + 3 + putting + Jigu + TempKougunum].PId[supportlength] = 0;//配列の初期化
						}
						templength = 0;
						templength = A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length;
						A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length = 0;//一旦0にする
						for (k = 0; k < templength; k++)
						{
							if (temp[k] != use_parts)
							{
								A_Supports[1][N + 3 + putting + Jigu + TempKougunum].PId[A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length] = temp[k];
								A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length++;
							}
						}
						if (A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length == 0)
						{
							A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Flag = 0;
						}
					}
					else
					{
						Remove(fp2, Jigbangou, use_parts, Te);//外す remove
						//Remove(fp2, Jigbangou, TyuPa, Te);//外す remove
						//治具と親部品の支えの関係を切る
						//A_Supports[1][3 + N + putting + Jig].PId = 0;

						for (supportlength = 0; supportlength < A_Supports[1][3 + N + putting + Jig].Length; supportlength++)
						{
							temp[supportlength] = 0;//配列の初期化
							temp[supportlength] = A_Supports[1][3 + N + putting + Jig].PId[supportlength];//値を移す
							A_Supports[1][3 + N + putting + Jig].PId[supportlength] = 0;//配列の初期化
						}
						templength = 0;
						templength = A_Supports[1][3 + N + putting + Jig].Length;
						A_Supports[1][3 + N + putting + Jig].Length = 0;//一旦0にする
						for (k = 0; k < templength; k++)
						{
							if (temp[k] != use_parts)
							{
								A_Supports[1][3 + N + putting + Jig].PId[A_Supports[1][3 + N + putting + Jig].Length] = temp[k];
								A_Supports[1][3 + N + putting + Jig].Length++;
							}
						}
						if (A_Supports[1][3 + N + putting + Jig].Length == 0)
						{
							A_Supports[1][3 + N + putting + Jig].Flag = 0;
						}
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == hanasu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = -1;//部品を持っている手がないことを記録
					if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)//対象が工具の時は工具を使用していないのでフラグを0に戻す
					{
						Kouguflag = 0;
					}
					Release(fp2, use_parts, Te);//放すrelease
					//Release(fp2, OyaPa, Te);//放すrelease
					//親部品と手の支えの関係を切る
					//A_Supports[0][Te].Flag = 0;
					//A_Supports[0][Te].PId = 0;
					for (supportlength = 0; supportlength < A_Supports[1][Te].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][Te].PId[supportlength];//値を移す
						A_Supports[1][Te].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][Te].Length;
					A_Supports[1][Te].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != use_parts)
						{
							A_Supports[1][Te].PId[A_Supports[1][Te].Length] = temp[k];
							A_Supports[1][Te].Length++;
						}
					}
					if (A_Supports[1][Te].Length == 0)
					{
						A_Supports[1][Te].Flag = 0;
					}

					if (Kouguflag != 0)
					{
						for (supportlength = 0; supportlength < A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length; supportlength++)
						{
							temp[supportlength] = 0;//配列の初期化
							temp[supportlength] = A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId[supportlength];//値を移す
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId[supportlength] = 0;//配列の初期化
						}
						templength = 0;
						templength = A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length;
						A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length = 0;//一旦0にする
						for (k = 0; k < templength; k++)
						{
							if (temp[k] != use_parts)
							{
								A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId[A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length] = temp[k];
								A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length++;
							}
						}
						if (A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length == 0)
						{
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].Flag = 0;
						}
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == motinaosu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					Turn0X = A_Objects[0][use_object].DirX;
					Turn1X = A_Objects[1][use_object].DirX;
					Turn0Y = A_Objects[0][use_object].DirY;
					Turn1Y = A_Objects[1][use_object].DirY;
					Turn0Z = A_Objects[0][use_object].DirZ;
					Turn1Z = A_Objects[1][use_object].DirZ;

					Turn(fp2, use_parts, Turn0X, Turn0Y, Turn0Z, Turn1X, Turn1Y, Turn1Z, Te);//左手で回転させるturn
					if (M_pattern[movetype].Move[Te][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(Turn0X - Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(Turn0Y - Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(Turn0Z - Turn1Z) + Oyakaitenkakudo;
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == kumitateidou)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = Te;//部品を持っている手を記録
					/*IchiX1 = A_Objects[1][KoPnum].IchiX;
					IchiY1 = A_Objects[1][KoPnum].IchiY;
					IchiZ1 = A_Objects[1][KoPnum].IchiZ;*/
					IchiX1 = A_Objects[0][2 * N - 1 + Te].IchiX;
					IchiY1 = A_Objects[0][2 * N - 1 + Te].IchiY;
					IchiZ1 = A_Objects[0][2 * N - 1 + Te].IchiZ;

					if (kumijun[line].scene_type == oya2ko1)
					{
						/*if (Oya2flag == 1 || Oya2flag == 3)
						{
							IchiX2 = KIdo_X1;
							IchiY2 = KIdo_Y1;
							IchiZ2 = KIdo_Z1;
						}
						else if (Oya2flag == 2)
						{
							IchiX2 = KIdo_X;
							IchiY2 = KIdo_Y;
							IchiZ2 = KIdo_Z;
						}*/
						IchiX2 = KIdo_X1;
						IchiY2 = KIdo_Y1;
						IchiZ2 = KIdo_Z1;
					}
					else
					{
						IchiX2 = KIdo_X;
						IchiY2 = KIdo_Y;
						IchiZ2 = KIdo_Z;
					}

					Kumimove(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);//組立移動Kumimove

					A_Objects[0][2 * N - 1 + Te].IchiX = IchiX2;//手の座標を更新
					A_Objects[0][2 * N - 1 + Te].IchiY = IchiY2;
					A_Objects[0][2 * N - 1 + Te].IchiZ = IchiZ2;

					A_Objects[0][use_object].IchiX = IchiX2;//部品の座標を更新
					A_Objects[0][use_object].IchiY = IchiY2;
					A_Objects[0][use_object].IchiZ = IchiZ2;

					A_Objects[1][use_object].IchiX = IchiX2;//部品の座標を更新
					A_Objects[1][use_object].IchiY = IchiY2;
					A_Objects[1][use_object].IchiZ = IchiZ2;

					if ((Kouguflag != 0 && M_pattern[movetype].Move[Te][nowmove][target] == Ko) || M_pattern[movetype].Move[Te][nowmove][target] == KOUGU || M_pattern[movetype].Move[Te][nowmove][target] == ChangeKOUGU)//工具を用いて部品を運ぶ場合は工具の座標も変更
					{
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiX = IchiX2;//部品の座標を更新
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY = IchiY2;
						A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = IchiZ2;
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == kumitateru)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					//Te = M_pattern[movetype].kobuhin[nowmove][Hand];
					/*if (kumijun[line].scene_type == oya2ko1)
					{
						Kumitate(fp2, A_Supports[0][N + putting + 3 + kumijun[line].jig - 1].Id, kumijun[line].tyukan, kumijun[line].oya, kumijun[line].ko, Te);//右手で組立Kumitate
						Kumitate(fp2, A_Supports[0][N + putting + 3 + kumijun[line + 1].jig - 1].Id, kumijun[line + 1].tyukan, kumijun[line + 1].oya, kumijun[line + 1].ko, Te);//右手で組立Kumitate
					}*/
					if (kumijun[line].kougu != 0)//工具を用いて組立を行う時
					{
						KouguKumi(fp2, Jigbangou, KouguBnum, TyuPa, OyaPa, KoPa);
					}
					else
					{
						Kumitate(fp2, Jigbangou, TyuPa, OyaPa, KoPa, Te);//組立Kumitate
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == sentanhenkou)
			{
				Tipmove(fp2, line, M_pattern[movetype].Move[Te][nowmove][target], Te);
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == hakobu_tsuika)
			{
				IchiX1 = A_Objects[0][2 * N - 1 + Te].IchiX;
				IchiY1 = A_Objects[0][2 * N - 1 + Te].IchiY;
				IchiZ1 = A_Objects[0][2 * N - 1 + Te].IchiZ;
				IchiX2 = A_Objects[1][use_object].IchiX + M_pattern[movetype].Move_addition[Te][nowmove][0];
				IchiY2 = A_Objects[1][use_object].IchiY + M_pattern[movetype].Move_addition[Te][nowmove][1];
				IchiZ2 = A_Objects[1][use_object].IchiZ + M_pattern[movetype].Move_addition[Te][nowmove][2];

				Carry(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);//左手で運ぶ carry

				A_Objects[0][2 * N - 1 + Te].IchiX = IchiX2;//手の座標を更新
				A_Objects[0][2 * N - 1 + Te].IchiY = IchiY2;
				A_Objects[0][2 * N - 1 + Te].IchiZ = IchiZ2;

				A_Objects[0][use_object].IchiX = IchiX2;//部品の座標を更新
				A_Objects[0][use_object].IchiY = IchiY2;
				A_Objects[0][use_object].IchiZ = IchiZ2;


				if ((Kouguflag != 0 && M_pattern[movetype].Move[Te][nowmove][target] == Ko) || M_pattern[movetype].Move[Te][nowmove][target] == KOUGU || M_pattern[movetype].Move[Te][nowmove][target] == ChangeKOUGU)//工具を用いて部品を運ぶ場合は工具の座標も変更
				{
					A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiX = IchiX2;//部品の座標を更新
					A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY = IchiY2;
					A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = IchiZ2;
				}

			}
		}
		else if (Te == ryoute)
		{
			//右手の対象を決める
			if (M_pattern[movetype].Move[migite][nowmove][target] == Oya)//対象製品が親部品
			{

				if (Oya2flag == 1)//基準部品が最初の部品の時
				{//2番目の部品が対象の部品になる
					R_use_parts = kumijun[line + 1].oya;
					R_use_object = OyaPnum;
				}
				else if (Oya2flag == 2)//基準部品が2番目の部品の時
				{//最初の部品が対象の部品になる
					R_use_parts = kumijun[line].oya;
					R_use_object = OyaPnum1;
				}
				else
				{
					R_use_parts = OyaPa;
					R_use_object = OyaPnum;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Ko)//対象製品が子部品
			{
				R_use_parts = KoPa;
				R_use_object = KoPnum;
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Tyukan)//対象製品が中間製品
			{
				R_use_parts = TyuPa;
				R_use_object = TyuPnum;
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Start_P)//手を初期位置に戻すとき、対象製品は使用する手
			{
				R_use_object = 2 * N - 1 + migite;
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Ko1)//両手2部品の時の右手で扱う子部品
			{
				R_use_parts = A_Objects[0][R_KoPnum].Id;
				R_use_object = R_KoPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].ko == R_use_parts)
					{
						R_TyuPa = kumijun[i].tyukan;
						R_line = i;
						if (NewNOS0 == 0)
						{
							R_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									R_Jig = k;
									break;
								}

							}
						}

						R_Jigbangou = A_Supports[0][N + putting + 3 + R_Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Oya1)//両手2部品の時の右手で扱う親部品
			{
				R_use_parts = A_Objects[0][R_OyaPnum].Id;
				R_use_object = R_OyaPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].oya == R_use_parts)
					{
						R_TyuPa = kumijun[i].tyukan;
						R_line = i;
						if (NewNOS0 == 0)
						{
							R_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									R_Jig = k;
									break;
								}

							}
						}
						R_Jigbangou = A_Supports[0][N + putting + 3 + R_Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Tyukan1)//両手2部品の時の右手で扱う中間製品部品
			{
				R_use_parts = A_Objects[0][R_TyuPnum].Id;
				R_use_object = R_TyuPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].tyukan == R_use_parts)
					{
						R_TyuPa = kumijun[i].tyukan;
						R_line = i;
						if (NewNOS0 == 0)
						{
							R_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									R_Jig = k;
									break;
								}

							}
						}
						R_Jigbangou = A_Supports[0][N + putting + 3 + R_Jig].Id;
					}
				}
			}

			//左手の対象を決める
			if (M_pattern[movetype].Move[hidarite][nowmove][target] == Oya)//対象製品が親部品
			{
				if (Oya2flag == 1)//基準部品が最初の部品の時
				{//2番目の部品が対象の部品になる
					L_use_parts = kumijun[line + 1].oya;
					L_use_object = OyaPnum;
				}
				else if (Oya2flag == 2)//基準部品が2番目の部品の時
				{//最初の部品が対象の部品になる
					L_use_parts = kumijun[line].oya;
					L_use_object = OyaPnum1;
				}
				else
				{
					L_use_parts = OyaPa;
					L_use_object = OyaPnum;
				}
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Ko)//対象製品が子部品
			{
				L_use_parts = KoPa;
				L_use_object = KoPnum;
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Tyukan)//対象製品が中間製品
			{
				L_use_parts = TyuPa;
				L_use_object = TyuPnum;
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Start_P)//手を初期位置に戻すとき、対象製品は使用する手
			{
				L_use_object = 2 * N - 1 + hidarite;
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Ko2)//両手2部品の時の左手で扱う子部品
			{
				L_use_parts = A_Objects[0][L_KoPnum].Id;
				L_use_object = L_KoPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].ko == L_use_parts)
					{
						L_TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							L_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									L_Jig = k;
									break;
								}

							}
						}
						L_Jigbangou = A_Supports[0][N + putting + 3 + L_Jig].Id;
						L_line = i;
					}
				}
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Oya2)//両手2部品の時の左手で扱う親部品
			{
				L_use_parts = A_Objects[0][L_OyaPnum].Id;
				L_use_object = L_OyaPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].oya == L_use_parts)
					{
						L_TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							L_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									L_Jig = k;
									break;
								}

							}
						}
						L_Jigbangou = A_Supports[0][N + putting + 3 + L_Jig].Id;
						L_line = i;
					}
				}
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Tyukan2)//両手2部品の時の左手で扱う中間製品部品
			{
				L_use_parts = A_Objects[0][L_TyuPnum].Id;
				L_use_object = L_TyuPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].tyukan == L_use_parts)
					{
						L_TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							L_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									L_Jig = k;
									break;
								}

							}
						}
						L_Jigbangou = A_Supports[0][N + putting + 3 + L_Jig].Id;
						L_line = i;
					}
				}
			}

			if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[hidarite][nowmove][move]) == nobasu)//右手と左手が同じ動作で伸ばすの時
			{
				//右手と左手の部品に回転があるときに必要、もしくは右手と左手にこの動作が指定されているとき
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{//Te = M_pattern[movetype].kobuhin[nowmove][Hand];
				//もともと治具に付いている部品(親部品)に手を伸ばす

					L_IchiX1 = A_Objects[0][2 * N - 1 + hidarite].IchiX;//使用する手の現在の位置
					L_IchiY1 = A_Objects[0][2 * N - 1 + hidarite].IchiY;
					L_IchiZ1 = A_Objects[0][2 * N - 1 + hidarite].IchiZ;
					L_IchiX2 = A_Objects[0][L_use_object].IchiX;
					L_IchiY2 = A_Objects[0][L_use_object].IchiY;
					L_IchiZ2 = A_Objects[0][L_use_object].IchiZ;

					R_IchiX1 = A_Objects[0][2 * N - 1 + migite].IchiX;//使用する手の現在の位置
					R_IchiY1 = A_Objects[0][2 * N - 1 + migite].IchiY;
					R_IchiZ1 = A_Objects[0][2 * N - 1 + migite].IchiZ;
					R_IchiX2 = A_Objects[0][R_use_object].IchiX;
					R_IchiY2 = A_Objects[0][R_use_object].IchiY;
					R_IchiZ2 = A_Objects[0][R_use_object].IchiZ;
					/*IchiX2 = A_Objects[0][OyaPnum].IchiX;
					IchiY2 = A_Objects[0][OyaPnum].IchiY;
					IchiZ2 = A_Objects[0][OyaPnum].IchiZ;*/

					WReach(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					R_IchiX1 = A_Objects[0][2 * N - 1 + migite].IchiX;//使用する手の現在の位置
					R_IchiY1 = A_Objects[0][2 * N - 1 + migite].IchiY;
					R_IchiZ1 = A_Objects[0][2 * N - 1 + migite].IchiZ;
					R_IchiX2 = A_Objects[0][R_use_object].IchiX;
					R_IchiY2 = A_Objects[0][R_use_object].IchiY;
					R_IchiZ2 = A_Objects[0][R_use_object].IchiZ;

					Reach(fp2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2, migite);

					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;

				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					L_IchiX1 = A_Objects[0][2 * N - 1 + hidarite].IchiX;//使用する手の現在の位置
					L_IchiY1 = A_Objects[0][2 * N - 1 + hidarite].IchiY;
					L_IchiZ1 = A_Objects[0][2 * N - 1 + hidarite].IchiZ;
					L_IchiX2 = A_Objects[0][L_use_object].IchiX;
					L_IchiY2 = A_Objects[0][L_use_object].IchiY;
					L_IchiZ2 = A_Objects[0][L_use_object].IchiZ;

					Reach(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, hidarite);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == hakobu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					//Te = M_pattern[movetype].kobuhin[nowmove][Hand];

					L_IchiX1 = A_Objects[0][2 * N - 1 + hidarite].IchiX;
					L_IchiY1 = A_Objects[0][2 * N - 1 + hidarite].IchiY;
					L_IchiZ1 = A_Objects[0][2 * N - 1 + hidarite].IchiZ;
					L_IchiX2 = A_Objects[1][L_use_object].IchiX;
					L_IchiY2 = A_Objects[1][L_use_object].IchiY;
					L_IchiZ2 = A_Objects[1][L_use_object].IchiZ;

					R_IchiX1 = A_Objects[0][2 * N - 1 + migite].IchiX;
					R_IchiY1 = A_Objects[0][2 * N - 1 + migite].IchiY;
					R_IchiZ1 = A_Objects[0][2 * N - 1 + migite].IchiZ;
					R_IchiX2 = A_Objects[1][R_use_object].IchiX;
					R_IchiY2 = A_Objects[1][R_use_object].IchiY;
					R_IchiZ2 = A_Objects[1][R_use_object].IchiZ;
					/*IchiX2 = A_Objects[1][TyuPnum].IchiX;
					IchiY2 = A_Objects[1][TyuPnum].IchiY;
					IchiZ2 = A_Objects[1][TyuPnum].IchiZ;*/

					WCarry(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2);//両手で運ぶ carry

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;

					A_Objects[0][R_use_object].IchiX = R_IchiX2;//部品の座標を更新
					A_Objects[0][R_use_object].IchiY = R_IchiY2;
					A_Objects[0][R_use_object].IchiZ = R_IchiZ2;
					A_Objects[0][L_use_object].IchiX = L_IchiX2;//部品の座標を更新
					A_Objects[0][L_use_object].IchiY = L_IchiY2;
					A_Objects[0][L_use_object].IchiZ = L_IchiZ2;
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					R_IchiX1 = A_Objects[0][2 * N - 1 + migite].IchiX;
					R_IchiY1 = A_Objects[0][2 * N - 1 + migite].IchiY;
					R_IchiZ1 = A_Objects[0][2 * N - 1 + migite].IchiZ;
					R_IchiX2 = A_Objects[1][R_use_object].IchiX;
					R_IchiY2 = A_Objects[1][R_use_object].IchiY;
					R_IchiZ2 = A_Objects[1][R_use_object].IchiZ;

					Carry(fp2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2, migite);

					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;

					A_Objects[0][R_use_object].IchiX = R_IchiX2;//部品の座標を更新
					A_Objects[0][R_use_object].IchiY = R_IchiY2;
					A_Objects[0][R_use_object].IchiZ = R_IchiZ2;

				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					L_IchiX1 = A_Objects[0][2 * N - 1 + hidarite].IchiX;
					L_IchiY1 = A_Objects[0][2 * N - 1 + hidarite].IchiY;
					L_IchiZ1 = A_Objects[0][2 * N - 1 + hidarite].IchiZ;
					L_IchiX2 = A_Objects[1][L_use_object].IchiX;
					L_IchiY2 = A_Objects[1][L_use_object].IchiY;
					L_IchiZ2 = A_Objects[1][L_use_object].IchiZ;

					Carry(fp2, L_IchiX1, L_IchiY1, R_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, hidarite);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					A_Objects[0][L_use_object].IchiX = L_IchiX2;//部品の座標を更新
					A_Objects[0][L_use_object].IchiY = L_IchiY2;
					A_Objects[0][L_use_object].IchiZ = L_IchiZ2;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == kumitateidou)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					hold_hands = migite;//部品を持っている手を記録
					/*IchiX1 = A_Objects[1][KoPnum].IchiX;
					IchiY1 = A_Objects[1][KoPnum].IchiY;
					IchiZ1 = A_Objects[1][KoPnum].IchiZ;*/
					L_IchiX1 = A_Objects[1][L_use_object].IchiX;
					L_IchiY1 = A_Objects[1][L_use_object].IchiY;
					L_IchiZ1 = A_Objects[1][L_use_object].IchiZ;

					R_IchiX1 = A_Objects[1][R_use_object].IchiX;
					R_IchiY1 = A_Objects[1][R_use_object].IchiY;
					R_IchiZ1 = A_Objects[1][R_use_object].IchiZ;

					if (kumijun[line].scene_type == oya1ko2 || kumijun[line].scene_type == oya2ko2)
					{
						if (R_line < L_line)
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
						else
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
					}
					else if (kumijun[line].scene_type == oya2ko1)
					{
						if (Oya2flag == 1)//組立順序の最初の部品が基準部品の場合
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
						else if (Oya2flag == 2 || Oya2flag == 3)
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
					}
					else
					{
						R_IchiX2 = KIdo_X;
						R_IchiY2 = KIdo_Y;
						R_IchiZ2 = KIdo_Z;

						L_IchiX2 = KIdo_X;
						L_IchiY2 = KIdo_Y;
						L_IchiZ2 = KIdo_Z;
					}

					WKumimove(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;

					//部品の座標の更新
					A_Objects[1][L_use_object].IchiX = L_IchiX2;
					A_Objects[1][L_use_object].IchiY = L_IchiX2;
					A_Objects[1][L_use_object].IchiZ = L_IchiX2;

					A_Objects[1][R_use_object].IchiX = R_IchiX2;
					A_Objects[1][R_use_object].IchiY = R_IchiY2;
					A_Objects[1][R_use_object].IchiZ = R_IchiZ2;
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					R_IchiX1 = A_Objects[1][R_use_object].IchiX;
					R_IchiY1 = A_Objects[1][R_use_object].IchiY;
					R_IchiZ1 = A_Objects[1][R_use_object].IchiZ;

					if (kumijun[line].scene_type == oya1ko2 || kumijun[line].scene_type == oya2ko2)
					{
						if (R_line < L_line)
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
						else
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
					}
					else if (kumijun[line].scene_type == oya2ko1)
					{
						if (Oya2flag == 1)//組立順序の最初の部品が基準部品の場合
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
						else if (Oya2flag == 2 || Oya2flag == 3)
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
					}
					else
					{
						R_IchiX2 = KIdo_X;
						R_IchiY2 = KIdo_Y;
						R_IchiZ2 = KIdo_Z;

						L_IchiX2 = KIdo_X;
						L_IchiY2 = KIdo_Y;
						L_IchiZ2 = KIdo_Z;
					}

					Kumimove(fp2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2, migite);

					A_Objects[0][2 * N - 1 + migite].IchiX = R_IchiX2;//右手の座標を更新
					A_Objects[0][2 * N - 1 + migite].IchiY = R_IchiY2;
					A_Objects[0][2 * N - 1 + migite].IchiZ = R_IchiZ2;
					A_Objects[1][R_use_object].IchiX = R_IchiX2;//部品の座標の更新
					A_Objects[1][R_use_object].IchiY = R_IchiY2;
					A_Objects[1][R_use_object].IchiZ = R_IchiZ2;
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					L_IchiX1 = A_Objects[1][L_use_object].IchiX;
					L_IchiY1 = A_Objects[1][L_use_object].IchiY;
					L_IchiZ1 = A_Objects[1][L_use_object].IchiZ;

					if (kumijun[line].scene_type == oya1ko2 || kumijun[line].scene_type == oya2ko2)
					{
						if (R_line < L_line)
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
						else
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
					}
					else if (kumijun[line].scene_type == oya2ko1)
					{
						if (Oya2flag == 1)//組立順序の最初の部品が基準部品の場合
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
						else if (Oya2flag == 2 || Oya2flag == 3)
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
					}
					else
					{
						R_IchiX2 = KIdo_X;
						R_IchiY2 = KIdo_Y;
						R_IchiZ2 = KIdo_Z;

						L_IchiX2 = KIdo_X;
						L_IchiY2 = KIdo_Y;
						L_IchiZ2 = KIdo_Z;
					}

					Kumimove(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, hidarite);

					A_Objects[0][2 * N - 1 + hidarite].IchiX = L_IchiX2;//左手の座標を更新
					A_Objects[0][2 * N - 1 + hidarite].IchiY = L_IchiY2;
					A_Objects[0][2 * N - 1 + hidarite].IchiZ = L_IchiZ2;
					//部品の座標の更新
					A_Objects[1][L_use_object].IchiX = L_IchiX2;
					A_Objects[1][L_use_object].IchiY = L_IchiX2;
					A_Objects[1][L_use_object].IchiZ = L_IchiX2;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == tsukeru)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					WFix(fp2, L_Jigbangou, R_Jigbangou, L_use_parts, R_use_parts);//付ける fix

					//治具と親部品の支えの関係をつくる
					A_Supports[1][3 + N + putting + R_Jig].Id = A_Jigus[R_Jig].Jnum;
					A_Supports[1][3 + N + putting + R_Jig].Flag = 1;

					A_Supports[1][3 + N + putting + L_Jig].Id = A_Jigus[L_Jig].Jnum;
					A_Supports[1][3 + N + putting + L_Jig].Flag = 1;

					for (k = 0; k < A_Supports[1][3 + N + putting + R_Jig].Length; k++)//治具と親部品の支えの関係をつくる(右手)
					{
						//A_Supports[0][Te].PId = use_parts;
						if (A_Supports[1][3 + N + putting + R_Jig].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
						{
							supportflug = 1;
							break;
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][3 + N + putting + R_Jig].PId[A_Supports[1][3 + N + putting + R_Jig].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + R_Jig].Length++;
							break;
						}
						else
						{
							supportflug = 0;
						}
					}

					for (k = 0; k < A_Supports[1][3 + N + putting + L_Jig].Length; k++)//治具と親部品の支えの関係をつくる(左手)
					{
						//A_Supports[0][Te].PId = use_parts;
						if (A_Supports[1][3 + N + putting + L_Jig].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
						{
							supportflug = 1;
							break;
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][3 + N + putting + L_Jig].PId[A_Supports[1][3 + N + putting + L_Jig].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + L_Jig].Length++;
							break;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					Fix(fp2, R_Jigbangou, R_use_parts, migite);//付ける fix

					//治具と親部品の支えの関係をつくる
					A_Supports[1][3 + N + putting + R_Jig].Id = A_Jigus[R_Jig].Jnum;
					A_Supports[1][3 + N + putting + R_Jig].Flag = 1;
					for (k = 0; k < A_Supports[1][3 + N + putting + R_Jig].Length; k++)//治具と親部品の支えの関係をつくる(右手)
					{
						//A_Supports[0][Te].PId = use_parts;
						if (A_Supports[1][3 + N + putting + R_Jig].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
						{
							supportflug = 1;
							break;
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][3 + N + putting + R_Jig].PId[A_Supports[1][3 + N + putting + R_Jig].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + R_Jig].Length++;
							break;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					Fix(fp2, L_Jigbangou, L_use_parts, hidarite);//付ける fix
					A_Supports[1][3 + N + putting + L_Jig].Id = A_Jigus[L_Jig].Jnum;
					A_Supports[1][3 + N + putting + L_Jig].Flag = 1;
					for (k = 0; k < A_Supports[1][3 + N + putting + L_Jig].Length; k++)//治具と親部品の支えの関係をつくる(左手)
					{
						//A_Supports[0][Te].PId = use_parts;
						if (A_Supports[1][3 + N + putting + L_Jig].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
						{
							supportflug = 1;
							break;
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][3 + N + putting + L_Jig].PId[A_Supports[1][3 + N + putting + L_Jig].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + L_Jig].Length++;
							break;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == tsukamu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					WGripping(fp2, L_use_parts, R_use_parts);//掴む
					//Gripping(fp2, TyuPa, Te);//掴む

					if (A_Supports[1][hidarite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][hidarite].Flag = 1;
						A_Supports[1][hidarite].PId[0] = L_use_parts;
						A_Supports[1][hidarite].Length++;
					}
					else
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;
						A_Supports[1][hidarite].Flag = 1;
						for (k = 0; k < A_Supports[1][hidarite].Length; k++)
						{
							//A_Supports[0][hidarite].PId = use_parts;
							if (A_Supports[1][hidarite].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][hidarite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

					if (A_Supports[1][migite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][migite].Flag = 1;
						A_Supports[1][migite].PId[0] = R_use_parts;
						A_Supports[1][migite].Length++;
					}
					else
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;
						A_Supports[1][migite].Flag = 1;
						for (k = 0; k < A_Supports[1][migite].Length; k++)
						{
							//A_Supports[0][migite].PId = use_parts;
							if (A_Supports[1][migite].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][migite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					Gripping(fp2, R_use_parts, migite);
					if (A_Supports[1][migite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][migite].Flag = 1;
						A_Supports[1][migite].PId[0] = R_use_parts;
						A_Supports[1][migite].Length++;
					}
					else
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;
						A_Supports[1][migite].Flag = 1;
						for (k = 0; k < A_Supports[1][migite].Length; k++)
						{
							//A_Supports[0][migite].PId = use_parts;
							if (A_Supports[1][migite].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][migite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					Gripping(fp2, L_use_parts, hidarite);
					if (A_Supports[1][hidarite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][hidarite].Flag = 1;
						A_Supports[1][hidarite].PId[0] = L_use_parts;
						A_Supports[1][hidarite].Length++;
					}
					else
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;
						A_Supports[1][hidarite].Flag = 1;
						for (k = 0; k < A_Supports[1][hidarite].Length; k++)
						{
							//A_Supports[0][hidarite].PId = use_parts;
							if (A_Supports[1][hidarite].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][hidarite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == tsukamitoru)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					//右側の部品に関して
					if (JigKobuhin == R_use_parts || JigKobuhin2 == R_use_parts || ChangeJig == R_use_parts || ChangeJig2 == R_use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == R_use_parts)
								{
									BeforeJigR = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					//左側の部品に関して
					if (JigKobuhin == L_use_parts || JigKobuhin2 == L_use_parts || ChangeJig == L_use_parts || ChangeJig2 == L_use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == L_use_parts)
								{
									BeforeJigL = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					for (i = 0; i < Bboxnum; i++)
					{
						for (k = 0; k < A_Supports[1][i + 2].Length; k++)
						{
							if (A_Supports[1][i + 2].PId[k] == L_use_parts || A_Supports[1][i + 2].PId[k] == R_use_parts) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
							   //A_Supports[1][i + 2].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i + 2].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i + 2].Length;
								A_Supports[1][i + 2].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if ((temp[supportlength] != L_use_parts && A_Supports[1][i + 2].PId[k] == L_use_parts) ||
										(temp[supportlength] != R_use_parts && A_Supports[1][i + 2].PId[k] == R_use_parts))//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i + 2].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i + 2].Length == 0)
								{
									A_Supports[1][i + 2].Flag = 0;
								}
								break;
							}
						}
					}
					for (i = 0; i < putting; i++)
					{//中間製品置き場からとるとき、支えの関係を切る
						//if (A_Supports[0][3 + N + i].PId == OyaPa)
						/*if (A_Supports[0][3 + N + i].PId == use_parts)
						{
							A_Supports[1][3 + N + i].Flag = 0;
							A_Supports[1][3 + N + i].PId = 0;
						}*/
						for (k = 0; k < A_Supports[1][3 + N + i].Length; k++)
						{
							if (A_Supports[1][3 + N + i].PId[k] == L_use_parts || A_Supports[1][3 + N + i].PId[k] == R_use_parts)//右手で扱う部品か左手で扱う部品の時
							{
								//A_Supports[1][3 + N + i].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][3 + N + i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][3 + N + i].Length;
								A_Supports[1][3 + N + i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if ((temp[supportlength] != L_use_parts && A_Supports[1][3 + N + i].PId[k] == L_use_parts) ||
										(temp[supportlength] != R_use_parts && A_Supports[1][3 + N + i].PId[k] == R_use_parts))//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = temp[supportlength];//データの移行
										A_Supports[1][3 + N + i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][3 + N + i].Length == 0)
								{
									A_Supports[1][3 + N + i].Flag = 0;
								}
								break;
							}
						}
					}

					if (A_Supports[1][hidarite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][hidarite].Flag = 1;
						A_Supports[1][hidarite].PId[0] = L_use_parts;
						A_Supports[1][hidarite].Length++;
					}
					else
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;
						A_Supports[1][hidarite].Flag = 1;
						for (k = 0; k < A_Supports[1][hidarite].Length; k++)
						{
							//A_Supports[0][hidarite].PId = use_parts;
							if (A_Supports[1][hidarite].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][hidarite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

					if (A_Supports[1][migite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][migite].Flag = 1;
						A_Supports[1][migite].PId[0] = R_use_parts;
						A_Supports[1][migite].Length++;
					}
					else
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;
						A_Supports[1][migite].Flag = 1;
						for (k = 0; k < A_Supports[1][migite].Length; k++)
						{
							//A_Supports[0][migite].PId = use_parts;
							if (A_Supports[1][migite].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][migite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

					WGrip(fp2, L_use_parts, R_use_parts, BeforeJigL, BeforeJigR);
					BeforeJigL = BeforeJigR = 0;
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					if (JigKobuhin == R_use_parts || JigKobuhin2 == R_use_parts || ChangeJig == R_use_parts || ChangeJig2 == R_use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == R_use_parts)
								{
									BeforeJigR = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					for (i = 0; i < Bboxnum; i++)
					{
						for (k = 0; k < A_Supports[1][i + 2].Length; k++)
						{
							if (A_Supports[1][i + 2].PId[k] == R_use_parts) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
							   //A_Supports[1][i + 2].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i + 2].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i + 2].Length;
								A_Supports[1][i + 2].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != R_use_parts && A_Supports[1][i + 2].PId[k] == R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i + 2].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i + 2].Length == 0)
								{
									A_Supports[1][i + 2].Flag = 0;
								}
								break;
							}
						}
					}
					for (i = 0; i < putting; i++)
					{//中間製品置き場からとるとき、支えの関係を切る
						//if (A_Supports[0][3 + N + i].PId == OyaPa)
						/*if (A_Supports[0][3 + N + i].PId == use_parts)
						{
							A_Supports[1][3 + N + i].Flag = 0;
							A_Supports[1][3 + N + i].PId = 0;
						}*/
						for (k = 0; k < A_Supports[1][3 + N + i].Length; k++)
						{
							if (A_Supports[1][3 + N + i].PId[k] == R_use_parts)//右手で扱う部品か左手で扱う部品の時
							{
								//A_Supports[1][3 + N + i].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][3 + N + i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][3 + N + i].Length;
								A_Supports[1][3 + N + i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != R_use_parts && A_Supports[1][3 + N + i].PId[k] == R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = temp[supportlength];//データの移行
										A_Supports[1][3 + N + i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][3 + N + i].Length == 0)
								{
									A_Supports[1][3 + N + i].Flag = 0;
								}
								break;
							}
						}
					}
					if (A_Supports[1][migite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][migite].Flag = 1;
						A_Supports[1][migite].PId[0] = use_parts;
						A_Supports[1][migite].Length++;
					}
					else
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;
						A_Supports[1][migite].Flag = 1;
						for (k = 0; k < A_Supports[1][migite].Length; k++)
						{
							//A_Supports[0][migite].PId = use_parts;
							if (A_Supports[1][migite].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][migite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
					Grip(fp2, R_use_parts, BeforeJigR, migite);
					BeforeJigR = 0;
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					if (JigKobuhin == L_use_parts || JigKobuhin2 == L_use_parts || ChangeJig == L_use_parts || ChangeJig2 == L_use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == L_use_parts)
								{
									BeforeJigL = A_Supports[0][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					for (i = 0; i < Bboxnum; i++)
					{
						for (k = 0; k < A_Supports[1][i + 2].Length; k++)
						{
							if (A_Supports[1][i + 2].PId[k] == L_use_parts) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
							   //A_Supports[1][i + 2].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i + 2].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i + 2].Length;
								A_Supports[1][i + 2].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != L_use_parts && A_Supports[1][i + 2].PId[k] == L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i + 2].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i + 2].Length == 0)
								{
									A_Supports[1][i + 2].Flag = 0;
								}
								break;
							}
						}
					}
					for (i = 0; i < putting; i++)
					{//中間製品置き場からとるとき、支えの関係を切る
						//if (A_Supports[0][3 + N + i].PId == OyaPa)
						/*if (A_Supports[0][3 + N + i].PId == use_parts)
						{
							A_Supports[1][3 + N + i].Flag = 0;
							A_Supports[1][3 + N + i].PId = 0;
						}*/
						for (k = 0; k < A_Supports[1][3 + N + i].Length; k++)
						{
							if (A_Supports[1][3 + N + i].PId[k] == L_use_parts)//右手で扱う部品か左手で扱う部品の時
							{
								//A_Supports[1][3 + N + i].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][3 + N + i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][3 + N + i].Length;
								A_Supports[1][3 + N + i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != L_use_parts && A_Supports[1][3 + N + i].PId[k] == L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = temp[supportlength];//データの移行
										A_Supports[1][3 + N + i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][3 + N + i].Length == 0)
								{
									A_Supports[1][3 + N + i].Flag = 0;
								}
								break;
							}
						}
					}

					if (A_Supports[1][hidarite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][hidarite].Flag = 1;
						A_Supports[1][hidarite].PId[0] = use_parts;
						A_Supports[1][hidarite].Length++;
					}
					else
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;
						A_Supports[1][hidarite].Flag = 1;
						for (k = 0; k < A_Supports[1][hidarite].Length; k++)
						{
							//A_Supports[0][hidarite].PId = use_parts;
							if (A_Supports[1][hidarite].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][hidarite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

					Grip(fp2, L_use_parts, BeforeJigL, hidarite);
					BeforeJigL = 0;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == okihanasu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					Wleave(fp2, L_use_parts, R_use_parts);//置き放す leave
					//leave(fp2, TyuPa, Te);//置き放す leave

					for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
					{//左手、右手、冶具の支えの関係を切る
						//if (A_Supports[1][i].PId == TyuPa)
						f = A_Supports[1][i].Length;//支えている数を保存
						for (k = 0; k < f; k++)
						{
							/*if (A_Supports[1][i].PId == use_parts)
							{
								A_Supports[1][i].Flag = 0;
								A_Supports[1][i].PId = 0;
							}*/
							if (A_Supports[1][i].PId[k] == L_use_parts || A_Supports[1][i].PId[k] == R_use_parts)//組立後に部品を支えていてはいけないのでA_Supports[1][i].PId
							{
								for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i].Length;
								A_Supports[1][i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if ((temp[supportlength] != L_use_parts && A_Supports[1][3 + N + i].PId[k] == L_use_parts) ||
										(temp[supportlength] != R_use_parts && A_Supports[1][3 + N + i].PId[k] == R_use_parts))//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i].PId[A_Supports[1][i].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i].Length == 0)
								{
									A_Supports[1][i].Flag = 0;
								}
								break;
							}
						}

						if (i == Tnum - 1 + N + 3)
						{//中間製品置き場と中間製品の支えの関係を作る
							A_Supports[1][i].Flag = 1;
							//A_Supports[1][i].PId = use_parts;
							//A_Supports[1][i].PId = TyuPa;
							for (k = 0; k < A_Supports[1][i].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][i].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = supportflug + 1;//左手で扱う部品を持っている時は＋1する
								}
								else if (A_Supports[1][i].PId[k] == R_use_parts)
								{
									supportflug = supportflug + 2;//右手で扱う部品を持っている時は＋2する
								}
							}
							if (supportflug == 0)//まだ支えられていない時
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = L_use_parts;//中間製品置き場と左手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;

								A_Supports[1][i].PId[A_Supports[1][i].Length] = R_use_parts;//中間製品置き場と右手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else if (supportflug == 1)//左手で扱う部品がすでに支えられているとき(一応の作業)
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = R_use_parts;//中間製品置き場と中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else if (supportflug == 2)//右手で扱う部品がすでに支えられているとき(一応の作業)
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = L_use_parts;//中間製品置き場と左手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else
							{
								supportflug = 0;
							}
						}
					}

				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					leave(fp2, R_use_parts, migite);
					for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
					{//右手、冶具の支えの関係を切る
						//if (A_Supports[1][i].PId == TyuPa)
						f = A_Supports[1][i].Length;//支えている数を保存
						for (k = 0; k < f; k++)
						{
							/*if (A_Supports[1][i].PId == use_parts)
							{
								A_Supports[1][i].Flag = 0;
								A_Supports[1][i].PId = 0;
							}*/
							if (A_Supports[1][i].PId[k] == R_use_parts)//組立後に部品を支えていてはいけないのでA_Supports[1][i].PId
							{
								for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i].Length;
								A_Supports[1][i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != R_use_parts && A_Supports[1][3 + N + i].PId[k] == R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i].PId[A_Supports[1][i].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i].Length == 0)
								{
									A_Supports[1][i].Flag = 0;
								}
								break;
							}
						}

						if (i == Tnum - 1 + N + 3)
						{//中間製品置き場と中間製品の支えの関係を作る
							A_Supports[1][i].Flag = 1;
							//A_Supports[1][i].PId = use_parts;
							//A_Supports[1][i].PId = TyuPa;
							for (k = 0; k < A_Supports[1][i].Length; k++)
							{
								if (A_Supports[1][i].PId[k] == R_use_parts)
								{
									supportflug = supportflug + 2;//右手で扱う部品を持っている時は＋2する
								}
							}
							if (supportflug == 0)//まだ支えられていない時
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = R_use_parts;//中間製品置き場と右手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else
							{
								supportflug = 0;
							}
						}
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					leave(fp2, L_use_parts, hidarite);
					for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
					{//左手、右手、冶具の支えの関係を切る
						//if (A_Supports[1][i].PId == TyuPa)
						f = A_Supports[1][i].Length;//支えている数を保存
						for (k = 0; k < f; k++)
						{
							/*if (A_Supports[1][i].PId == use_parts)
							{
								A_Supports[1][i].Flag = 0;
								A_Supports[1][i].PId = 0;
							}*/
							if (A_Supports[1][i].PId[k] == L_use_parts)//組立後に部品を支えていてはいけないのでA_Supports[1][i].PId
							{
								for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i].Length;
								A_Supports[1][i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != L_use_parts && A_Supports[1][3 + N + i].PId[k] == L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i].PId[A_Supports[1][i].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i].Length == 0)
								{
									A_Supports[1][i].Flag = 0;
								}
								break;
							}
						}

						if (i == Tnum - 1 + N + 3)
						{//中間製品置き場と中間製品の支えの関係を作る
							A_Supports[1][i].Flag = 1;
							//A_Supports[1][i].PId = use_parts;
							//A_Supports[1][i].PId = TyuPa;
							for (k = 0; k < A_Supports[1][i].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][i].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = supportflug + 1;//左手で扱う部品を持っている時は＋1する
								}
							}
							if (supportflug == 0)//まだ支えられていない時
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = L_use_parts;//中間製品置き場と左手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else
							{
								supportflug = 0;
							}
						}
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == hanasu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					WRelease(fp2, L_use_parts, R_use_parts);//両手で放すrelease

					for (supportlength = 0; supportlength < A_Supports[1][hidarite].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][hidarite].PId[supportlength];//値を移す
						A_Supports[1][hidarite].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][hidarite].Length;
					A_Supports[1][hidarite].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != L_use_parts)
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = temp[k];
							A_Supports[1][hidarite].Length++;
						}
					}
					if (A_Supports[1][hidarite].Length == 0)
					{
						A_Supports[1][hidarite].Flag = 0;
					}

					for (supportlength = 0; supportlength < A_Supports[1][migite].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][migite].PId[supportlength];//値を移す
						A_Supports[1][migite].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][migite].Length;
					A_Supports[1][migite].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != use_parts)
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = temp[k];
							A_Supports[1][migite].Length++;
						}
					}
					if (A_Supports[1][migite].Length == 0)
					{
						A_Supports[1][migite].Flag = 0;
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					Release(fp2, R_use_parts, migite);//右手で放すrelease
					for (supportlength = 0; supportlength < A_Supports[1][migite].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][migite].PId[supportlength];//値を移す
						A_Supports[1][migite].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][migite].Length;
					A_Supports[1][migite].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != use_parts)
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = temp[k];
							A_Supports[1][migite].Length++;
						}
					}
					if (A_Supports[1][migite].Length == 0)
					{
						A_Supports[1][migite].Flag = 0;
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					Release(fp2, L_use_parts, hidarite);//左手で放すrelease
					for (supportlength = 0; supportlength < A_Supports[1][hidarite].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][hidarite].PId[supportlength];//値を移す
						A_Supports[1][hidarite].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][hidarite].Length;
					A_Supports[1][hidarite].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != L_use_parts)
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = temp[k];
							A_Supports[1][hidarite].Length++;
						}
					}
					if (A_Supports[1][hidarite].Length == 0)
					{
						A_Supports[1][hidarite].Flag = 0;
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == kumitateru)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					oya_hoji = A_Jigus[Jig].Jnum;
					if (R_line < L_line)
					{
						Kumitate(fp2, A_Supports[1][N + putting + 3 + R_Jig].Id, TyuPa, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
						Kumitate(fp2, A_Supports[1][N + putting + 3 + L_Jig].Id, TyuPa2, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
					}
					else
					{
						Kumitate(fp2, A_Supports[1][N + putting + 3 + L_Jig].Id, TyuPa, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
						Kumitate(fp2, A_Supports[1][N + putting + 3 + R_Jig].Id, TyuPa2, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					oya_hoji = A_Jigus[Jig].Jnum;
					if (R_line < L_line)
					{
						Kumitate(fp2, A_Supports[1][N + putting + 3 + R_Jig].Id, TyuPa, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[L_line].jig - 1].Id, TyuPa2, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
					}
					else
					{
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[L_line].jig - 1].Id, TyuPa, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
						Kumitate(fp2, A_Supports[1][N + putting + 3 + R_Jig].Id, TyuPa2, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
					}

				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					oya_hoji = A_Jigus[Jig].Jnum;
					if (R_line < L_line)
					{
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[R_line].jig - 1].Id, TyuPa, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
						Kumitate(fp2, A_Supports[1][N + putting + 3 + L_Jig].Id, TyuPa2, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
					}
					else
					{
						Kumitate(fp2, A_Supports[1][N + putting + 3 + L_Jig].Id, TyuPa, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[R_line].jig - 1].Id, TyuPa2, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == motinaosu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					L_Turn0X = A_Objects[0][L_use_object].DirX;
					L_Turn1X = A_Objects[1][L_use_object].DirX;
					L_Turn0Y = A_Objects[0][L_use_object].DirY;
					L_Turn1Y = A_Objects[1][L_use_object].DirY;
					L_Turn0Z = A_Objects[0][L_use_object].DirZ;
					L_Turn1Z = A_Objects[1][L_use_object].DirZ;

					R_Turn0X = A_Objects[0][R_use_object].DirX;
					R_Turn1X = A_Objects[1][R_use_object].DirX;
					R_Turn0Y = A_Objects[0][R_use_object].DirY;
					R_Turn1Y = A_Objects[1][R_use_object].DirY;
					R_Turn0Z = A_Objects[0][R_use_object].DirZ;
					R_Turn1Z = A_Objects[1][R_use_object].DirZ;

					WTurn(fp2, L_use_parts, L_Turn0X, L_Turn0Y, L_Turn0Z, L_Turn1X, L_Turn1Y, L_Turn1Z, R_use_parts, R_Turn0X, R_Turn0Y, R_Turn0Z, R_Turn1X, R_Turn1Y, R_Turn1Z);//左手で回転させるturn
					if (M_pattern[movetype].Move[migite][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(R_Turn0X - R_Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(R_Turn0Y - R_Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(R_Turn0Z - R_Turn1Z) + Oyakaitenkakudo;
					}
					if (M_pattern[movetype].Move[hidarite][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(L_Turn0X - L_Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(L_Turn0Y - L_Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(L_Turn0Z - L_Turn1Z) + Oyakaitenkakudo;
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					R_Turn0X = A_Objects[0][R_use_object].DirX;
					R_Turn1X = A_Objects[1][R_use_object].DirX;
					R_Turn0Y = A_Objects[0][R_use_object].DirY;
					R_Turn1Y = A_Objects[1][R_use_object].DirY;
					R_Turn0Z = A_Objects[0][R_use_object].DirZ;
					R_Turn1Z = A_Objects[1][R_use_object].DirZ;

					Turn(fp2, R_use_parts, R_Turn0X, R_Turn0Y, R_Turn0Z, R_Turn1X, R_Turn1Y, R_Turn1Z, migite);//回転させるturn
					if (M_pattern[movetype].Move[migite][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(R_Turn0X - R_Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(R_Turn0Y - R_Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(R_Turn0Z - R_Turn1Z) + Oyakaitenkakudo;
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					L_Turn0X = A_Objects[0][L_use_object].DirX;
					L_Turn1X = A_Objects[1][L_use_object].DirX;
					L_Turn0Y = A_Objects[0][L_use_object].DirY;
					L_Turn1Y = A_Objects[1][L_use_object].DirY;
					L_Turn0Z = A_Objects[0][L_use_object].DirZ;
					L_Turn1Z = A_Objects[1][L_use_object].DirZ;
					Turn(fp2, L_use_parts, L_Turn0X, L_Turn0Y, L_Turn0Z, L_Turn1X, L_Turn1Y, L_Turn1Z, hidarite);
					if (M_pattern[movetype].Move[hidarite][nowmove][target] == Oya)
					{
						Oyakaiten++;
						Oyakaitenkakudo = fabs(L_Turn0X - L_Turn1X) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(L_Turn0Y - L_Turn1Y) + Oyakaitenkakudo;
						Oyakaitenkakudo = fabs(L_Turn0Z - L_Turn1Z) + Oyakaitenkakudo;
					}
				}
			}
		}
	}
	for (i = 0; i < 2; i++)
	{
		//手の最終座標を合わせる
		A_Objects[1][2 * N - 1 + i].IchiX = A_Objects[0][2 * N - 1 + i].IchiX;
		A_Objects[1][2 * N - 1 + i].IchiY = A_Objects[0][2 * N - 1 + i].IchiY;
		A_Objects[1][2 * N - 1 + i].IchiZ = A_Objects[0][2 * N - 1 + i].IchiZ;
	}
	if (kumijun[line].kougu != 0)//工具を用いる時
	{
		A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiX = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiX;//工具の座標を更新
		A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiY = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY;
		A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY;
	}
}

void Make_finish(int line)
{
	/*
組立作業最後の状態の作り方
1.完成品を完成品箱に持っていく
2.右手、左手を初期位置に持っていく
3.完成品の支えは完成品箱だけにする
*/

	int i, KanseiTyusin = 0;
	double X_max = 0, X_min = 0, Y_max = 0, Y_min = 0, Z_max = 0, Z_min = 0, Tyusin_X, Tyusin_Y, Tyusin_Z;
	double KanseiTyusin_X = 0, KanseiTyusin_Y = 0, KanseiTyusin_Z = 0;
	int KoPa, KanseiPa;//最後の組付けた子部品の番号,完成品の中間製品番号
	int supportlength = 0, k = 0;
	int KouguNum = 0;

	int roop = 1, roopcount = 0;//roop何回繰り返すか、roopcount：for文を回すための変数

	for (i = 0; i < 3 * N + 2 + Kougu + putting + Jigu; i++) {
		A_Objects[0][i].Id = A_Objects[1][i].Id;
		A_Objects[0][i].Flag = A_Objects[1][i].Flag;
		A_Objects[0][i].IchiX = A_Objects[1][i].IchiX;
		A_Objects[0][i].IchiY = A_Objects[1][i].IchiY;
		A_Objects[0][i].IchiZ = A_Objects[1][i].IchiZ;
		A_Objects[0][i].DirX = A_Objects[1][i].DirX;
		A_Objects[0][i].DirY = A_Objects[1][i].DirY;
		A_Objects[0][i].DirZ = A_Objects[1][i].DirZ;
	}
	for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++) {
		A_Supports[0][i].Id = A_Supports[1][i].Id;
		for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
		{
			A_Supports[0][i].PId[supportlength] = A_Supports[1][i].PId[supportlength];
		}
		A_Supports[0][i].Length = supportlength;
	}

	if (kumijun[line].scene_type == oya2ko2)//完成品置き場に持っていく部品が2つのとき
	{
		roop = 2;
		line = line - 1;
	}

	for (roopcount = 0; roopcount < roop; roopcount++)
	{
		KanseiPa = kumijun[line].tyukan;
		KoPa = kumijun[line].ko;//組立順序から一つ前の組付けの子部品を読み取っている
		//for (i = 0; i < N + 1; i++) {
		for (i = 0; i < e; i++) {
			if (A_Tyukantyusin[i].TyukanNum == KanseiPa) {
				KanseiTyusin = A_Tyukantyusin[i].Tyusin;
			}
		}


		for (i = 0; i < N; i++)
		{
			//完成品の本来の中心点を出しています
			if (i == 0)//暫定の各軸の最大値、最小値を決める
			{
				X_max = A_Buhin[i].Tyusin_X + A_Buhin[i].X_max;
				X_min = A_Buhin[i].Tyusin_X + A_Buhin[i].X_min;
				Y_max = A_Buhin[i].Tyusin_Y + A_Buhin[i].Y_max;
				Y_min = A_Buhin[i].Tyusin_Y + A_Buhin[i].Y_min;
				Z_max = A_Buhin[i].Tyusin_Z + A_Buhin[i].Z_max;
				Z_min = A_Buhin[i].Tyusin_Z + A_Buhin[i].Z_min;
			}
			if (X_max < (A_Buhin[i].Tyusin_X + A_Buhin[i].X_max)) {
				X_max = A_Buhin[i].Tyusin_X + A_Buhin[i].X_max;
			}
			if (X_min > (A_Buhin[i].Tyusin_X + A_Buhin[i].X_min)) {
				X_min = A_Buhin[i].Tyusin_X + A_Buhin[i].X_min;
			}
			if (Y_max < (A_Buhin[i].Tyusin_Y + A_Buhin[i].Y_max)) {
				Y_max = A_Buhin[i].Tyusin_Y + A_Buhin[i].Y_max;
			}
			if (Y_min > (A_Buhin[i].Tyusin_Y + A_Buhin[i].Y_min)) {
				Y_min = A_Buhin[i].Tyusin_Y + A_Buhin[i].Y_min;
			}
			if (Z_max < (A_Buhin[i].Tyusin_Z + A_Buhin[i].Z_max)) {
				Z_max = A_Buhin[i].Tyusin_Z + A_Buhin[i].Z_max;
			}
			if (Z_min > (A_Buhin[i].Tyusin_Z + A_Buhin[i].Z_min)) {
				Z_min = A_Buhin[i].Tyusin_Z + A_Buhin[i].Z_min;
			}
			if (A_Buhin[i].Buhinnum == KanseiTyusin)
			{
				KanseiTyusin_X = A_Buhin[i].Tyusin_X;//完成品のMAYA上での中心点を出しています
				KanseiTyusin_Y = A_Buhin[i].Tyusin_Y;
				KanseiTyusin_Z = A_Buhin[i].Tyusin_Z;
			}
		}

		Tyusin_X = (X_max + X_min) / 2;
		Tyusin_Y = (Y_max + Y_min) / 2;
		Tyusin_Z = (Z_max + Z_min) / 2;


		for (i = 0; i < 3 * N + 2 + Kougu + putting + Jigu; i++) {//中間部品置き場に中間製品と左手を持っていく
			if (A_Objects[1][i].Id == KanseiPa) {

				TyuPnum = i;
			}
		}
		/*A_Objects[1][2 * N - 2].IchiX = A_Objects[1][2 * N + Bboxnum].IchiX - (Tyusin_X - KanseiTyusin_X) + A_Bboxs[Bboxnum - 1].SizeX / 2;//完成品を完成品箱に持っていく
		A_Objects[1][2 * N - 2].IchiY = A_Objects[1][2 * N + Bboxnum].IchiY - (Tyusin_Y - KanseiTyusin_Y) + A_Bboxs[Bboxnum - 1].SizeY / 2;
		A_Objects[1][2 * N - 2].IchiZ = A_Objects[1][2 * N + Bboxnum].IchiZ + (KanseiTyusin_Z - Z_min);
		A_Objects[1][2 * N - 2].DirX = 0;
		A_Objects[1][2 * N - 2].DirY = 0;
		A_Objects[1][2 * N - 2].DirZ = 0;*/
		A_Objects[1][TyuPnum].IchiX = A_Objects[1][2 * N + Bboxnum].IchiX - (Tyusin_X - KanseiTyusin_X) + A_Bboxs[Bboxnum - 1].SizeX / 2;//完成品を完成品箱に持っていく
		A_Objects[1][TyuPnum].IchiY = A_Objects[1][2 * N + Bboxnum].IchiY - (Tyusin_Y - KanseiTyusin_Y) + A_Bboxs[Bboxnum - 1].SizeY / 2;
		A_Objects[1][TyuPnum].IchiZ = A_Objects[1][2 * N + Bboxnum].IchiZ + (KanseiTyusin_Z - Z_min);
		A_Objects[1][TyuPnum].DirX = 0;
		A_Objects[1][TyuPnum].DirY = 0;
		A_Objects[1][TyuPnum].DirZ = 0;


		for (i = 0; i < 2; i++) {//右手、左手を初期位置に持っていく
			A_Objects[1][2 * N - 1 + i].IchiX = A_Hands[i].IchiX;
			A_Objects[1][2 * N - 1 + i].IchiY = A_Hands[i].IchiY;
			A_Objects[1][2 * N - 1 + i].IchiZ = A_Hands[i].IchiZ;
			A_Objects[1][2 * N - 1 + i].DirX = A_Hands[i].DirX;
			A_Objects[1][2 * N - 1 + i].DirY = A_Hands[i].DirY;
			A_Objects[1][2 * N - 1 + i].DirZ = A_Hands[i].DirZ;
		}

		for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
		{
			for (k = 0; k < A_Supports[0][i].Length; k++)//完成品置き場に置く部品を仮置き場からなくす
			{
				if (A_Supports[1][i].PId[k] == A_Objects[0][N + gyousu - 1].Id)
				{
					for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
					{
						A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
					}
					A_Supports[1][i].Length = 0;//一旦0にする
					for (supportlength = 0; supportlength < A_Supports[0][i].Length; supportlength++)//前の状態で支えている数だけ回す
					{
						if (A_Supports[0][i].PId[supportlength] != A_Objects[0][N + gyousu - 1].Id)//一致する子部品は部品箱から取る部品なのでカウントしない
						{
							A_Supports[1][i].PId[A_Supports[1][i].Length] = A_Supports[0][i].PId[supportlength];//データの移行
							A_Supports[1][i].Length++;//カウントを増やす
						}
					}
				}
				if (A_Supports[1][i].Length == 0)
				{
					A_Supports[1][i].Flag = 0;
				}
				break;
			}
		}
		A_Supports[1][2 + Bboxnum - 1].Flag = 1;
		A_Supports[1][2 + Bboxnum - 1].PId[A_Supports[1][2 + Bboxnum - 1].Length] = A_Objects[1][N + gyousu - 1].Id;
		A_Supports[1][2 + Bboxnum - 1].Length++;

		if (kumijun[line].kougu != 0)//最後の組立で工具を用いているとき
		{
			if (NewNOS0 == 0)
			{
				KouguNum = kumijun[line].kougu - 1;
			}
			else
			{
				for (i = 0; i < Kougu; i++)
				{
					if (A_Objects[0][3 * N + 2 + i + putting + Jigu].Id == kumijun[line].kougu)
					{
						KouguNum = i;
						break;
					}
				}
			}

			A_Objects[1][3 * N + 2 + putting + Jigu + KouguNum].IchiX = A_Kougus[KouguNum].IchiX;//工具の位置を工具置き場にする
			A_Objects[1][3 * N + 2 + putting + Jigu + KouguNum].IchiY = A_Kougus[KouguNum].IchiY;//工具の位置を工具置き場にする
			A_Objects[1][3 * N + 2 + putting + Jigu + KouguNum].IchiZ = A_Kougus[KouguNum].IchiZ;//工具の位置を工具置き場にする
		}

		if (roopcount == 0 && roop == 2)//組立順序2行分組立を行うときで、一行目の組立の状態を作り終わった時
		{
			line++;
			TyuPnum1 = TyuPnum;
		}
	}
	if (kumijun[line].scene_type == oya2ko2)
	{
		if (A_Objects[0][TyuPnum].IchiX > A_Objects[0][TyuPnum1].IchiX)//右手左手でどの子部品,親部品を扱うのかの判定
		{
			R_TyuPnum = TyuPnum;
			L_TyuPnum = TyuPnum1;
		}
		else
		{
			R_TyuPnum = TyuPnum1;
			L_TyuPnum = TyuPnum;
		}
	}
}

void Make_kanseioki_move(FILE* fp2, int line)
{
	int Jigugu, TyuP, Te = 0, Turn0X, Turn0Y, Turn0Z, Turn1X, Turn1Y, Turn1Z, Jig;
	double IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2;
	double Tyusin_X = 0, Tyusin_Y = 0, Tyusin_Z = 0;
	double TyukanTyusin_X = 0, TyukanTyusin_Y = 0, TyukanTyusin_Z = 0;
	int i = 0, TyusinParts = 0;
	double X_max = 0, X_min = 0, Y_max = 0, Y_min = 0, Z_max = 0, Z_min = 0;

	Jig = kumijun[line].jig;
	Jigugu = A_Supports[0][N + putting + 3 + Jig].Id;
	TyuP = kumijun[line].tyukan;

	if (not_use_flag == 0)
	{
		Te = 0;
		Release(fp2, TyuP, Te);//右手で放す release

		Te = 1;
		IchiX1 = A_Objects[0][2 * N].IchiX;
		IchiY1 = A_Objects[0][2 * N].IchiY;
		IchiZ1 = A_Objects[0][2 * N].IchiZ;
		IchiX2 = A_Objects[1][2 * N].IchiX;
		IchiY2 = A_Objects[1][2 * N].IchiY;
		IchiZ2 = A_Objects[1][2 * N].IchiZ;
		Reach(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);//左手で伸ばす reach


		Te = 0;
		//Release(fp2, TyuP, Te);//右手で放す

		IchiX1 = A_Objects[0][OyaPnum].IchiX;
		IchiY1 = A_Objects[0][OyaPnum].IchiY;
		IchiZ1 = A_Objects[0][OyaPnum].IchiZ;
		IchiX2 = A_Objects[0][OyaPnum].IchiX;
		IchiY2 = A_Objects[0][OyaPnum].IchiY;
		IchiZ2 = A_Objects[0][OyaPnum].IchiZ;

		Reach(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);//右手で伸ばす

		Gripping(fp2, TyuP, Te);//右手で掴む
		Remove(fp2, Jigugu, TyuP, Te);//右手で外す remove

		IchiX1 = A_Objects[0][2 * N - 1].IchiX;
		IchiY1 = A_Objects[0][2 * N - 1].IchiY;
		IchiZ1 = A_Objects[0][2 * N - 1].IchiZ;
		IchiX2 = A_Objects[1][N + gyousu - 1].IchiX;
		IchiY2 = A_Objects[1][N + gyousu - 1].IchiY;
		IchiZ2 = A_Objects[1][N + gyousu - 1].IchiZ;
		Carry(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);//右手で運ぶ carry

		if ((A_Objects[1][N + gyousu - 1].DirX - A_Objects[0][N + gyousu - 1].DirX) % 360 != 0 || (A_Objects[1][N + gyousu - 1].DirY - A_Objects[0][N + gyousu - 1].DirY) % 360 != 0 || (A_Objects[1][N + gyousu - 1].DirZ - A_Objects[0][N + gyousu - 1].DirZ) % 360 != 0) {
			Turn0X = A_Objects[0][N + gyousu - 1].DirX;
			Turn1X = A_Objects[1][N + gyousu - 1].DirX;
			Turn0Y = A_Objects[0][N + gyousu - 1].DirY;
			Turn1Y = A_Objects[1][N + gyousu - 1].DirY;
			Turn0Z = A_Objects[0][N + gyousu - 1].DirY;
			Turn1Z = A_Objects[1][N + gyousu - 1].DirY;
			Turn(fp2, TyuP, Turn0X, Turn0Y, Turn0Z, Turn1X, Turn1Y, Turn1Z, Te);//右手で回転させるturn
		}


		leave(fp2, TyuP, Te);//右手で置き放す leave

		IchiX1 = A_Objects[1][N + gyousu - 1].IchiX;
		IchiY1 = A_Objects[1][N + gyousu - 1].IchiY;
		IchiZ1 = A_Objects[1][N + gyousu - 1].IchiZ;
		IchiX2 = A_Objects[1][2 * N - 1].IchiX;
		IchiY2 = A_Objects[1][2 * N - 1].IchiY;
		IchiZ2 = A_Objects[1][2 * N - 1].IchiZ;
		Reach(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);//右手で伸ばす reach
	}
	else if (not_use_flag == 1)
	{
		for (i = 0; i < e; i++) {
			if (A_Tyukantyusin[i].TyukanNum == TyuP) {
				TyusinParts = A_Tyukantyusin[i].Tyusin;
			}
		}
		for (i = 0; i < N; i++)
		{//完成品の本来の中心点を出しています
			if (i == 0)//暫定の各軸の最大値、最小値を決める
			{
				X_max = A_Buhin[i].Tyusin_X + A_Buhin[i].X_max;
				X_min = A_Buhin[i].Tyusin_X + A_Buhin[i].X_min;
				Y_max = A_Buhin[i].Tyusin_Y + A_Buhin[i].Y_max;
				Y_min = A_Buhin[i].Tyusin_Y + A_Buhin[i].Y_min;
				Z_max = A_Buhin[i].Tyusin_Z + A_Buhin[i].Z_max;
				Z_min = A_Buhin[i].Tyusin_Z + A_Buhin[i].Z_min;
			}
			if (X_max < (A_Buhin[i].Tyusin_X + A_Buhin[i].X_max)) {
				X_max = A_Buhin[i].Tyusin_X + A_Buhin[i].X_max;
			}
			if (X_min > (A_Buhin[i].Tyusin_X + A_Buhin[i].X_min)) {
				X_min = A_Buhin[i].Tyusin_X + A_Buhin[i].X_min;
			}
			if (Y_max < (A_Buhin[i].Tyusin_Y + A_Buhin[i].Y_max)) {
				Y_max = A_Buhin[i].Tyusin_Y + A_Buhin[i].Y_max;
			}
			if (Y_min > (A_Buhin[i].Tyusin_Y + A_Buhin[i].Y_min)) {
				Y_min = A_Buhin[i].Tyusin_Y + A_Buhin[i].Y_min;
			}
			if (Z_max < (A_Buhin[i].Tyusin_Z + A_Buhin[i].Z_max)) {
				Z_max = A_Buhin[i].Tyusin_Z + A_Buhin[i].Z_max;
			}
			if (Z_min > (A_Buhin[i].Tyusin_Z + A_Buhin[i].Z_min)) {
				Z_min = A_Buhin[i].Tyusin_Z + A_Buhin[i].Z_min;
			}
			if (TyusinParts == A_Buhin[i].Buhinnum)
			{
				TyukanTyusin_X = A_Buhin[i].Tyusin_X;
				TyukanTyusin_Y = A_Buhin[i].Tyusin_Y;
				TyukanTyusin_Z = A_Buhin[i].Tyusin_Z;
			}
		}

		Tyusin_X = (X_max + X_min) / 2;
		Tyusin_Y = (Y_max + Y_min) / 2;
		Tyusin_Z = (Z_max + Z_min) / 2;

		A_Objects[1][TyuPnum].IchiX = A_Objects[1][3 * N + 2 + Tnum - 1].IchiX - (Tyusin_X - TyukanTyusin_X);
		A_Objects[1][TyuPnum].IchiY = A_Objects[1][3 * N + 2 + Tnum - 1].IchiY - (Tyusin_Y - TyukanTyusin_Y);
		A_Objects[1][TyuPnum].IchiZ = A_Objects[1][3 * N + 2 + Tnum - 1].IchiZ + (TyukanTyusin_Z - Z_min);

		X_max = X_min = Y_max = Y_min = Z_max = Z_min = 0;

		if (hold_hands >= 0)
		{
			Release(fp2, TyuP, hold_hands);//放す release
		}

		Te = migite;

		IchiX1 = A_Objects[0][2 * N - 1 + Te].IchiX;//使用する手の現在の位置
		IchiY1 = A_Objects[0][2 * N - 1 + Te].IchiY;
		IchiZ1 = A_Objects[0][2 * N - 1 + Te].IchiZ;
		IchiX2 = A_Objects[0][TyuPnum].IchiX;
		IchiY2 = A_Objects[0][TyuPnum].IchiY;
		IchiZ2 = A_Objects[0][TyuPnum].IchiZ;

		Reach(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);

		A_Objects[0][2 * N - 1 + Te].IchiX = IchiX2;//手の座標を更新
		A_Objects[0][2 * N - 1 + Te].IchiY = IchiY2;
		A_Objects[0][2 * N - 1 + Te].IchiZ = IchiZ2;

		Gripping(fp2, TyuP, Te);//掴む
		Remove(fp2, Jigugu, TyuP, Te);//外す remove

		IchiX1 = A_Objects[0][2 * N - 1 + Te].IchiX;
		IchiY1 = A_Objects[0][2 * N - 1 + Te].IchiY;
		IchiZ1 = A_Objects[0][2 * N - 1 + Te].IchiZ;
		IchiX2 = A_Objects[1][TyuPnum].IchiX;
		IchiY2 = A_Objects[1][TyuPnum].IchiY;
		IchiZ2 = A_Objects[1][TyuPnum].IchiZ;
		/*IchiX2 = A_Objects[1][TyuPnum].IchiX;
		IchiY2 = A_Objects[1][TyuPnum].IchiY;
		IchiZ2 = A_Objects[1][TyuPnum].IchiZ;*/

		Carry(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);//運ぶ carry

		A_Objects[0][2 * N - 1 + Te].IchiX = IchiX2;//手の座標を更新
		A_Objects[0][2 * N - 1 + Te].IchiY = IchiY2;
		A_Objects[0][2 * N - 1 + Te].IchiZ = IchiZ2;

		if ((0 - A_Objects[0][TyuPnum].DirX) % 360 != 0 || (0 - A_Objects[0][TyuPnum].DirY) % 360 != 0 || (0 - A_Objects[0][TyuPnum].DirZ) % 360 != 0) {//出来た中間製品の角度が完成品の角度ではないとき
			Turn0X = A_Objects[0][TyuPnum].DirX;
			Turn1X = 0;
			Turn0Y = A_Objects[0][TyuPnum].DirY;
			Turn1Y = 0;
			Turn0Z = A_Objects[0][TyuPnum].DirZ;
			Turn1Z = 0;

			A_Objects[1][TyuPnum].DirX = 0;
			A_Objects[1][TyuPnum].DirY = 0;
			A_Objects[1][TyuPnum].DirZ = 0;

			Turn(fp2, TyuP, Turn0X, Turn0Y, Turn0Z, Turn1X, Turn1Y, Turn1Z, Te);//回転させるturn
		}

		hold_hands = -1;//部品を持っている手がないことを記録
		for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++) {//左手、右手、冶具の支えの関係を切る
			//if (A_Supports[1][i].PId == TyuPa)
			if (A_Supports[1][i].PId == TyuP)
			{
				A_Supports[1][i].Flag = 0;
				//A_Supports[1][i].PId = 0;
			}
			if (i == Tnum - 1 + N + 3) {//中間製品置き場と中間製品の支えの関係を作る
				A_Supports[1][i].Flag = 1;
				//A_Supports[1][i].PId = TyuP;
				//A_Supports[1][i].PId = TyuPa;
			}
		}

		leave(fp2, TyuP, Te);//置き放す leave

		//手の最終座標を合わせる
		A_Objects[1][2 * N - 1 + Te].IchiX = A_Objects[0][2 * N - 1 + Te].IchiX;
		A_Objects[1][2 * N - 1 + Te].IchiY = A_Objects[0][2 * N - 1 + Te].IchiY;
		A_Objects[1][2 * N - 1 + Te].IchiZ = A_Objects[0][2 * N - 1 + Te].IchiZ;
		//手の支えの関係をコピー
		for (i = 0; i < 2; i++)
		{
			A_Supports[1][i].Flag = A_Supports[0][i].Flag;
			//A_Supports[1][i].PId = A_Supports[0][i].PId;
		}
	}
}

void Make_pre_assembly(FILE* fp2, int* pre_assemble, int pre_num)
{
	int i = 0, j = 0, k = 0, m = 0, flag = 0, f = 0;
	int kumitsuke_length = 0, kumitate = 0;//kumitsuke_length:対象の中間製品を組立てるために必要な組立の数　kumitate:組立部品を入れておく変数
	int tyukan[MaxN / 2]/*探す中間製品(組付けが中間製品同士になっている場合に追加するために配列*/, times = 0, tantai_num = 0/*単体部品の数*/;
	int  kijun = 0, object_kijun = 0, kijun_num/*基準とする単体部品の部品番号、objectsでどこにあるか、A_Buhinでどこにあるか*/;
	double kijun_X = 0, kijun_Y = 0, kijun_Z = 0/*基準部品の完成品の時の中心座標*/, coord_X = 0, coord_Y = 0, coord_Z = 0/*基準部品の初期位置を基準とした単体部品の座標*/, X = 0, Y = 0, Z = 0/*X,Y,Z基準部品の初期位置*/;
	double X_max = 0, X_min = 0, Y_max = 0, Y_min = 0, Z_max = 0, Z_min = 0, Tyusin_X = 0, Tyusin_Y = 0, Tyusin_Z = 0, Size_X = 0, Size_Y = 0, Size_Z = 0;//中間製品の大きさ
	int Kumi_Count = 0;//組付けを作るカウント
	int KariKumiN = KumiN;//途中で組付け数が変わるため、保存しておく
	int virtualkumitate;//架空の組付けをつくるためにまとまりの中間製品を保存する変数

	for (i = 0; i < pre_num; i++)
	{
		tyukan[times] = pre_assemble[i];
		virtualkumitate = pre_assemble[i];
		if (First_Time == 0) {
			//架空の組付けを作る
			for (j = 0; j < KariKumiN; j++)//組付けの数分回す
			{
				if (Kumi[j][1] == virtualkumitate)//組付けの組立部品と用意しなければならない中間製品が一致するとき
				{
					//4〜3 + N:部品1の構成部品, 4 + N〜3 + 2N : 部品2の構成部品
					//構成部品を調べて、架空の組付けを作る
					for (m = 4; m <= 3 + N; m++) {
						if (Kumi[j][m] != 0) {
							//初回
							if (Kumi_Count == 0) {
								Kumi[KumiN][0] = KumiN + 1;
								Kumi[KumiN][1] = Kumi[j][m];
								Kumi_Count++;
							}
							else if (Kumi_Count == 1) {
								Kumi[KumiN][2] = Kumi[j][m];
								Kumi[KumiN][3] = MaxPL + 1;
								MaxPL++;
								KumiN++;
								Kumi_Count++;
							}
							//2回目以降
							else if (Kumi_Count == 2) {
								Kumi[KumiN][0] = KumiN + 1;
								Kumi[KumiN][1] = Kumi[KumiN - 1][3];
								Kumi[KumiN][2] = Kumi[j][m];
								Kumi[KumiN][3] = MaxPL + 1;
								MaxPL++;
								KumiN++;
							}
						}
					}
					Kumi[KumiN - 1][3] = virtualkumitate;
					Kumi_Count = 0;
					break;
				}
				else if (Kumi[j][2] == virtualkumitate) {
					//構成部品を調べて、架空の組付けを作る
					for (m = 4 + N; m <= 3 + 2 * N; m++) {
						if (Kumi[j][m] != 0) {
							//初回
							if (Kumi_Count == 0) {
								Kumi[KumiN][0] = KumiN + 1;
								Kumi[KumiN][1] = Kumi[j][m];
								Kumi_Count++;
							}
							else if (Kumi_Count == 1) {
								Kumi[KumiN][2] = Kumi[j][m];
								Kumi[KumiN][3] = MaxPL + 1;
								MaxPL++;
								KumiN++;
								Kumi_Count++;
							}
							//2回目以降
							else if (Kumi_Count == 2) {
								Kumi[KumiN][0] = KumiN + 1;
								Kumi[KumiN][1] = Kumi[KumiN - 1][3];
								Kumi[KumiN][2] = Kumi[j][m];
								Kumi[KumiN][3] = MaxPL + 1;
								MaxPL++;
								KumiN++;
							}
						}
					}
					Kumi[KumiN - 1][3] = virtualkumitate;
					Kumi_Count = 0;
					break;
				}
			}
		}
		for (k = 0; k <= times; k++)
		{
			kumitate = tyukan[times];
			while (1)
			{
				for (j = 0; j < KumiN; j++)//組付けの数分回す
				{
					if (Kumi[j][3] == kumitate)//組付けの組立部品と用意しなければならない中間製品が一致するとき
					{//組付けの部品1、部品2、組立部品を移す
						pre_parts.kumitsuke[kumitsuke_length][0] = Kumi[j][1];
						pre_parts.kumitsuke[kumitsuke_length][1] = Kumi[j][2];
						pre_parts.kumitsuke[kumitsuke_length][2] = Kumi[j][3];

						if (pre_parts.kumitsuke[kumitsuke_length][0] > N0 && pre_parts.kumitsuke[kumitsuke_length][1] > N0)//部品1、部品2共に中間製品であった時
						{
							times++;//調べる中間製品が増えたので数を増やす
							kumitate = pre_parts.kumitsuke[kumitsuke_length][0];//部品1の中間製品を先に調べるためにkumitateに代入
							tyukan[times] = pre_parts.kumitsuke[kumitsuke_length][1];//部品2の中間製品を後で調べるために保存しておく
						}
						else if (pre_parts.kumitsuke[kumitsuke_length][0] > N0)//部品1が中間製品であった場合
						{
							kumitate = pre_parts.kumitsuke[kumitsuke_length][0];
							pre_parts.tantai_buhin[tantai_num] = pre_parts.kumitsuke[kumitsuke_length][1];
							tantai_num++;

						}
						else if (pre_parts.kumitsuke[kumitsuke_length][1] > N0)//部品2が中間製品であった場合
						{
							kumitate = pre_parts.kumitsuke[kumitsuke_length][1];
							pre_parts.tantai_buhin[tantai_num] = pre_parts.kumitsuke[kumitsuke_length][0];
							tantai_num++;
						}

						kumitsuke_length++;
						break;
					}
				}
				if (pre_parts.kumitsuke[kumitsuke_length - 1][0] <= N0 && pre_parts.kumitsuke[kumitsuke_length - 1][1] <= N0)//部品1と部品2が単体部品での時
				{
					pre_parts.tantai_buhin[tantai_num] = pre_parts.kumitsuke[kumitsuke_length - 1][1];
					tantai_num++;
					pre_parts.tantai_buhin[tantai_num] = pre_parts.kumitsuke[kumitsuke_length - 1][0];
					tantai_num++;
					break;//ループを抜ける
				}
			}
		}
		kijun = pre_parts.tantai_buhin[tantai_num - 1];//基準となる単体部品を決める(中間製品を構成する単体部品なら何でもよいが今回は一番最初に組立始める単体部品にする
		for (k = 0; k < N0; k++)//基準部品の座標を部品属性から探す
		{
			if (A_Buhin[k].Buhinnum == kijun)//基準部品と同じ時
			{
				kijun_X = A_Buhin[k].Tyusin_X;
				kijun_Y = A_Buhin[k].Tyusin_Y;
				kijun_Z = A_Buhin[k].Tyusin_Z;
				kijun_num = k;
				break;
			}
		}
		for (k = 0; k < N; k++)
		{
			if (kijun == A_Objects[0][k].Id)//基準部品の初期位置を調べる
			{
				A_Objects[0][k].Flag = 0;
				X = A_Objects[0][k].IchiX;
				Y = A_Objects[0][k].IchiY;
				Z = A_Objects[0][k].IchiZ;
				object_kijun = k;
				break;
			}
		}
		for (m = 0; m < tantai_num; m++)
		{
			for (k = 0; k < N0; k++)
			{
				if (pre_parts.tantai_buhin[m] == A_Buhin[k].Buhinnum && pre_parts.tantai_buhin[m] != kijun)//中間製品を構成する子部品の位置を組付いたときの位置を計算
				{
					coord_X = -1 * kijun_X + X + A_Buhin[k].Tyusin_X;
					coord_Y = -1 * kijun_Y + Y + A_Buhin[k].Tyusin_Y;
					coord_Z = -1 * kijun_Z + Z + A_Buhin[k].Tyusin_Z;
					break;
				}
			}
			for (k = 0; k < N; k++)
			{
				if (A_Objects[0][k].Id == pre_parts.tantai_buhin[m] && pre_parts.tantai_buhin[m] != kijun)//中間製品を構成する子部品の位置を組付いたときの位置に調整
				{
					A_Objects[0][k].Flag = 0;
					A_Objects[0][k].IchiX = coord_X;
					A_Objects[0][k].IchiY = coord_Y;
					A_Objects[0][k].IchiZ = coord_Z;

					A_Parts[k].IchiX = coord_X;
					A_Parts[k].IchiY = coord_Y;
					A_Parts[k].IchiZ = coord_Z;
					break;
				}
			}
		}
		for (k = kumitsuke_length - 1; k >= 0; k--)//配列を逆から出力することで中間製品を組立てる
		{
			Kumitate(kari, -101, pre_parts.kumitsuke[k][2], pre_parts.kumitsuke[k][0], pre_parts.kumitsuke[k][1], migite);
			//中間製品の中心点になる部品を記録します
			if (e == 0) {
				A_Tyukantyusin[e].TyukanNum = pre_parts.kumitsuke[k][2];
				A_Tyukantyusin[e].Tyusin = pre_parts.kumitsuke[k][0];
			}
			else {
				if (pre_parts.kumitsuke[k][0] <= N) {
					A_Tyukantyusin[e].TyukanNum = pre_parts.kumitsuke[k][2];
					A_Tyukantyusin[e].Tyusin = pre_parts.kumitsuke[k][0];
				}
				else {
					A_Tyukantyusin[e].TyukanNum = pre_parts.kumitsuke[k][2];
					for (f = 0; f < e; f++) {
						if (pre_parts.kumitsuke[k][0] == A_Tyukantyusin[f].TyukanNum) {
							A_Tyukantyusin[e].Tyusin = A_Tyukantyusin[f].Tyusin;
						}
					}
				}
			}
			e++;
			PreStep++;
		}

		Release(kari, pre_assemble[i], migite);
		PreStep++;

		for (k = 0; k < 3 * N + 2 + Kougu + putting + Jigu; k++)
		{
			if (A_Objects[0][k].Id == pre_assemble[i])//中間製品のフラグ1にする
			{
				A_Objects[0][k].Flag = 1;
				A_Objects[0][k].IchiX = A_Objects[0][object_kijun].IchiX;//中間製品の位置・角度を親部品の情報からコピーする
				A_Objects[0][k].IchiY = A_Objects[0][object_kijun].IchiY;
				A_Objects[0][k].IchiZ = A_Objects[0][object_kijun].IchiZ;
				A_Objects[0][k].DirX = A_Objects[0][object_kijun].DirX;
				A_Objects[0][k].DirY = A_Objects[0][object_kijun].DirY;
				A_Objects[0][k].DirZ = A_Objects[0][object_kijun].DirZ;
				break;
			}
		}

		//部品箱の大きさを中間製品の大きさに合わせる
		for (k = 0; k < tantai_num; k++)
		{//中間製品の大きさを出しています
			for (j = 0; j < N; j++)
			{
				if (A_Buhin[j].Buhinnum == pre_parts.tantai_buhin[k] && k == 0)//暫定の各軸の最大値、最小値を決める
				{
					X_max = A_Buhin[j].Tyusin_X + A_Buhin[j].X_max;
					X_min = A_Buhin[j].Tyusin_X + A_Buhin[j].X_min;
					Y_max = A_Buhin[j].Tyusin_Y + A_Buhin[j].Y_max;
					Y_min = A_Buhin[j].Tyusin_Y + A_Buhin[j].Y_min;
					Z_max = A_Buhin[j].Tyusin_Z + A_Buhin[j].Z_max;
					Z_min = A_Buhin[j].Tyusin_Z + A_Buhin[j].Z_min;
				}
				else if (A_Buhin[j].Buhinnum == pre_parts.tantai_buhin[k])
				{
					if (X_max < (A_Buhin[j].Tyusin_X + A_Buhin[j].X_max))
					{
						X_max = A_Buhin[j].Tyusin_X + A_Buhin[j].X_max;
					}
					if (X_min > (A_Buhin[j].Tyusin_X + A_Buhin[j].X_min))
					{
						X_min = A_Buhin[j].Tyusin_X + A_Buhin[j].X_min;
					}
					if (Y_max < (A_Buhin[j].Tyusin_Y + A_Buhin[j].Y_max))
					{
						Y_max = A_Buhin[j].Tyusin_Y + A_Buhin[j].Y_max;
					}
					if (Y_min > (A_Buhin[j].Tyusin_Y + A_Buhin[j].Y_min))
					{
						Y_min = A_Buhin[j].Tyusin_Y + A_Buhin[j].Y_min;
					}
					if (Z_max < (A_Buhin[j].Tyusin_Z + A_Buhin[j].Z_max))
					{
						Z_max = A_Buhin[j].Tyusin_Z + A_Buhin[j].Z_max;
					}
					if (Z_min > (A_Buhin[j].Tyusin_Z + A_Buhin[j].Z_min))
					{
						Z_min = A_Buhin[j].Tyusin_Z + A_Buhin[j].Z_min;
					}
					break;
				}
			}
		}
		//中間製品の中心座標を出す
		Tyusin_X = (X_max + X_min) / 2.0;
		Tyusin_Y = (Y_max + Y_min) / 2.0;
		Tyusin_Z = (Z_max + Z_min) / 2.0;
		//中間製品の大きさを出す
		Size_X = fabs(X_max - X_min);
		Size_Y = fabs(Y_max - Y_min);
		Size_Z = fabs(Z_max - Z_min);

		//部品箱の大きさを決める
		A_Bboxs[i].SizeX = Size_X + 20;
		A_Bboxs[i].SizeY = Size_Y + 20;
		//部品箱の位置を決める
		A_Bboxs[i].IchiX = A_Parts[kijun_num].IchiX + Tyusin_X - A_Buhin[kijun_num].Tyusin_X - (Size_X + 20) / 2;//部品箱は左下が原点だから調節
		A_Bboxs[i].IchiY = A_Parts[kijun_num].IchiY + Tyusin_Y - A_Buhin[kijun_num].Tyusin_Y - (Size_Y + 20) / 2;
		A_Bboxs[i].IchiZ = A_Parts[kijun_num].IchiZ + Tyusin_Z - A_Buhin[kijun_num].Tyusin_Z - Size_Z / 2 - 5;//部品の大きさ読み込むようになったら、Ｚを調節する

		//支えの関係を作る
		A_Supports[0][2 + i].PId[0] = pre_assemble[i];

		times = 0;//数値をリセット
		kumitsuke_length = 0;
		tantai_num = 0;
		X_max = X_min = Y_max = Y_min = Z_max = Z_min = 0;
	}
	if (First_Time == 0) { First_Time++; }
	//支えの関係を作る
	i = pre_num;
	for (k = 0; k < N; k++)
	{
		if (A_Objects[0][k].Flag == 1)//objectsのフラグが１の単体部品が最初から単体部品として存在する部品
		{//支えの関係を作る
			for (m = 0; m < gyousu; m++)
			{
				if ((kumijun[m].ko < N && kumijun[m].ko == A_Objects[0][k].Id) || (kumijun[m].oya < N && kumijun[m].oya == A_Objects[0][k].Id))//親部品または子部品が単部品で組立順序に現れる時
				{
					A_Supports[0][2 + i].PId[0] = A_Objects[0][k].Id;
					flag = 1;
					if (boxflag == 1)//箱を指定していないとき
					{
						for (j = 0; j < N; j++)
						{
							if (A_Buhin[j].Buhinnum == A_Objects[0][k].Id)//部品箱の大きさを直す
							{
								A_Bboxs[i].SizeX = A_Buhin[j].Lengrh_X + 20;
								A_Bboxs[i].SizeY = A_Buhin[j].Lengrh_Y + 20;
								A_Bboxs[i].SizeZ = 20;
								A_Bboxs[i].IchiX = A_Parts[j].IchiX - (A_Buhin[j].Lengrh_X + 20) / 2;//部品箱は左下が原点だから調節
								A_Bboxs[i].IchiY = A_Parts[j].IchiY - (A_Buhin[j].Lengrh_Y + 20) / 2;
								A_Bboxs[i].IchiZ = A_Parts[j].IchiZ - A_Buhin[j].Lengrh_Z / 2 - 5;//部品の大きさ読み込むようになったら、Ｚを調節する
								i++;
								break;
							}
						}
					}
					if (flag == 1)
					{
						break;
					}
				}
			}
			if (flag == 0)//中間製品の部品でなく、組立順序に出てこない部品の時
			{
				for (j = 0; j < N; j++)
				{
					if (A_Buhin[j].Buhinnum == A_Objects[0][k].Id)//部品箱の大きさを直す
					{
						A_Bboxs[Total_Box].Bnum = 9000 + 1 + Total_Box - Bboxnum + tantaibuhinsu + pre_num;
						A_Bboxs[Total_Box].Oyako = 1;
						A_Bboxs[Total_Box].Type = 2;
						A_Bboxs[Total_Box].Iro = 20;
						A_Bboxs[Total_Box].SizeX = A_Buhin[j].Lengrh_X + 20;
						A_Bboxs[Total_Box].SizeY = A_Buhin[j].Lengrh_Y + 20;
						A_Bboxs[Total_Box].SizeZ = 20;
						A_Bboxs[Total_Box].Atusa = 2;
						A_Bboxs[Total_Box].IchiX = A_Parts[j].IchiX - (A_Buhin[j].Lengrh_X + 20) / 2;//部品箱は左下が原点だから調節
						A_Bboxs[Total_Box].IchiY = A_Parts[j].IchiY - (A_Buhin[j].Lengrh_Y + 20) / 2;
						A_Bboxs[Total_Box].IchiZ = A_Parts[j].IchiZ - A_Buhin[j].Lengrh_Z / 2 - 5;//部品の大きさ読み込むようになったら、Ｚを調節する
						A_Bboxs[Total_Box].DirX = 0;
						A_Bboxs[Total_Box].DirY = 0;
						A_Bboxs[Total_Box].DirZ = 180;
						Total_Box++;
						break;
					}
				}
			}
			flag = 0;
		}
		//if (i == gyousu+1) break;
	}
}

void Make_Joutai(int line, int movetype)
{
	int i = 0, R_length = 0, L_length = 0, length = 0, /*movetype = 0,*/ Te = 0, nowmove = 0, Jig = 0;
	int OyaPa, KoPa, TyuPa, Jigbangou = 0;//親部品番号,子部品番号,中間製品
	double IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Turn0X, Turn0Y, Turn0Z, Turn1X, Turn1Y, Turn1Z;
	int Oyanum = 0;//親部品が何番目にあるか
	int use_parts = 0/*使用する部品番号*/, use_object = 0/*使用する部品がobjectでどこにあるか*/;
	int R_use_parts = 0/*右手で使用する部品番号*/, R_use_object = 0;/*右手で使用する部品がobjectでどこにあるか*/
	int L_use_parts = 0/*左手で使用する部品番号*/, L_use_object = 0;/*左手で使用する部品がobjectでどこにあるか*/
	double R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2, R_Turn0X, R_Turn0Y, R_Turn0Z, R_Turn1X, R_Turn1Y, R_Turn1Z;
	double L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, L_Turn0X, L_Turn0Y, L_Turn0Z, L_Turn1X, L_Turn1Y, L_Turn1Z;
	int temp[MaxSupport], templength = 0;

	int R_Jig = 0, L_Jig = 0, R_Jigbangou = 0, L_Jigbangou = 0, R_TyuPa = 0, L_TyuPa = 0, TyuPa2 = 0, R_line = 0/*両手の時右手の組付けが一行目か二行目かどうかを保管*/, L_line = 0/*両手の時右手の組付けが一行目か二行目かどうかを保管*/;
	int supportlength = 0, k = 0, supportflug = 0, f = 0;
	int KouguBnum = 0, Kougunum = 0, KouguPnum = 0;//KouguBnum：レイアウト情報での工具の番号、Kougunum：工具番号,KouguPnum：工具がobjectsでどこにあるか
	int ChangeKouguBnum = 0, ChangeKougunum = 0, ChangeKouguPnum = 0;//ChangeKouguBnum：レイアウト情報での交換する工具の番号、ChangeKougunum：交換する工具番号,ChangeKouguPnum：交換する工具がobjectsでどこにあるか
	int TempKougunum = 0;
	double RhandX = 0, RhandY = 0, RhandZ = 0, LhandX = 0, LhandY = 0, LhandZ = 0, KouguX = 0, KouguY = 0, KouguZ = 0;//状態を作る時用の座標を一時的に置いておく場所
	//int BeforeJig = 0;
	//int BeforeJigR = 0, BeforeJigL = 0;

	TyuPa2 = kumijun[line + 1].tyukan;

	R_length = M_pattern[movetype].length[migite];
	L_length = M_pattern[movetype].length[hidarite];
	KoPa = kumijun[line].ko;
	OyaPa = kumijun[line].oya;
	TyuPa = kumijun[line].tyukan;
	if (NewNOS0 == 0)
	{
		Jig = kumijun[line].jig - 1;
		Kougunum = kumijun[line].kougu - 1;
		ChangeKougunum = kumijun[line - 1].kougu - 1;
	}
	else
	{
		for (i = 0; i < Jigu; i++)
		{
			if (A_Objects[0][3 * N + 2 + i + putting].Id == kumijun[line].jig)
			{
				Jig = i;
				break;
			}
		}
		for (i = 0; i < Kougu; i++)
		{
			if (A_Objects[0][3 * N + 2 + i + putting + Jigu].Id == kumijun[line].kougu)
			{
				Kougunum = i;
				break;
			}
		}
		for (i = 0; i < Kougu; i++)
		{
			if (A_Objects[0][3 * N + 2 + i + putting + Jigu].Id == kumijun[line - 1].kougu)
			{
				ChangeKougunum = i;
				break;
			}
		}
	}
	Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
	//Kougunum = kumijun[line].kougu;
	KouguBnum = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].Id;
	//ChangeKougunum = kumijun[line-1].kougu;
	ChangeKouguBnum = A_Objects[0][3 * N + 2 + ChangeKougunum + putting + Jigu].Id;

	RhandX = A_Objects[0][2 * N - 1 + migite].IchiX;//使用する手の現在の位置
	RhandY = A_Objects[0][2 * N - 1 + migite].IchiY;
	RhandZ = A_Objects[0][2 * N - 1 + migite].IchiZ;

	LhandX = A_Objects[0][2 * N - 1 + hidarite].IchiX;//使用する手の現在の位置
	LhandY = A_Objects[0][2 * N - 1 + hidarite].IchiY;
	LhandZ = A_Objects[0][2 * N - 1 + hidarite].IchiZ;
	if (Kouguflag != 0)//工具を用いて部品を運ぶ場合は工具の座標も変更
	{
		KouguX = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiX;
		KouguY = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiY;
		KouguZ = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].IchiZ;
	}

	if (R_length > L_length)
	{
		length = R_length;
	}
	else
	{
		length = L_length;
	}

	for (nowmove = 0; nowmove <= length; nowmove++)
	{
		if (M_pattern[movetype].Move[migite][nowmove][move] != none && M_pattern[movetype].Move[hidarite][nowmove][move] != none)//右手左手両方に同時に動作がある時
		{
			Te = ryoute;
		}
		else if (M_pattern[movetype].Move[migite][nowmove][move] != none)//右手に作業がある時
		{
			Te = migite;
		}
		else if (M_pattern[movetype].Move[hidarite][nowmove][move] != none)//左手に動作がある時
		{
			Te = hidarite;
		}

		//どの部品を対象とするかを調べる
		if (Te == migite || Te == hidarite)//両手で同時に作業をしない時
		{
			if (M_pattern[movetype].Move[Te][nowmove][target] == Oya)//対象製品が親部品
			{
				//printf("oya\n");
				if (Oya2flag == 1)//基準部品が最初の部品の時
				{//2番目の部品が対象の部品になる
					use_parts = kumijun[line + 1].oya;
					use_object = OyaPnum;
				}
				else if (Oya2flag == 2)//基準部品が2番目の部品の時
				{//最初の部品が対象の部品になる
					use_parts = kumijun[line].oya;
					use_object = OyaPnum1;
				}
				else
				{
					use_parts = OyaPa;
					use_object = OyaPnum;
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Ko)//対象製品が子部品
			{
				//printf("ko\n");
				use_parts = KoPa;
				use_object = KoPnum;
				//printf("kopa%d,%d\n", use_parts, use_object);
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Tyukan)//対象製品が中間製品
			{
				use_parts = TyuPa;
				use_object = TyuPnum;
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Start_P)//手を初期位置に戻すとき、対象製品は使用する手
			{
				use_object = 2 * N - 1 + Te;
			}

			else if (M_pattern[movetype].Move[Te][nowmove][target] == Ko1)//両手2部品の時の右手で扱う子部品
			{
				use_parts = A_Objects[0][R_KoPnum].Id;
				use_object = R_KoPnum;
				if (Oya2flag == 2)
				{
					use_object = KoPnum1;
				}
				else if (Oya2flag == 1)
				{
					use_object = KoPnum1;
				}
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].ko == R_use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						OyaPa = kumijun[i].oya;
						KoPa = kumijun[i].ko;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Oya1)//両手2部品の時の右手で扱う親部品
			{
				use_parts = A_Objects[0][R_OyaPnum].Id;
				use_object = R_OyaPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].oya == R_use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Tyukan1)//両手2部品の時の右手で扱う中間製品部品
			{
				use_parts = A_Objects[0][R_TyuPnum].Id;
				use_object = R_TyuPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].tyukan == use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Ko2)//両手2部品の時の左手で扱う子部品
			{
				use_parts = A_Objects[0][L_KoPnum].Id;
				use_object = L_KoPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].ko == use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						OyaPa = kumijun[i].oya;
						KoPa = kumijun[i].ko;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Oya2)//両手2部品の時の左手で扱う親部品
			{
				use_parts = A_Objects[0][L_OyaPnum].Id;
				use_object = L_OyaPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].oya == use_parts)
					{
						OyaPa = kumijun[i].oya;
						KoPa = kumijun[line].ko;
						TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == Tyukan2)//両手2部品の時の左手で扱う中間製品部品
			{
				use_parts = A_Objects[0][L_TyuPnum].Id;
				use_object = L_TyuPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].tyukan == L_use_parts)
					{
						TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									Jig = k;
									break;
								}

							}
						}
						Jigbangou = A_Supports[0][N + putting + 3 + Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)
			{
				use_parts = A_Objects[0][3 * N + 2 + Kougunum + putting + Jigu].Id;
				use_object = 3 * N + 2 + Kougunum + putting + Jigu;
			}
			else if (M_pattern[movetype].Move[Te][nowmove][target] == ChangeKOUGU)
			{
				use_parts = A_Objects[0][3 * N + 2 + ChangeKougunum + putting + Jigu].Id;
				use_object = 3 * N + 2 + ChangeKougunum + putting + Jigu;
			}

			if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == nobasu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{//Te = M_pattern[movetype].kobuhin[nowmove][Hand];
				//もともと治具に付いている部品(親部品)に手を伸ばす
					if (Te == migite)
					{
						IchiX1 = RhandX;//使用する手の現在の位置
						IchiY1 = RhandY;
						IchiZ1 = RhandZ;
					}
					else if (Te == hidarite)
					{
						IchiX1 = LhandX;//使用する手の現在の位置
						IchiY1 = LhandY;
						IchiZ1 = LhandZ;
					}
					if (M_pattern[movetype].Move[Te][nowmove][target] == Start_P)
					{
						IchiX2 = A_Objects[1][use_object].IchiX;
						IchiY2 = A_Objects[1][use_object].IchiY;
						IchiZ2 = A_Objects[1][use_object].IchiZ;
					}
					else
					{
						IchiX2 = A_Objects[0][use_object].IchiX;
						IchiY2 = A_Objects[0][use_object].IchiY;
						IchiZ2 = A_Objects[0][use_object].IchiZ;
					}
					/*IchiX2 = A_Objects[0][OyaPnum].IchiX;
					IchiY2 = A_Objects[0][OyaPnum].IchiY;
					IchiZ2 = A_Objects[0][OyaPnum].IchiZ;*/

					//Reach(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);
					if (Te == migite)
					{
						RhandX = IchiX2;//手の座標を更新
						RhandY = IchiY2;
						RhandZ = IchiZ2;
					}
					else if (Te == hidarite)
					{
						LhandX = IchiX2;//手の座標を更新
						LhandY = IchiY2;
						LhandZ = IchiZ2;
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == tsukamu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = Te;//部品を持っている手を記録
					if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)//対象が工具の時は工具を使用していることを記録しておく
					{
						Kouguflag = KouguBnum;
					}
					//Gripping(fp2, use_parts, Te);//掴む
					//Gripping(fp2, TyuPa, Te);//掴む
					if (A_Supports[1][Te].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][Te].Id = A_Hands[Te].Hnum;//部品と手の支えの関係をつくる
						A_Supports[1][Te].Flag = 1;
						A_Supports[1][Te].PId[0] = use_parts;
						A_Supports[1][Te].Length++;
					}
					else
					{
						A_Supports[1][Te].Id = A_Hands[Te].Hnum;
						A_Supports[1][Te].Flag = 1;
						for (k = 0; k < A_Supports[1][Te].Length; k++)
						{
							//A_Supports[0][Te].PId = use_parts;
							if (A_Supports[1][Te].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][Te].PId[A_Supports[1][Te].Length] = use_parts;//部品と手の支えの関係をつくる
							A_Supports[1][Te].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
					//A_Supports[1][Te].PId = TyuPa;
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == tsukamitoru)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = Te;//部品を持っている手を記録
					if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)//対象が工具の時は工具を使用していることを記録しておく
					{
						Kouguflag = KouguBnum;
					}

					if (JigKobuhin == use_parts || JigKobuhin2 == use_parts || ChangeJig == use_parts || ChangeJig2 == use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == use_parts)
								{
									//BeforeJig = A_Supports[1][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}
					//for (i = 0; i < N + 1; i++) {//部品箱の支えの関係を切る
					for (i = 0; i < Bboxnum; i++)
					{
						for (k = 0; k < A_Supports[1][i + 2].Length; k++)
						{
							if (A_Supports[1][i + 2].PId[k] == use_parts) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
							   //A_Supports[1][i + 2].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i + 2].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i + 2].Length;
								A_Supports[1][i + 2].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i + 2].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i + 2].Length == 0)
								{
									A_Supports[1][i + 2].Flag = 0;
								}
								break;
							}
						}
					}
					for (i = 0; i < putting; i++)
					{//中間製品置き場からとるとき、支えの関係を切る
						//if (A_Supports[0][3 + N + i].PId == OyaPa)
						/*if (A_Supports[0][3 + N + i].PId == use_parts)
						{
							A_Supports[1][3 + N + i].Flag = 0;
							A_Supports[1][3 + N + i].PId = 0;
						}*/
						for (k = 0; k < A_Supports[1][3 + N + i].Length; k++)
						{
							if (A_Supports[1][3 + N + i].PId[k] == use_parts) {//A_Supports[][0],A_Supports[][1]には
							   //A_Supports[1][3 + N + i].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][3 + N + i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][3 + N + i].Length;
								A_Supports[1][3 + N + i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = temp[supportlength];//データの移行
										A_Supports[1][3 + N + i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][3 + N + i].Length == 0)
								{
									A_Supports[1][3 + N + i].Flag = 0;
								}
								break;
							}
						}
					}

					if (A_Supports[1][Te].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][Te].Id = A_Hands[Te].Hnum;//部品と手の支えの関係をつくる
						A_Supports[1][Te].Flag = 1;
						A_Supports[1][Te].PId[0] = use_parts;
						A_Supports[1][Te].Length++;
					}
					else
					{
						A_Supports[1][Te].Id = A_Hands[Te].Hnum;
						A_Supports[1][Te].Flag = 1;
						for (k = 0; k < A_Supports[1][Te].Length; k++)
						{
							//A_Supports[0][Te].PId = use_parts;
							if (A_Supports[1][Te].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][Te].PId[A_Supports[1][Te].Length] = use_parts;//部品と手の支えの関係をつくる
							A_Supports[1][Te].Length++;
						}
						else
						{
							supportflug = 0;
						}

					}
					//A_Supports[0][Te].PId = OyaPa;

					//Grip(fp2, use_parts, Te);//掴み取る grip
					//Grip(fp2, OyaPa, Te);//掴み取る grip
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == hakobu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					//Te = M_pattern[movetype].kobuhin[nowmove][Hand];

					if (Te == migite)
					{
						IchiX1 = RhandX;//使用する手の現在の位置
						IchiY1 = RhandY;
						IchiZ1 = RhandZ;
					}
					else if (Te == hidarite)
					{
						IchiX1 = LhandX;//使用する手の現在の位置
						IchiY1 = LhandY;
						IchiZ1 = LhandZ;
					}
					//printf("use_object%d\n", use_object);
					IchiX2 = A_Objects[1][use_object].IchiX;
					IchiY2 = A_Objects[1][use_object].IchiY;
					IchiZ2 = A_Objects[1][use_object].IchiZ;
					//printf("%lf\n", IchiX2);
					/*IchiX2 = A_Objects[1][TyuPnum].IchiX;
					IchiY2 = A_Objects[1][TyuPnum].IchiY;
					IchiZ2 = A_Objects[1][TyuPnum].IchiZ;*/

					//Carry(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);//左手で運ぶ carry

					if (Te == migite)
					{
						RhandX = IchiX2;//手の座標を更新
						RhandY = IchiY2;
						RhandZ = IchiZ2;
					}
					else if (Te == hidarite)
					{
						LhandX = IchiX2;//手の座標を更新
						LhandY = IchiY2;
						LhandZ = IchiZ2;
					}


					if ((Kouguflag != 0 && M_pattern[movetype].Move[Te][nowmove][target] == Ko) || M_pattern[movetype].Move[Te][nowmove][target] == KOUGU || M_pattern[movetype].Move[Te][nowmove][target] == ChangeKOUGU)//工具を用いて部品を運ぶ場合は工具の座標も変更
					{
						KouguX = IchiX2;//工具の座標を更新
						KouguY = IchiY2;
						KouguZ = IchiZ2;
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == okihanasu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = -1;//部品を持っている手がないことを記録
					if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)//対象が工具の時は工具を使用していないのでフラグを0に戻す
					{
						Kouguflag = 0;
					}

					for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
					{//左手、右手、冶具の支えの関係を切る
						//if (A_Supports[1][i].PId == TyuPa)
						f = A_Supports[1][i].Length;//支えている数を保存
						for (k = 0; k < f; k++)
						{
							/*if (A_Supports[1][i].PId == use_parts)
							{
								A_Supports[1][i].Flag = 0;
								A_Supports[1][i].PId = 0;
							}*/
							if (A_Supports[1][i].PId[k] == use_parts)//組立後に部品を支えていてはいけないのでA_Supports[1][i].PId
							{
								for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i].Length;
								A_Supports[1][i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != use_parts)//一致する部品は支えない部品なのでカウントしない
									{
										A_Supports[1][i].PId[A_Supports[1][i].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i].Length == 0)
								{
									A_Supports[1][i].Flag = 0;
								}
								break;
							}
						}

						if (i == Tnum - 1 + N + 3)
						{//中間製品置き場と中間製品の支えの関係を作る
							A_Supports[1][i].Flag = 1;
							//A_Supports[1][i].PId = use_parts;
							//A_Supports[1][i].PId = TyuPa;
							for (k = 0; k < A_Supports[1][i].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][i].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = 1;
									break;
								}
							}
							if (supportflug == 0)//まだ支えられていない時
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = use_parts;//親部品と手の支えの関係をつくる
								A_Supports[1][i].Length++;
							}
							else
							{
								supportflug = 0;
							}
						}
					}

					//leave(fp2, use_parts, Te);//置き放す leave
					//leave(fp2, TyuPa, Te);//置き放す leave
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == tsukeru)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = Te;//部品を持っている手を記録

					if (M_pattern[movetype].Move[Te][nowmove][destination] == KOUGU)//付ける対象が工具の時は工具に付ける
					{
						//Fix(fp2, KouguBnum, use_parts, Te);//付ける fix
						//Fix(fp2, Jigbangou, OyaPa, Te);//付ける fix

						//工具と親部品の支えの関係をつくる
						A_Supports[1][N + 3 + putting + Jigu + Kougunum].Id = A_Kougus[Kougunum].Bnum;
						A_Supports[1][N + 3 + putting + Jigu + Kougunum].Flag = 1;

						if (A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length == 0)
						{
							A_Supports[1][N + 3 + putting + Jigu + Kougunum].PId[A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length] = use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length++;
						}
						else
						{
							for (k = 0; k < A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][N + 3 + putting + Jigu + Kougunum].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = 1;
									break;
								}

								if (supportflug == 0)//まだ支えられていない時
								{
									A_Supports[1][N + 3 + putting + Jigu + Kougunum].PId[A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length] = use_parts;//親部品と手の支えの関係をつくる
									A_Supports[1][N + 3 + putting + Jigu + Kougunum].Length++;
									break;
								}
								else
								{
									supportflug = 0;
								}
							}
						}
					}
					else
					{
						//Fix(fp2, Jigbangou, use_parts, Te);//付ける fix
					   //Fix(fp2, Jigbangou, OyaPa, Te);//付ける fix

					   //治具と親部品の支えの関係をつくる
						A_Supports[1][3 + N + putting + Jig].Id = A_Jigus[Jig].Jnum;
						A_Supports[1][3 + N + putting + Jig].Flag = 1;
						//A_Supports[1][3 + N + putting + Jig].PId = use_parts;
						//A_Supports[1][3 + N + putting + Jig].PId = OyaPa;
						if (A_Supports[1][3 + N + putting + Jig].Length == 0)
						{
							A_Supports[1][3 + N + putting + Jig].PId[A_Supports[1][3 + N + putting + Jig].Length] = use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + Jig].Length++;
						}
						else
						{
							for (k = 0; k < A_Supports[1][3 + N + putting + Jig].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][3 + N + putting + Jig].PId[k] == use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = 1;
									break;
								}

								if (supportflug == 0)//まだ支えられていない時
								{
									A_Supports[1][3 + N + putting + Jig].PId[A_Supports[1][3 + N + putting + Jig].Length] = use_parts;//親部品と手の支えの関係をつくる
									A_Supports[1][3 + N + putting + Jig].Length++;
									break;
								}
								else
								{
									supportflug = 0;
								}
							}
						}
						oya_hoji = A_Jigus[Jig].Jnum;
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == hazusu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					if (M_pattern[movetype].Move[Te][nowmove][destination] == KOUGU || M_pattern[movetype].Move[Te][nowmove][destination] == ChangeKOUGU)
					{
						if (M_pattern[movetype].Move[Te][nowmove][destination] == ChangeKOUGU)
						{
							TempKougunum = ChangeKougunum;
						}
						else
						{
							TempKougunum = Kougunum;
						}

						//Remove(fp2, A_Objects[0][3 * N + 2 + TempKougunum + putting + Jigu - 1].Id, use_parts, Te);//外す remove
						//Remove(fp2, Jigbangou, TyuPa, Te);//外す remove
						//治具と親部品の支えの関係を切る
						//A_Supports[1][3 + N + putting + Jig].PId = 0;

						for (supportlength = 0; supportlength < A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length; supportlength++)
						{
							temp[supportlength] = 0;//配列の初期化
							temp[supportlength] = A_Supports[1][N + 3 + putting + Jigu + TempKougunum].PId[supportlength];//値を移す
							A_Supports[1][N + 3 + putting + Jigu + TempKougunum].PId[supportlength] = 0;//配列の初期化
						}
						templength = 0;
						templength = A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length;
						A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length = 0;//一旦0にする
						for (k = 0; k < templength; k++)
						{
							if (temp[k] != use_parts)
							{
								A_Supports[1][N + 3 + putting + Jigu + TempKougunum].PId[A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length] = temp[k];
								A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length++;
							}
						}
						if (A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Length == 0)
						{
							A_Supports[1][N + 3 + putting + Jigu + TempKougunum].Flag = 0;
						}
					}
					else
					{
						//Remove(fp2, Jigbangou, use_parts, Te);//外す remove
						//Remove(fp2, Jigbangou, TyuPa, Te);//外す remove
						//治具と親部品の支えの関係を切る
						//A_Supports[1][3 + N + putting + Jig].PId = 0;

						for (supportlength = 0; supportlength < A_Supports[1][3 + N + putting + Jig].Length; supportlength++)
						{
							temp[supportlength] = 0;//配列の初期化
							temp[supportlength] = A_Supports[1][3 + N + putting + Jig].PId[supportlength];//値を移す
							A_Supports[1][3 + N + putting + Jig].PId[supportlength] = 0;//配列の初期化
						}
						templength = 0;
						templength = A_Supports[1][3 + N + putting + Jig].Length;
						A_Supports[1][3 + N + putting + Jig].Length = 0;//一旦0にする
						for (k = 0; k < templength; k++)
						{
							if (temp[k] != use_parts)
							{
								A_Supports[1][3 + N + putting + Jig].PId[A_Supports[1][3 + N + putting + Jig].Length] = temp[k];
								A_Supports[1][3 + N + putting + Jig].Length++;
							}
						}
						if (A_Supports[1][3 + N + putting + Jig].Length == 0)
						{
							A_Supports[1][3 + N + putting + Jig].Flag = 0;
						}
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == hanasu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = -1;//部品を持っている手がないことを記録
					if (M_pattern[movetype].Move[Te][nowmove][target] == KOUGU)//対象が工具の時は工具を使用していないのでフラグを0に戻す
					{
						Kouguflag = 0;
					}
					//Release(fp2, use_parts, Te);//放すrelease
					//Release(fp2, OyaPa, Te);//放すrelease
					//親部品と手の支えの関係を切る
					//A_Supports[0][Te].Flag = 0;
					//A_Supports[0][Te].PId = 0;
					for (supportlength = 0; supportlength < A_Supports[1][Te].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][Te].PId[supportlength];//値を移す
						A_Supports[1][Te].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][Te].Length;
					A_Supports[1][Te].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != use_parts)
						{
							A_Supports[1][Te].PId[A_Supports[1][Te].Length] = temp[k];
							A_Supports[1][Te].Length++;
						}
					}
					if (A_Supports[1][Te].Length == 0)
					{
						A_Supports[1][Te].Flag = 0;
					}
					if (Kouguflag != 0)
					{
						for (supportlength = 0; supportlength < A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length; supportlength++)
						{
							temp[supportlength] = 0;//配列の初期化
							temp[supportlength] = A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId[supportlength];//値を移す
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId[supportlength] = 0;//配列の初期化
						}
						templength = 0;
						templength = A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length;
						A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length = 0;//一旦0にする
						for (k = 0; k < templength; k++)
						{
							if (temp[k] != use_parts)
							{
								A_Supports[1][Kougunum + N + 3 + putting + Jigu].PId[A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length] = temp[k];
								A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length++;
							}
						}
						if (A_Supports[1][Kougunum + N + 3 + putting + Jigu].Length == 0)
						{
							A_Supports[1][Kougunum + N + 3 + putting + Jigu].Flag = 0;
						}
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == motinaosu)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					Turn0X = A_Objects[0][use_object].DirX;
					Turn1X = A_Objects[1][use_object].DirX;
					Turn0Y = A_Objects[0][use_object].DirY;
					Turn1Y = A_Objects[1][use_object].DirY;
					Turn0Z = A_Objects[0][use_object].DirZ;
					Turn1Z = A_Objects[1][use_object].DirZ;

					//Turn(fp2, use_parts, Turn0X, Turn0Y, Turn0Z, Turn1X, Turn1Y, Turn1Z, Te);//左手で回転させるturn
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == kumitateidou)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					hold_hands = Te;//部品を持っている手を記録
					/*IchiX1 = A_Objects[1][KoPnum].IchiX;
					IchiY1 = A_Objects[1][KoPnum].IchiY;
					IchiZ1 = A_Objects[1][KoPnum].IchiZ;*/
					if (Te == migite)
					{
						IchiX1 = RhandX;//使用する手の現在の位置
						IchiY1 = RhandY;
						IchiZ1 = RhandZ;
					}
					else if (Te == hidarite)
					{
						IchiX1 = LhandX;//使用する手の現在の位置
						IchiY1 = LhandY;
						IchiZ1 = LhandZ;
					}

					if (kumijun[line].scene_type == oya2ko1)
					{
						/*if (Oya2flag == 1 || Oya2flag == 3)
						{
							IchiX2 = KIdo_X1;
							IchiY2 = KIdo_Y1;
							IchiZ2 = KIdo_Z1;
						}
						else if (Oya2flag == 2)
						{
							IchiX2 = KIdo_X;
							IchiY2 = KIdo_Y;
							IchiZ2 = KIdo_Z;
						}*/
						IchiX2 = KIdo_X1;
						IchiY2 = KIdo_Y1;
						IchiZ2 = KIdo_Z1;
					}
					else
					{
						IchiX2 = KIdo_X;
						IchiY2 = KIdo_Y;
						IchiZ2 = KIdo_Z;
					}

					//Kumimove(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);//組立移動Kumimove

					if (Te == migite)
					{
						RhandX = IchiX2;//手の座標を更新
						RhandY = IchiY2;
						RhandZ = IchiZ2;
					}
					else if (Te == hidarite)
					{
						LhandX = IchiX2;//手の座標を更新
						LhandY = IchiY2;
						LhandZ = IchiZ2;
					}

					if ((Kouguflag != 0 && M_pattern[movetype].Move[Te][nowmove][target] == Ko) || M_pattern[movetype].Move[Te][nowmove][target] == KOUGU || M_pattern[movetype].Move[Te][nowmove][target] == ChangeKOUGU)//工具を用いて部品を運ぶ場合は工具の座標も変更
					{
						KouguX = IchiX2;//工具の座標を更新
						KouguY = IchiY2;
						KouguZ = IchiZ2;
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == kumitateru)
			{
				if ((M_pattern[movetype].Move[Te][nowmove][move] < 0 && ((A_Objects[1][use_object].DirX - A_Objects[0][use_object].DirX) % 360 != 0 || (A_Objects[1][use_object].DirY - A_Objects[0][use_object].DirY) % 360 != 0 || (A_Objects[1][use_object].DirZ - A_Objects[0][use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[Te][nowmove][move] > 0)
				{
					//Te = M_pattern[movetype].kobuhin[nowmove][Hand];
					/*if (kumijun[line].scene_type == oya2ko1)
					{
						Kumitate(fp2, A_Supports[0][N + putting + 3 + kumijun[line].jig - 1].Id, kumijun[line].tyukan, kumijun[line].oya, kumijun[line].ko, Te);//右手で組立Kumitate
						Kumitate(fp2, A_Supports[0][N + putting + 3 + kumijun[line + 1].jig - 1].Id, kumijun[line + 1].tyukan, kumijun[line + 1].oya, kumijun[line + 1].ko, Te);//右手で組立Kumitate
					}*/
					if (kumijun[line].kougu != 0)//工具を用いて組立を行う時
					{
						//KouguKumi(fp2, Jigbangou, Kougunum, TyuPa, OyaPa, KoPa);
					}
					else
					{
						//Kumitate(fp2, Jigbangou, TyuPa, OyaPa, KoPa, Te);//組立Kumitate
					}
				}
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == sentanhenkou)
			{
				//Tipmove(fp2, line, M_pattern[movetype].Move[Te][nowmove][target], Te);
			}
			else if (abs(M_pattern[movetype].Move[Te][nowmove][move]) == hakobu_tsuika)
			{

				if (Te == migite)
				{
					IchiX1 = RhandX;//使用する手の現在の位置
					IchiY1 = RhandY;
					IchiZ1 = RhandZ;
				}
				else if (Te == hidarite)
				{
					IchiX1 = LhandX;//使用する手の現在の位置
					IchiY1 = LhandY;
					IchiZ1 = LhandZ;
				}
				IchiX2 = A_Objects[1][use_object].IchiX + M_pattern[movetype].Move_addition[Te][nowmove][0];
				IchiY2 = A_Objects[1][use_object].IchiY + M_pattern[movetype].Move_addition[Te][nowmove][1];
				IchiZ2 = A_Objects[1][use_object].IchiZ + M_pattern[movetype].Move_addition[Te][nowmove][2];

				//Carry(fp2, IchiX1, IchiY1, IchiZ1, IchiX2, IchiY2, IchiZ2, Te);//左手で運ぶ carry

				if (Te == migite)
				{
					RhandX = IchiX2;//手の座標を更新
					RhandY = IchiY2;
					RhandZ = IchiZ2;
				}
				else if (Te == hidarite)
				{
					LhandX = IchiX2;//手の座標を更新
					LhandY = IchiY2;
					LhandZ = IchiZ2;
				}

				if ((Kouguflag != 0 && M_pattern[movetype].Move[Te][nowmove][target] == Ko) || M_pattern[movetype].Move[Te][nowmove][target] == KOUGU || M_pattern[movetype].Move[Te][nowmove][target] == ChangeKOUGU)//工具を用いて部品を運ぶ場合は工具の座標も変更
				{
					KouguX = IchiX2;//工具の座標を更新
					KouguY = IchiY2;
					KouguZ = IchiZ2;
				}

			}
		}
		else if (Te == ryoute)
		{
			//右手の対象を決める
			if (M_pattern[movetype].Move[migite][nowmove][target] == Oya)//対象製品が親部品
			{

				if (Oya2flag == 1)//基準部品が最初の部品の時
				{//2番目の部品が対象の部品になる
					R_use_parts = kumijun[line + 1].oya;
					R_use_object = OyaPnum;
				}
				else if (Oya2flag == 2)//基準部品が2番目の部品の時
				{//最初の部品が対象の部品になる
					R_use_parts = kumijun[line].oya;
					R_use_object = OyaPnum1;
				}
				else
				{
					R_use_parts = OyaPa;
					R_use_object = OyaPnum;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Ko)//対象製品が子部品
			{
				R_use_parts = KoPa;
				R_use_object = KoPnum;
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Tyukan)//対象製品が中間製品
			{
				R_use_parts = TyuPa;
				R_use_object = TyuPnum;
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Start_P)//手を初期位置に戻すとき、対象製品は使用する手
			{
				R_use_object = 2 * N - 1 + migite;
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Ko1)//両手2部品の時の右手で扱う子部品
			{
				R_use_parts = A_Objects[0][R_KoPnum].Id;
				R_use_object = R_KoPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].ko == R_use_parts)
					{
						R_TyuPa = kumijun[i].tyukan;
						R_line = i;
						if (NewNOS0 == 0)
						{
							R_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									R_Jig = k;
									break;
								}

							}
						}
						R_Jigbangou = A_Supports[0][N + putting + 3 + R_Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Oya1)//両手2部品の時の右手で扱う親部品
			{
				R_use_parts = A_Objects[0][R_OyaPnum].Id;
				R_use_object = R_OyaPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].oya == R_use_parts)
					{
						R_TyuPa = kumijun[i].tyukan;
						R_line = i;
						if (NewNOS0 == 0)
						{
							R_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									R_Jig = k;
									break;
								}

							}
						}
						R_Jigbangou = A_Supports[0][N + putting + 3 + R_Jig].Id;
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][target] == Tyukan1)//両手2部品の時の右手で扱う中間製品部品
			{
				R_use_parts = A_Objects[0][R_TyuPnum].Id;
				R_use_object = R_TyuPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].tyukan == R_use_parts)
					{
						R_TyuPa = kumijun[i].tyukan;
						R_line = i;
						if (NewNOS0 == 0)
						{
							R_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									R_Jig = k;
									break;
								}

							}
						}
						R_Jigbangou = A_Supports[0][N + putting + 3 + R_Jig].Id;
					}
				}
			}

			//左手の対象を決める
			if (M_pattern[movetype].Move[hidarite][nowmove][target] == Oya)//対象製品が親部品
			{
				if (Oya2flag == 1)//基準部品が最初の部品の時
				{//2番目の部品が対象の部品になる
					L_use_parts = kumijun[line + 1].oya;
					L_use_object = OyaPnum;
				}
				else if (Oya2flag == 2)//基準部品が2番目の部品の時
				{//最初の部品が対象の部品になる
					L_use_parts = kumijun[line].oya;
					L_use_object = OyaPnum1;
				}
				else
				{
					L_use_parts = OyaPa;
					L_use_object = OyaPnum;
				}
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Ko)//対象製品が子部品
			{
				L_use_parts = KoPa;
				L_use_object = KoPnum;
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Tyukan)//対象製品が中間製品
			{
				L_use_parts = TyuPa;
				L_use_object = TyuPnum;
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Start_P)//手を初期位置に戻すとき、対象製品は使用する手
			{
				L_use_object = 2 * N - 1 + hidarite;
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Ko2)//両手2部品の時の左手で扱う子部品
			{
				L_use_parts = A_Objects[0][L_KoPnum].Id;
				L_use_object = L_KoPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].ko == L_use_parts)
					{
						L_TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							L_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									L_Jig = k;
									break;
								}

							}
						}
						L_Jigbangou = A_Supports[0][N + putting + 3 + L_Jig].Id;
						L_line = i;
					}
				}
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Oya2)//両手2部品の時の左手で扱う親部品
			{
				L_use_parts = A_Objects[0][L_OyaPnum].Id;
				L_use_object = L_OyaPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].oya == L_use_parts)
					{
						L_TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							L_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									L_Jig = k;
									break;
								}

							}
						}
						L_Jigbangou = A_Supports[0][N + putting + 3 + L_Jig].Id;
						L_line = i;
					}
				}
			}
			else if (M_pattern[movetype].Move[hidarite][nowmove][target] == Tyukan2)//両手2部品の時の左手で扱う中間製品部品
			{
				L_use_parts = A_Objects[0][L_TyuPnum].Id;
				L_use_object = L_TyuPnum;
				for (i = line; i <= line + 1; i++)
				{
					if (kumijun[i].tyukan == L_use_parts)
					{
						L_TyuPa = kumijun[i].tyukan;
						if (NewNOS0 == 0)
						{
							L_Jig = kumijun[i].jig - 1;
						}
						else
						{
							for (k = 0; k < Jigu; k++)
							{
								if (A_Objects[0][3 * N + 2 + k + putting].Id == kumijun[i].jig)
								{
									L_Jig = k;
									break;
								}

							}
						}
						L_Jigbangou = A_Supports[0][N + putting + 3 + L_Jig].Id;
						L_line = i;
					}
				}
			}

			if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[hidarite][nowmove][move]) == nobasu)//右手と左手が同じ動作で伸ばすの時
			{
				//右手と左手の部品に回転があるときに必要、もしくは右手と左手にこの動作が指定されているとき
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{//Te = M_pattern[movetype].kobuhin[nowmove][Hand];
				//もともと治具に付いている部品(親部品)に手を伸ばす


					R_IchiX1 = RhandX;//使用する手の現在の位置
					R_IchiY1 = RhandY;
					R_IchiZ1 = RhandZ;

					L_IchiX1 = LhandX;//使用する手の現在の位置
					L_IchiY1 = LhandY;
					L_IchiZ1 = LhandZ;

					L_IchiX2 = A_Objects[0][L_use_object].IchiX;
					L_IchiY2 = A_Objects[0][L_use_object].IchiY;
					L_IchiZ2 = A_Objects[0][L_use_object].IchiZ;

					R_IchiX2 = A_Objects[0][R_use_object].IchiX;
					R_IchiY2 = A_Objects[0][R_use_object].IchiY;
					R_IchiZ2 = A_Objects[0][R_use_object].IchiZ;
					/*IchiX2 = A_Objects[0][OyaPnum].IchiX;
					IchiY2 = A_Objects[0][OyaPnum].IchiY;
					IchiZ2 = A_Objects[0][OyaPnum].IchiZ;*/

					//WReach(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2);

					LhandX = L_IchiX2;//左手の座標を更新
					LhandY = L_IchiY2;
					LhandZ = L_IchiZ2;
					RhandX = R_IchiX2;//右手の座標を更新
					RhandY = R_IchiY2;
					RhandZ = R_IchiZ2;
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					R_IchiX1 = RhandX;//使用する手の現在の位置
					R_IchiY1 = RhandY;
					R_IchiZ1 = RhandZ;
					R_IchiX2 = A_Objects[0][R_use_object].IchiX;
					R_IchiY2 = A_Objects[0][R_use_object].IchiY;
					R_IchiZ2 = A_Objects[0][R_use_object].IchiZ;

					//Reach(fp2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2, migite);

					RhandX = R_IchiX2;//右手の座標を更新
					RhandY = R_IchiY2;
					RhandZ = R_IchiZ2;

				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					L_IchiX1 = LhandX;//使用する手の現在の位置
					L_IchiY1 = LhandY;
					L_IchiZ1 = LhandZ;
					L_IchiX2 = A_Objects[0][L_use_object].IchiX;
					L_IchiY2 = A_Objects[0][L_use_object].IchiY;
					L_IchiZ2 = A_Objects[0][L_use_object].IchiZ;

					//Reach(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, hidarite);

					LhandX = L_IchiX2;//左手の座標を更新
					LhandY = L_IchiY2;
					LhandZ = L_IchiZ2;
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == hakobu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					//Te = M_pattern[movetype].kobuhin[nowmove][Hand];

					R_IchiX1 = RhandX;//使用する手の現在の位置
					R_IchiY1 = RhandY;
					R_IchiZ1 = RhandZ;

					L_IchiX1 = LhandX;//使用する手の現在の位置
					L_IchiY1 = LhandY;
					L_IchiZ1 = LhandZ;

					L_IchiX2 = A_Objects[1][L_use_object].IchiX;
					L_IchiY2 = A_Objects[1][L_use_object].IchiY;
					L_IchiZ2 = A_Objects[1][L_use_object].IchiZ;

					R_IchiX2 = A_Objects[1][R_use_object].IchiX;
					R_IchiY2 = A_Objects[1][R_use_object].IchiY;
					R_IchiZ2 = A_Objects[1][R_use_object].IchiZ;
					/*IchiX2 = A_Objects[1][TyuPnum].IchiX;
					IchiY2 = A_Objects[1][TyuPnum].IchiY;
					IchiZ2 = A_Objects[1][TyuPnum].IchiZ;*/

					//WCarry(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2);//両手で運ぶ carry

					LhandX = L_IchiX2;//左手の座標を更新
					LhandY = L_IchiY2;
					LhandZ = L_IchiZ2;
					RhandX = R_IchiX2;//右手の座標を更新
					RhandY = R_IchiY2;
					RhandZ = R_IchiZ2;

					/*A_Objects[0][R_use_object].IchiX = R_IchiX2;//部品の座標を更新
					A_Objects[0][R_use_object].IchiY = R_IchiY2;
					A_Objects[0][R_use_object].IchiZ = R_IchiZ2;
					A_Objects[0][L_use_object].IchiX = L_IchiX2;//部品の座標を更新
					A_Objects[0][L_use_object].IchiY = L_IchiY2;
					A_Objects[0][L_use_object].IchiZ = L_IchiZ2;*/
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					R_IchiX1 = RhandX;//使用する手の現在の位置
					R_IchiY1 = RhandY;
					R_IchiZ1 = RhandZ;
					R_IchiX2 = A_Objects[1][R_use_object].IchiX;
					R_IchiY2 = A_Objects[1][R_use_object].IchiY;
					R_IchiZ2 = A_Objects[1][R_use_object].IchiZ;

					//Carry(fp2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2, migite);

					RhandX = R_IchiX2;//右手の座標を更新
					RhandY = R_IchiY2;
					RhandZ = R_IchiZ2;

					/*A_Objects[0][R_use_object].IchiX = R_IchiX2;//部品の座標を更新
					A_Objects[0][R_use_object].IchiY = R_IchiY2;
					A_Objects[0][R_use_object].IchiZ = R_IchiZ2;*/

				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					L_IchiX1 = LhandX;//使用する手の現在の位置
					L_IchiY1 = LhandY;
					L_IchiZ1 = LhandZ;
					L_IchiX2 = A_Objects[1][L_use_object].IchiX;
					L_IchiY2 = A_Objects[1][L_use_object].IchiY;
					L_IchiZ2 = A_Objects[1][L_use_object].IchiZ;

					//Carry(fp2, L_IchiX1, L_IchiY1, R_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, hidarite);

					LhandX = L_IchiX2;//左手の座標を更新
					LhandY = L_IchiY2;
					LhandZ = L_IchiZ2;
					/*A_Objects[0][L_use_object].IchiX = L_IchiX2;//部品の座標を更新
					A_Objects[0][L_use_object].IchiY = L_IchiY2;
					A_Objects[0][L_use_object].IchiZ = L_IchiZ2;*/
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == kumitateidou)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					hold_hands = migite;//部品を持っている手を記録
					/*IchiX1 = A_Objects[1][KoPnum].IchiX;
					IchiY1 = A_Objects[1][KoPnum].IchiY;
					IchiZ1 = A_Objects[1][KoPnum].IchiZ;*/
					L_IchiX1 = A_Objects[1][L_use_object].IchiX;
					L_IchiY1 = A_Objects[1][L_use_object].IchiY;
					L_IchiZ1 = A_Objects[1][L_use_object].IchiZ;

					R_IchiX1 = A_Objects[1][R_use_object].IchiX;
					R_IchiY1 = A_Objects[1][R_use_object].IchiY;
					R_IchiZ1 = A_Objects[1][R_use_object].IchiZ;

					if (kumijun[line].scene_type == oya1ko2 || kumijun[line].scene_type == oya2ko2)
					{
						if (R_line < L_line)
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
						else
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
					}
					else if (kumijun[line].scene_type == oya2ko1)
					{
						if (Oya2flag == 1)//組立順序の最初の部品が基準部品の場合
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
						else if (Oya2flag == 2 || Oya2flag == 3)
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
					}
					else
					{
						R_IchiX2 = KIdo_X;
						R_IchiY2 = KIdo_Y;
						R_IchiZ2 = KIdo_Z;

						L_IchiX2 = KIdo_X;
						L_IchiY2 = KIdo_Y;
						L_IchiZ2 = KIdo_Z;
					}

					//WKumimove(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2);

					LhandX = L_IchiX2;//左手の座標を更新
					LhandY = L_IchiY2;
					LhandZ = L_IchiZ2;
					RhandX = R_IchiX2;//右手の座標を更新
					RhandY = R_IchiY2;
					RhandZ = R_IchiZ2;

					//部品の座標の更新
					/*A_Objects[1][L_use_object].IchiX = L_IchiX2;
					A_Objects[1][L_use_object].IchiY = L_IchiX2;
					A_Objects[1][L_use_object].IchiZ = L_IchiX2;

					A_Objects[1][R_use_object].IchiX = R_IchiX2;
					A_Objects[1][R_use_object].IchiY = R_IchiY2;
					A_Objects[1][R_use_object].IchiZ = R_IchiZ2;*/
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					R_IchiX1 = A_Objects[1][R_use_object].IchiX;
					R_IchiY1 = A_Objects[1][R_use_object].IchiY;
					R_IchiZ1 = A_Objects[1][R_use_object].IchiZ;

					if (kumijun[line].scene_type == oya1ko2 || kumijun[line].scene_type == oya2ko2)
					{
						if (R_line < L_line)
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
						else
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
					}
					else if (kumijun[line].scene_type == oya2ko1)
					{
						if (Oya2flag == 1)//組立順序の最初の部品が基準部品の場合
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
						else if (Oya2flag == 2 || Oya2flag == 3)
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
					}
					else
					{
						R_IchiX2 = KIdo_X;
						R_IchiY2 = KIdo_Y;
						R_IchiZ2 = KIdo_Z;

						L_IchiX2 = KIdo_X;
						L_IchiY2 = KIdo_Y;
						L_IchiZ2 = KIdo_Z;
					}

					//Kumimove(fp2, R_IchiX1, R_IchiY1, R_IchiZ1, R_IchiX2, R_IchiY2, R_IchiZ2, migite);

					RhandX = R_IchiX2;//右手の座標を更新
					RhandY = R_IchiY2;
					RhandZ = R_IchiZ2;
					/*A_Objects[1][R_use_object].IchiX = R_IchiX2;//部品の座標の更新
					A_Objects[1][R_use_object].IchiY = R_IchiY2;
					A_Objects[1][R_use_object].IchiZ = R_IchiZ2;*/
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					L_IchiX1 = A_Objects[1][L_use_object].IchiX;
					L_IchiY1 = A_Objects[1][L_use_object].IchiY;
					L_IchiZ1 = A_Objects[1][L_use_object].IchiZ;

					if (kumijun[line].scene_type == oya1ko2 || kumijun[line].scene_type == oya2ko2)
					{
						if (R_line < L_line)
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
						else
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
					}
					else if (kumijun[line].scene_type == oya2ko1)
					{
						if (Oya2flag == 1)//組立順序の最初の部品が基準部品の場合
						{
							R_IchiX2 = KIdo_X1;
							R_IchiY2 = KIdo_Y1;
							R_IchiZ2 = KIdo_Z1;

							L_IchiX2 = KIdo_X1;
							L_IchiY2 = KIdo_Y1;
							L_IchiZ2 = KIdo_Z1;
						}
						else if (Oya2flag == 2 || Oya2flag == 3)
						{
							R_IchiX2 = KIdo_X;
							R_IchiY2 = KIdo_Y;
							R_IchiZ2 = KIdo_Z;

							L_IchiX2 = KIdo_X;
							L_IchiY2 = KIdo_Y;
							L_IchiZ2 = KIdo_Z;
						}
					}
					else
					{
						R_IchiX2 = KIdo_X;
						R_IchiY2 = KIdo_Y;
						R_IchiZ2 = KIdo_Z;

						L_IchiX2 = KIdo_X;
						L_IchiY2 = KIdo_Y;
						L_IchiZ2 = KIdo_Z;
					}

					//Kumimove(fp2, L_IchiX1, L_IchiY1, L_IchiZ1, L_IchiX2, L_IchiY2, L_IchiZ2, hidarite);

					LhandX = L_IchiX2;//左手の座標を更新
					LhandY = L_IchiY2;
					LhandZ = L_IchiZ2;
					//部品の座標の更新
					/*A_Objects[1][L_use_object].IchiX = L_IchiX2;
					A_Objects[1][L_use_object].IchiY = L_IchiX2;
					A_Objects[1][L_use_object].IchiZ = L_IchiX2;*/
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == tsukeru)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					//WFix(fp2, L_Jigbangou, R_Jigbangou, L_use_parts, R_use_parts);//付ける fix

					//治具と親部品の支えの関係をつくる
					A_Supports[1][3 + N + putting + R_Jig].Id = A_Jigus[R_Jig].Jnum;
					A_Supports[1][3 + N + putting + R_Jig].Flag = 1;

					A_Supports[1][3 + N + putting + L_Jig].Id = A_Jigus[L_Jig].Jnum;
					A_Supports[1][3 + N + putting + L_Jig].Flag = 1;

					for (k = 0; k < A_Supports[1][3 + N + putting + R_Jig].Length; k++)//治具と親部品の支えの関係をつくる(右手)
					{
						//A_Supports[0][Te].PId = use_parts;
						if (A_Supports[1][3 + N + putting + R_Jig].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
						{
							supportflug = 1;
							break;
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][3 + N + putting + R_Jig].PId[A_Supports[1][3 + N + putting + R_Jig].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + R_Jig].Length++;
							break;
						}
						else
						{
							supportflug = 0;
						}
					}

					for (k = 0; k < A_Supports[1][3 + N + putting + L_Jig].Length; k++)//治具と親部品の支えの関係をつくる(左手)
					{
						//A_Supports[0][Te].PId = use_parts;
						if (A_Supports[1][3 + N + putting + L_Jig].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
						{
							supportflug = 1;
							break;
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][3 + N + putting + L_Jig].PId[A_Supports[1][3 + N + putting + L_Jig].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + L_Jig].Length++;
							break;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					//Fix(fp2, R_Jigbangou, R_use_parts, migite);//付ける fix

					//治具と親部品の支えの関係をつくる
					A_Supports[1][3 + N + putting + R_Jig].Id = A_Jigus[R_Jig].Jnum;
					A_Supports[1][3 + N + putting + R_Jig].Flag = 1;
					for (k = 0; k < A_Supports[1][3 + N + putting + R_Jig].Length; k++)//治具と親部品の支えの関係をつくる(右手)
					{
						//A_Supports[0][Te].PId = use_parts;
						if (A_Supports[1][3 + N + putting + R_Jig].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
						{
							supportflug = 1;
							break;
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][3 + N + putting + R_Jig].PId[A_Supports[1][3 + N + putting + R_Jig].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + R_Jig].Length++;
							break;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					//Fix(fp2, L_Jigbangou, L_use_parts, hidarite);//付ける fix
					A_Supports[1][3 + N + putting + L_Jig].Id = A_Jigus[L_Jig].Jnum;
					A_Supports[1][3 + N + putting + L_Jig].Flag = 1;
					for (k = 0; k < A_Supports[1][3 + N + putting + L_Jig].Length; k++)//治具と親部品の支えの関係をつくる(左手)
					{
						//A_Supports[0][Te].PId = use_parts;
						if (A_Supports[1][3 + N + putting + L_Jig].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
						{
							supportflug = 1;
							break;
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][3 + N + putting + L_Jig].PId[A_Supports[1][3 + N + putting + L_Jig].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][3 + N + putting + L_Jig].Length++;
							break;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == tsukamu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					//WGripping(fp2, L_use_parts, R_use_parts);//掴む
					//Gripping(fp2, TyuPa, Te);//掴む

					if (A_Supports[1][hidarite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][hidarite].Flag = 1;
						A_Supports[1][hidarite].PId[0] = L_use_parts;
						A_Supports[1][hidarite].Length++;
					}
					else
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;
						A_Supports[1][hidarite].Flag = 1;
						for (k = 0; k < A_Supports[1][hidarite].Length; k++)
						{
							//A_Supports[0][hidarite].PId = use_parts;
							if (A_Supports[1][hidarite].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][hidarite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

					if (A_Supports[1][migite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][migite].Flag = 1;
						A_Supports[1][migite].PId[0] = R_use_parts;
						A_Supports[1][migite].Length++;
					}
					else
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;
						A_Supports[1][migite].Flag = 1;
						for (k = 0; k < A_Supports[1][migite].Length; k++)
						{
							//A_Supports[0][migite].PId = use_parts;
							if (A_Supports[1][migite].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][migite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					//Gripping(fp2, R_use_parts, migite);
					if (A_Supports[1][migite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][migite].Flag = 1;
						A_Supports[1][migite].PId[0] = R_use_parts;
						A_Supports[1][migite].Length++;
					}
					else
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;
						A_Supports[1][migite].Flag = 1;
						for (k = 0; k < A_Supports[1][migite].Length; k++)
						{
							//A_Supports[0][migite].PId = use_parts;
							if (A_Supports[1][migite].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][migite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					//Gripping(fp2, L_use_parts, hidarite);
					if (A_Supports[1][hidarite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][hidarite].Flag = 1;
						A_Supports[1][hidarite].PId[0] = L_use_parts;
						A_Supports[1][hidarite].Length++;
					}
					else
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;
						A_Supports[1][hidarite].Flag = 1;
						for (k = 0; k < A_Supports[1][hidarite].Length; k++)
						{
							//A_Supports[0][hidarite].PId = use_parts;
							if (A_Supports[1][hidarite].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][hidarite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == tsukamitoru)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					//WGrip(fp2, L_use_parts, R_use_parts);

					//右側の部品に関して
					if (JigKobuhin == R_use_parts || JigKobuhin2 == R_use_parts || ChangeJig == R_use_parts || ChangeJig2 == R_use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == R_use_parts)
								{
									//BeforeJigR = A_Supports[1][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					//左側の部品に関して
					if (JigKobuhin == L_use_parts || JigKobuhin2 == L_use_parts || ChangeJig == L_use_parts || ChangeJig2 == L_use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == L_use_parts)
								{
									//BeforeJigL = A_Supports[1][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					for (i = 0; i < Bboxnum; i++)
					{
						for (k = 0; k < A_Supports[1][i + 2].Length; k++)
						{
							if (A_Supports[1][i + 2].PId[k] == L_use_parts || A_Supports[1][i + 2].PId[k] == R_use_parts) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
							   //A_Supports[1][i + 2].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i + 2].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i + 2].Length;
								A_Supports[1][i + 2].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if ((temp[supportlength] != L_use_parts && A_Supports[1][i + 2].PId[k] == L_use_parts) ||
										(temp[supportlength] != R_use_parts && A_Supports[1][i + 2].PId[k] == R_use_parts))//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i + 2].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i + 2].Length == 0)
								{
									A_Supports[1][i + 2].Flag = 0;
								}
								break;
							}
						}
					}
					for (i = 0; i < putting; i++)
					{//中間製品置き場からとるとき、支えの関係を切る
						//if (A_Supports[0][3 + N + i].PId == OyaPa)
						/*if (A_Supports[0][3 + N + i].PId == use_parts)
						{
							A_Supports[1][3 + N + i].Flag = 0;
							A_Supports[1][3 + N + i].PId = 0;
						}*/
						for (k = 0; k < A_Supports[1][3 + N + i].Length; k++)
						{
							if (A_Supports[1][3 + N + i].PId[k] == L_use_parts || A_Supports[1][3 + N + i].PId[k] == R_use_parts)//右手で扱う部品か左手で扱う部品の時
							{
								//A_Supports[1][3 + N + i].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][3 + N + i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][3 + N + i].Length;
								A_Supports[1][3 + N + i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if ((temp[supportlength] != L_use_parts && A_Supports[1][3 + N + i].PId[k] == L_use_parts) ||
										(temp[supportlength] != R_use_parts && A_Supports[1][3 + N + i].PId[k] == R_use_parts))//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = temp[supportlength];//データの移行
										A_Supports[1][3 + N + i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][3 + N + i].Length == 0)
								{
									A_Supports[1][3 + N + i].Flag = 0;
								}
								break;
							}
						}
					}

					if (A_Supports[1][hidarite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][hidarite].Flag = 1;
						A_Supports[1][hidarite].PId[0] = L_use_parts;
						A_Supports[1][hidarite].Length++;
					}
					else
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;
						A_Supports[1][hidarite].Flag = 1;
						for (k = 0; k < A_Supports[1][hidarite].Length; k++)
						{
							//A_Supports[0][hidarite].PId = use_parts;
							if (A_Supports[1][hidarite].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][hidarite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}

					if (A_Supports[1][migite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][migite].Flag = 1;
						A_Supports[1][migite].PId[0] = R_use_parts;
						A_Supports[1][migite].Length++;
					}
					else
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;
						A_Supports[1][migite].Flag = 1;
						for (k = 0; k < A_Supports[1][migite].Length; k++)
						{
							//A_Supports[0][migite].PId = use_parts;
							if (A_Supports[1][migite].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][migite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					//WGrip(fp2, R_use_parts, migite);

					//右側の部品に関して
					if (JigKobuhin == R_use_parts || JigKobuhin2 == R_use_parts || ChangeJig == R_use_parts || ChangeJig2 == R_use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == R_use_parts)
								{
									//BeforeJigR = A_Supports[1][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					for (i = 0; i < Bboxnum; i++)
					{
						for (k = 0; k < A_Supports[1][i + 2].Length; k++)
						{
							if (A_Supports[1][i + 2].PId[k] == R_use_parts) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
							   //A_Supports[1][i + 2].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i + 2].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i + 2].Length;
								A_Supports[1][i + 2].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != R_use_parts && A_Supports[1][i + 2].PId[k] == R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i + 2].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i + 2].Length == 0)
								{
									A_Supports[1][i + 2].Flag = 0;
								}
								break;
							}
						}
					}
					for (i = 0; i < putting; i++)
					{//中間製品置き場からとるとき、支えの関係を切る
						//if (A_Supports[0][3 + N + i].PId == OyaPa)
						/*if (A_Supports[0][3 + N + i].PId == use_parts)
						{
							A_Supports[1][3 + N + i].Flag = 0;
							A_Supports[1][3 + N + i].PId = 0;
						}*/
						for (k = 0; k < A_Supports[1][3 + N + i].Length; k++)
						{
							if (A_Supports[1][3 + N + i].PId[k] == R_use_parts)//右手で扱う部品か左手で扱う部品の時
							{
								//A_Supports[1][3 + N + i].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][3 + N + i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][3 + N + i].Length;
								A_Supports[1][3 + N + i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != R_use_parts && A_Supports[1][3 + N + i].PId[k] == R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = temp[supportlength];//データの移行
										A_Supports[1][3 + N + i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][3 + N + i].Length == 0)
								{
									A_Supports[1][3 + N + i].Flag = 0;
								}
								break;
							}
						}
					}
					if (A_Supports[1][migite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][migite].Flag = 1;
						A_Supports[1][migite].PId[0] = use_parts;
						A_Supports[1][migite].Length++;
					}
					else
					{
						A_Supports[1][migite].Id = A_Hands[migite].Hnum;
						A_Supports[1][migite].Flag = 1;
						for (k = 0; k < A_Supports[1][migite].Length; k++)
						{
							//A_Supports[0][migite].PId = use_parts;
							if (A_Supports[1][migite].PId[k] == R_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = R_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][migite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					//WGrip(fp2, L_use_parts, hidarite);

					//左側の部品に関して
					if (JigKobuhin == L_use_parts || JigKobuhin2 == L_use_parts || ChangeJig == L_use_parts || ChangeJig2 == L_use_parts)//治具を交換する親部品または子部品が治具についている場合に前の治具から部品を外す
					{
						for (i = 0; i < Jigu; i++)
						{
							for (k = 0; k < A_Supports[0][i + N + 3 + putting].Length; k++)
							{
								if (A_Supports[0][i + N + 3 + putting].PId[k] == L_use_parts)
								{
									//BeforeJigL = A_Supports[1][i + N + 3 + putting].Id;

									for (supportlength = 0; supportlength < A_Supports[1][i + N + 3 + putting].Length; supportlength++)
									{
										temp[supportlength] = 0;//配列の初期化
										temp[supportlength] = A_Supports[1][i + N + 3 + putting].PId[supportlength];//値を移す
										A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
									}
									templength = 0;
									templength = A_Supports[1][i + N + 3 + putting].Length;
									A_Supports[1][i + N + 3 + putting].Length = 0;//一旦0にする
									for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
									{
										if (temp[supportlength] != L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
										{
											A_Supports[1][i + N + 3 + putting].PId[A_Supports[1][i + N + 3 + putting].Length] = temp[supportlength];//一致する子部品以外のデータの移行
											A_Supports[1][i + N + 3 + putting].Length++;//カウントを増やす
										}
									}

									if (A_Supports[1][i + N + 3 + putting].Length == 0)
									{
										A_Supports[1][i + N + 3 + putting].Flag = 0;
									}
									break;
								}
							}
						}
					}

					for (i = 0; i < Bboxnum; i++)
					{
						for (k = 0; k < A_Supports[1][i + 2].Length; k++)
						{
							if (A_Supports[1][i + 2].PId[k] == L_use_parts) {//A_Supports[][0],A_Supports[][1]には手の情報が入っているのでi+2
							   //A_Supports[1][i + 2].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][i + 2].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i + 2].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i + 2].Length;
								A_Supports[1][i + 2].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != L_use_parts && A_Supports[1][i + 2].PId[k] == L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i + 2].PId[A_Supports[1][i + 2].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i + 2].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i + 2].Length == 0)
								{
									A_Supports[1][i + 2].Flag = 0;
								}
								break;
							}
						}
					}
					for (i = 0; i < putting; i++)
					{//中間製品置き場からとるとき、支えの関係を切る
						//if (A_Supports[0][3 + N + i].PId == OyaPa)
						/*if (A_Supports[0][3 + N + i].PId == use_parts)
						{
							A_Supports[1][3 + N + i].Flag = 0;
							A_Supports[1][3 + N + i].PId = 0;
						}*/
						for (k = 0; k < A_Supports[1][3 + N + i].Length; k++)
						{
							if (A_Supports[1][3 + N + i].PId[k] == L_use_parts)//右手で扱う部品か左手で扱う部品の時
							{
								//A_Supports[1][3 + N + i].Flag = 0;
								for (supportlength = 0; supportlength < A_Supports[1][3 + N + i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][3 + N + i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][3 + N + i].Length;
								A_Supports[1][3 + N + i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != L_use_parts && A_Supports[1][3 + N + i].PId[k] == L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][3 + N + i].PId[A_Supports[1][3 + N + i].Length] = temp[supportlength];//データの移行
										A_Supports[1][3 + N + i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][3 + N + i].Length == 0)
								{
									A_Supports[1][3 + N + i].Flag = 0;
								}
								break;
							}
						}
					}

					if (A_Supports[1][hidarite].Length == 0)//まだ対象とする手で部品を保持していないとき
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;//親部品と手の支えの関係をつくる
						A_Supports[1][hidarite].Flag = 1;
						A_Supports[1][hidarite].PId[0] = use_parts;
						A_Supports[1][hidarite].Length++;
					}
					else
					{
						A_Supports[1][hidarite].Id = A_Hands[hidarite].Hnum;
						A_Supports[1][hidarite].Flag = 1;
						for (k = 0; k < A_Supports[1][hidarite].Length; k++)
						{
							//A_Supports[0][hidarite].PId = use_parts;
							if (A_Supports[1][hidarite].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
							{
								supportflug = 1;
								break;
							}
						}

						if (supportflug == 0)//まだ支えられていない時
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = L_use_parts;//親部品と手の支えの関係をつくる
							A_Supports[1][hidarite].Length++;
						}
						else
						{
							supportflug = 0;
						}
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == okihanasu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					//Wleave(fp2, L_use_parts, R_use_parts);//置き放す leave
					//leave(fp2, TyuPa, Te);//置き放す leave

					for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
					{//左手、右手、冶具の支えの関係を切る
						//if (A_Supports[1][i].PId == TyuPa)
						f = A_Supports[1][i].Length;//支えている数を保存
						for (k = 0; k < f; k++)
						{
							/*if (A_Supports[1][i].PId == use_parts)
							{
								A_Supports[1][i].Flag = 0;
								A_Supports[1][i].PId = 0;
							}*/
							if (A_Supports[1][i].PId[k] == L_use_parts || A_Supports[1][i].PId[k] == R_use_parts)//組立後に部品を支えていてはいけないのでA_Supports[1][i].PId
							{
								for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i].Length;
								A_Supports[1][i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if ((temp[supportlength] != L_use_parts && A_Supports[1][3 + N + i].PId[k] == L_use_parts) ||
										(temp[supportlength] != R_use_parts && A_Supports[1][3 + N + i].PId[k] == R_use_parts))//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i].PId[A_Supports[1][i].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i].Length == 0)
								{
									A_Supports[1][i].Flag = 0;
								}
								break;
							}
						}

						if (i == Tnum - 1 + N + 3)
						{//中間製品置き場と中間製品の支えの関係を作る
							A_Supports[1][i].Flag = 1;
							//A_Supports[1][i].PId = use_parts;
							//A_Supports[1][i].PId = TyuPa;
							for (k = 0; k < A_Supports[1][i].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][i].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = supportflug + 1;//左手で扱う部品を持っている時は＋2する
								}
								else if (A_Supports[1][i].PId[k] == R_use_parts)
								{
									supportflug = supportflug + 2;//右手で扱う部品を持っている時は＋2する
								}
							}
							if (supportflug == 0)//まだ支えられていない時
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = L_use_parts;//中間製品置き場と左手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;

								A_Supports[1][i].PId[A_Supports[1][i].Length] = R_use_parts;//中間製品置き場と右手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else if (supportflug == 1)//左手で扱う部品がすでに支えられているとき(一応の作業)
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = R_use_parts;//中間製品置き場と中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else if (supportflug == 2)//右手で扱う部品がすでに支えられているとき(一応の作業)
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = L_use_parts;//中間製品置き場と左手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else
							{
								supportflug = 0;
							}
						}
					}

				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					//leave(fp2, R_use_parts, migite);
					for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
					{//右手、冶具の支えの関係を切る
						//if (A_Supports[1][i].PId == TyuPa)
						f = A_Supports[1][i].Length;//支えている数を保存
						for (k = 0; k < f; k++)
						{
							/*if (A_Supports[1][i].PId == use_parts)
							{
								A_Supports[1][i].Flag = 0;
								A_Supports[1][i].PId = 0;
							}*/
							if (A_Supports[1][i].PId[k] == R_use_parts)//組立後に部品を支えていてはいけないのでA_Supports[1][i].PId
							{
								for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i].Length;
								A_Supports[1][i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != R_use_parts && A_Supports[1][3 + N + i].PId[k] == R_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i].PId[A_Supports[1][i].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i].Length == 0)
								{
									A_Supports[1][i].Flag = 0;
								}
								break;
							}
						}

						if (i == Tnum - 1 + N + 3)
						{//中間製品置き場と中間製品の支えの関係を作る
							A_Supports[1][i].Flag = 1;
							//A_Supports[1][i].PId = use_parts;
							//A_Supports[1][i].PId = TyuPa;
							for (k = 0; k < A_Supports[1][i].Length; k++)
							{
								if (A_Supports[1][i].PId[k] == R_use_parts)
								{
									supportflug = supportflug + 2;//右手で扱う部品を持っている時は＋2する
								}
							}
							if (supportflug == 0)//まだ支えられていない時
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = R_use_parts;//中間製品置き場と右手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else
							{
								supportflug = 0;
							}
						}
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					//leave(fp2, L_use_parts, hidarite);
					for (i = 0; i < N + 3 + putting + Jigu + Kougu; i++)
					{//左手、右手、冶具の支えの関係を切る
						//if (A_Supports[1][i].PId == TyuPa)
						f = A_Supports[1][i].Length;//支えている数を保存
						for (k = 0; k < f; k++)
						{
							/*if (A_Supports[1][i].PId == use_parts)
							{
								A_Supports[1][i].Flag = 0;
								A_Supports[1][i].PId = 0;
							}*/
							if (A_Supports[1][i].PId[k] == L_use_parts)//組立後に部品を支えていてはいけないのでA_Supports[1][i].PId
							{
								for (supportlength = 0; supportlength < A_Supports[1][i].Length; supportlength++)
								{
									temp[supportlength] = 0;//配列の初期化
									temp[supportlength] = A_Supports[1][i].PId[supportlength];//値を移す
									A_Supports[1][i].PId[supportlength] = 0;//配列の初期化
								}
								templength = 0;
								templength = A_Supports[1][i].Length;
								A_Supports[1][i].Length = 0;//一旦0にする
								for (supportlength = 0; supportlength < templength; supportlength++)//状態で支えている数だけ回す
								{
									if (temp[supportlength] != L_use_parts && A_Supports[1][3 + N + i].PId[k] == L_use_parts)//一致する部品は部品箱から取る部品なのでカウントしない
									{
										A_Supports[1][i].PId[A_Supports[1][i].Length] = temp[supportlength];//一致する子部品以外のデータの移行
										A_Supports[1][i].Length++;//カウントを増やす
									}
								}

								if (A_Supports[1][i].Length == 0)
								{
									A_Supports[1][i].Flag = 0;
								}
								break;
							}
						}

						if (i == Tnum - 1 + N + 3)
						{//中間製品置き場と中間製品の支えの関係を作る
							A_Supports[1][i].Flag = 1;
							//A_Supports[1][i].PId = use_parts;
							//A_Supports[1][i].PId = TyuPa;
							for (k = 0; k < A_Supports[1][i].Length; k++)
							{
								//A_Supports[0][Te].PId = use_parts;
								if (A_Supports[1][i].PId[k] == L_use_parts)//すでに支えている時は新たに支えを作る必要はないのでフラグを付ける
								{
									supportflug = supportflug + 1;//左手で扱う部品を持っている時は＋1する
								}
							}
							if (supportflug == 0)//まだ支えられていない時
							{
								A_Supports[1][i].PId[A_Supports[1][i].Length] = L_use_parts;//中間製品置き場と左手の中間製品の支えの関係を作る
								A_Supports[1][i].Length++;
							}
							else
							{
								supportflug = 0;
							}
						}
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == hanasu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					//WRelease(fp2, L_use_parts, R_use_parts);//両手で放すrelease

					for (supportlength = 0; supportlength < A_Supports[1][hidarite].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][hidarite].PId[supportlength];//値を移す
						A_Supports[1][hidarite].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][hidarite].Length;
					A_Supports[1][hidarite].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != L_use_parts)
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = temp[k];
							A_Supports[1][hidarite].Length++;
						}
					}
					if (A_Supports[1][hidarite].Length == 0)
					{
						A_Supports[1][hidarite].Flag = 0;
					}

					for (supportlength = 0; supportlength < A_Supports[1][migite].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][migite].PId[supportlength];//値を移す
						A_Supports[1][migite].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][migite].Length;
					A_Supports[1][migite].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != use_parts)
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = temp[k];
							A_Supports[1][migite].Length++;
						}
					}
					if (A_Supports[1][migite].Length == 0)
					{
						A_Supports[1][migite].Flag = 0;
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					//Release(fp2, R_use_parts, migite);//右手で放すrelease
					for (supportlength = 0; supportlength < A_Supports[1][migite].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][migite].PId[supportlength];//値を移す
						A_Supports[1][migite].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][migite].Length;
					A_Supports[1][migite].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != use_parts)
						{
							A_Supports[1][migite].PId[A_Supports[1][migite].Length] = temp[k];
							A_Supports[1][migite].Length++;
						}
					}
					if (A_Supports[1][migite].Length == 0)
					{
						A_Supports[1][migite].Flag = 0;
					}
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					//Release(fp2, L_use_parts, hidarite);//左手で放すrelease
					for (supportlength = 0; supportlength < A_Supports[1][hidarite].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][hidarite].PId[supportlength];//値を移す
						A_Supports[1][hidarite].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][hidarite].Length;
					A_Supports[1][hidarite].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != L_use_parts)
						{
							A_Supports[1][hidarite].PId[A_Supports[1][hidarite].Length] = temp[k];
							A_Supports[1][hidarite].Length++;
						}
					}
					if (A_Supports[1][hidarite].Length == 0)
					{
						A_Supports[1][hidarite].Flag = 0;
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == kumitateru)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					oya_hoji = A_Jigus[Jig].Jnum;
					if (R_line < L_line)
					{
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[R_line].jig - 1].Id, TyuPa, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[L_line].jig - 1].Id, TyuPa2, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
					}
					else
					{
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[L_line].jig - 1].Id, TyuPa, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[R_line].jig - 1].Id, TyuPa2, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
					}
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					oya_hoji = A_Jigus[Jig].Jnum;
					if (R_line < L_line)
					{
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[R_line].jig - 1].Id, TyuPa, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[L_line].jig - 1].Id, TyuPa2, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
					}
					else
					{
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[L_line].jig - 1].Id, TyuPa, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[R_line].jig - 1].Id, TyuPa2, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
					}

				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					oya_hoji = A_Jigus[Jig].Jnum;
					if (R_line < L_line)
					{
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[R_line].jig - 1].Id, TyuPa, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[L_line].jig - 1].Id, TyuPa2, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
					}
					else
					{
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[L_line].jig - 1].Id, TyuPa, kumijun[L_line].oya, kumijun[L_line].ko, hidarite);//左手で組立Kumitate
						//Kumitate(fp2, A_Supports[1][N + putting + 3 + kumijun[R_line].jig - 1].Id, TyuPa2, kumijun[R_line].oya, kumijun[R_line].ko, migite);//右手で組立Kumitate
					}
				}
			}
			else if (M_pattern[movetype].Move[migite][nowmove][move] == M_pattern[movetype].Move[hidarite][nowmove][move] && abs(M_pattern[movetype].Move[migite][nowmove][move]) == motinaosu)
			{
				if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)
					&& ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0)
					|| (M_pattern[movetype].Move[migite][nowmove][move] > 0 && M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0))
					|| (M_pattern[movetype].Move[migite][nowmove][move] < 0 && M_pattern[movetype].Move[hidarite][nowmove][move] > 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)))
				{
					L_Turn0X = A_Objects[0][L_use_object].DirX;
					L_Turn1X = A_Objects[1][L_use_object].DirX;
					L_Turn0Y = A_Objects[0][L_use_object].DirY;
					L_Turn1Y = A_Objects[1][L_use_object].DirY;
					L_Turn0Z = A_Objects[0][L_use_object].DirZ;
					L_Turn1Z = A_Objects[1][L_use_object].DirZ;

					R_Turn0X = A_Objects[0][R_use_object].DirX;
					R_Turn1X = A_Objects[1][R_use_object].DirX;
					R_Turn0Y = A_Objects[0][R_use_object].DirY;
					R_Turn1Y = A_Objects[1][R_use_object].DirY;
					R_Turn0Z = A_Objects[0][R_use_object].DirZ;
					R_Turn1Z = A_Objects[1][R_use_object].DirZ;

					//WTurn(fp2, L_use_parts, L_Turn0X, L_Turn0Y, L_Turn0Z, L_Turn1X, L_Turn1Y, L_Turn1Z, R_use_parts, R_Turn0X, R_Turn0Y, R_Turn0Z, R_Turn1X, R_Turn1Y, R_Turn1Z);//左手で回転させるturn
				}
				else if ((M_pattern[movetype].Move[migite][nowmove][move] < 0 && ((A_Objects[1][R_use_object].DirX - A_Objects[0][R_use_object].DirX) % 360 != 0 || (A_Objects[1][R_use_object].DirY - A_Objects[0][R_use_object].DirY) % 360 != 0 || (A_Objects[1][R_use_object].DirZ - A_Objects[0][R_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[migite][nowmove][move] > 0)//右手の部品だけを動かす場合
				{
					R_Turn0X = A_Objects[0][R_use_object].DirX;
					R_Turn1X = A_Objects[1][R_use_object].DirX;
					R_Turn0Y = A_Objects[0][R_use_object].DirY;
					R_Turn1Y = A_Objects[1][R_use_object].DirY;
					R_Turn0Z = A_Objects[0][R_use_object].DirZ;
					R_Turn1Z = A_Objects[1][R_use_object].DirZ;

					//Turn(fp2, R_use_parts, R_Turn0X, R_Turn0Y, R_Turn0Z, R_Turn1X, R_Turn1Y, R_Turn1Z, migite);//回転させるturn
				}
				else if ((M_pattern[movetype].Move[hidarite][nowmove][move] < 0 && ((A_Objects[1][L_use_object].DirX - A_Objects[0][L_use_object].DirX) % 360 != 0 || (A_Objects[1][L_use_object].DirY - A_Objects[0][L_use_object].DirY) % 360 != 0 || (A_Objects[1][L_use_object].DirZ - A_Objects[0][L_use_object].DirZ) % 360 != 0)) || M_pattern[movetype].Move[hidarite][nowmove][move] > 0)//左手の部品だけを動かす場合
				{
					L_Turn0X = A_Objects[0][L_use_object].DirX;
					L_Turn1X = A_Objects[1][L_use_object].DirX;
					L_Turn0Y = A_Objects[0][L_use_object].DirY;
					L_Turn1Y = A_Objects[1][L_use_object].DirY;
					L_Turn0Z = A_Objects[0][L_use_object].DirZ;
					L_Turn1Z = A_Objects[1][L_use_object].DirZ;
					//Turn(fp2, L_use_parts, L_Turn0X, L_Turn0Y, L_Turn0Z, L_Turn1X, L_Turn1Y, L_Turn1Z, hidarite);
				}
			}
		}
	}

	//手の最終座標を合わせる
	A_Objects[1][2 * N - 1 + migite].IchiX = RhandX;
	A_Objects[1][2 * N - 1 + migite].IchiY = RhandY;
	A_Objects[1][2 * N - 1 + migite].IchiZ = RhandZ;

	A_Objects[1][2 * N - 1 + hidarite].IchiX = LhandX;
	A_Objects[1][2 * N - 1 + hidarite].IchiY = LhandY;
	A_Objects[1][2 * N - 1 + hidarite].IchiZ = LhandZ;

	if (kumijun[line].kougu != 0)//工具を用いる時
	{
		A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiX = KouguX;//工具の座標を更新
		A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiY = KouguY;
		A_Objects[1][3 * N + 2 + Kougunum + putting + Jigu].IchiZ = KouguZ;
	}
}

void MaikingOffset(int line, double* OyaJigX, double* OyaJigY, double* OyaJigZ)
{
	int i, j, q = 0, o = 0;//pは部品1でなかったかあったかを見分ける
	int OyaKousei = 0, KoKousei = 0;//中間製品の構成部品(親部品),中間製品の構成部品(子部品)
	double Ko_X = 0, Ko_Y = 0, Ko_Z = 0, Oya_X = 0, Oya_Y = 0, Oya_Z = 0, Sa_X, Sa_Y, Sa_Z;//子部品の中心、親部品の中心、その差
	double K_Sa_X, K_Sa_Y, K_Sa_Z;//計算用の差
	double X_Max = 0, X_Min = 0, Y_Max = 0, Y_Min = 0, Z_Max = 0, Z_Min = 0;//中間製品の中心座標を計算するのに用いる
	double rad;//ラジアンに変換
	double JiguZ = 0;
	int JiguOya;
	int Jig = 0;

	double KariX = 0, KariY = 0, KariZ = 0;
	int Jigfix = 0, Jigflag = 0, Karinum = 0, Karijignum=0;//治具についている部品がjig_partsでどこにあるか,karijignumは小峯修正
	int temp[MaxSupport], templength = 0;
	int supportlength = 0, k = 0, supportflug = 0, f = 0;

	//JiguOya = A_Supports[1][2 + N + 1 + putting].PId;
	JiguOya = kumijun[line].oya;
	if (NewNOS0 == 0)
	{
		Jig = kumijun[line].jig - 1;
	}
	else
	{
		for (i = 0; i < Jigu; i++)
		{
			if (A_Objects[0][3 * N + 2 + i + putting].Id == kumijun[line].jig)
			{
				Jig = i;
				break;
			}

		}
	}

	if (JiguOya > N) {//治具についてる部品が中間製品の時
		if (kumijun[line].ko > N) {//子部品が中間製品の時

			/*for (i = 0; i < N; i++) {//治具の組付け暫定的な位置
				if (A_Buhin[i].Buhinnum == JiguOya) {
					JiguZ = A_Buhin[i].Lengrh_Z / 2.0;
				}
			}*/
			for (i = 0; i < e; i++) {//親部品である中間製品を探して中心点の部品を決める
				if (A_Tyukantyusin[i].TyukanNum == JiguOya) {
					OyaKousei = A_Tyukantyusin[i].Tyusin;
				}
			}

			for (i = 0; i < N; i++) {//部品属性から親部品である中間製品の中心点になる部品の情報を読み取る
				if (A_Buhin[i].Buhinnum == OyaKousei) {
					Oya_X = A_Buhin[i].Tyusin_X;
					Oya_Y = A_Buhin[i].Tyusin_Y;
					Oya_Z = A_Buhin[i].Tyusin_Z;
					JiguZ = A_Buhin[i].Lengrh_Z / 2.0;
				}
			}
			for (j = 0; j < JigPartssu; j++)//親部品が治具についているかどうか調べる
			{
				if (jig_parts[j].num == kumijun[line].oya && jig_parts[j].jignum == Jig)//親部品が治具についているとき
				{
					Jigfix = j;
					Jigflag = 1;
					*OyaJigX = jig_parts[j].IchiX;
					*OyaJigY = jig_parts[j].IchiY;
					*OyaJigZ = jig_parts[j].IchiZ;
					break;
				}
				else if (jig_parts[j].num == kumijun[line].oya)//使用する治具にはついていないが、ほかの治具についているとき
				{
					*OyaJigX = A_Jigus[Jig].H_IchiX - A_Jigus[Jig].SizeX / 2;
					*OyaJigY = A_Jigus[Jig].H_IchiY - A_Jigus[Jig].SizeY / 2;
					*OyaJigZ = A_Jigus[Jig].H_IchiZ + JiguZ + A_Jigus[Jig].SizeZ / 2;

					Jigflag = 1;
					jig_parts[j].jignum = Jig;
					jig_parts[j].IchiX = *OyaJigX;
					jig_parts[j].IchiY = *OyaJigY;
					jig_parts[j].IchiZ = *OyaJigZ;
					break;
				}
			}

			if (Jigflag == 0)
			{
				*OyaJigX = A_Jigus[Jig].H_IchiX - A_Jigus[Jig].SizeX / 2;
				*OyaJigY = A_Jigus[Jig].H_IchiY - A_Jigus[Jig].SizeY / 2;
				*OyaJigZ = A_Jigus[Jig].H_IchiZ + JiguZ + A_Jigus[Jig].SizeZ / 2;

				jig_parts[JigPartssu].num = JiguOya;
				jig_parts[JigPartssu].jignum = Jig;
				jig_parts[JigPartssu].Id = A_Objects[0][3 * N + 2 + Jig + putting].Id;
				jig_parts[JigPartssu].IchiX = *OyaJigX;
				jig_parts[JigPartssu].IchiY = *OyaJigY;
				jig_parts[JigPartssu].IchiZ = *OyaJigZ;
				JigPartssu++;
			}

			for (j = 0; j < JigPartssu; j++)//子部品が治具についているかどうか調べる
			{
				if (jig_parts[j].num == kumijun[line].ko)//子部品が治具についているとき
				{
					//治具から子部品を外す
					for (supportlength = 0; supportlength < A_Supports[1][3 + N + putting + Jig].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][3 + N + putting + Jig].PId[supportlength];//値を移す
						A_Supports[1][3 + N + putting + Jig].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][3 + N + putting + Jig].Length;
					A_Supports[1][3 + N + putting + Jig].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != kumijun[line].ko)//一致する部品は治具から外す部品なので一致しない部品を入れ替える
						{
							A_Supports[1][3 + N + putting + Jig].PId[A_Supports[1][3 + N + putting + Jig].Length] = temp[k];
							A_Supports[1][3 + N + putting + Jig].Length++;
						}
					}
					if (A_Supports[1][3 + N + putting + Jig].Length == 0)
					{
						A_Supports[1][3 + N + putting + Jig].Flag = 0;
					}

					for (k = 0; k < JigPartssu; k++)
					{
						Karinum = jig_parts[k].num;
						Karijignum = jig_parts[k].jignum;
						KariX = jig_parts[k].IchiX;
						KariY = jig_parts[k].IchiY;
						KariZ = jig_parts[k].IchiZ;

						jig_parts[k].num = jig_parts[k].IchiX = jig_parts[k].IchiY = jig_parts[k].IchiZ = 0;//一旦0にする

						if (kumijun[line].ko != Karinum)
						{
							jig_parts[f].num = Karinum;
							jig_parts[f].jignum = Karijignum;
							jig_parts[f].IchiX = KariX;
							jig_parts[f].IchiY = KariY;
							jig_parts[f].IchiZ = KariZ;
							f++;
						}
					}

					JigPartssu = f;

					break;
				}
			}

			for (i = 0; i < e; i++) {//子部品である中間製品を探して中心点の部品を決める
				if (A_Tyukantyusin[i].TyukanNum == kumijun[line].ko) {
					KoKousei = A_Tyukantyusin[i].Tyusin;
				}
			}

			for (i = 0; i < N; i++) {//部品属性から子部品である中間製品の中心点になる部品の情報を読み取る
				if (A_Buhin[i].Buhinnum == KoKousei) {
					Ko_X = A_Buhin[i].Tyusin_X;
					Ko_Y = A_Buhin[i].Tyusin_Y;
					Ko_Z = A_Buhin[i].Tyusin_Z;
				}
			}




			K_Sa_X = Ko_X - Oya_X;
			K_Sa_Y = Ko_Y - Oya_Y;
			K_Sa_Z = Ko_Z - Oya_Z;

			Sa_X = K_Sa_X;
			Sa_Y = K_Sa_Y;
			Sa_Z = K_Sa_Z;


			//回転を考える(回転行列を用いて計算)
			rotation_matrix_Coord(K_Sa_X, K_Sa_Y, K_Sa_Z);

			KIdo_X = Re_X + *OyaJigX;//絶対座標に変換
			KIdo_Y = Re_Y + *OyaJigY;
			KIdo_Z = Re_Z + *OyaJigZ;

		}
		else if (kumijun[line].ko <= N)
		{//子部品が単部品の時

			/*for (i = 0; i < N; i++) {//治具の組付け暫定的な位置
				if (A_Buhin[i].Buhinnum == JiguOya) {
					JiguZ = A_Buhin[i].Lengrh_Z / 2.0;
				}
			}*/
			for (i = 0; i < e; i++) {//親部品である中間製品を探して中心点の部品を決める
				if (A_Tyukantyusin[i].TyukanNum == JiguOya) {
					OyaKousei = A_Tyukantyusin[i].Tyusin;
				}
			}

			for (i = 0; i < N; i++) {//部品属性から親部品である中間製品の中心点になる部品の情報を読み取る
				if (A_Buhin[i].Buhinnum == OyaKousei) {
					Oya_X = A_Buhin[i].Tyusin_X;
					Oya_Y = A_Buhin[i].Tyusin_Y;
					Oya_Z = A_Buhin[i].Tyusin_Z;
					JiguZ = A_Buhin[i].Lengrh_Z / 2.0;
				}
			}
			for (j = 0; j < JigPartssu; j++)//親部品が治具についているかどうか調べる
			{
				if (jig_parts[j].num == kumijun[line].oya && jig_parts[j].jignum == Jig)//親部品が治具についているとき
				{
					Jigfix = j;
					Jigflag = 1;
					*OyaJigX = jig_parts[j].IchiX;
					*OyaJigY = jig_parts[j].IchiY;
					*OyaJigZ = jig_parts[j].IchiZ;
					break;
				}
				else if (jig_parts[j].num == kumijun[line].oya)//使用する治具にはついていないが、ほかの治具についているとき
				{
					*OyaJigX = A_Jigus[Jig].H_IchiX - A_Jigus[Jig].SizeX / 2;
					*OyaJigY = A_Jigus[Jig].H_IchiY - A_Jigus[Jig].SizeY / 2;
					*OyaJigZ = A_Jigus[Jig].H_IchiZ + JiguZ + A_Jigus[Jig].SizeZ / 2;
					Jigflag = 1;
					jig_parts[j].jignum = Jig;
					jig_parts[j].IchiX = *OyaJigX;
					jig_parts[j].IchiY = *OyaJigY;
					jig_parts[j].IchiZ = *OyaJigZ;
					break;
				}
			}

			if (Jigflag == 0)
			{
				*OyaJigX = A_Jigus[Jig].H_IchiX - A_Jigus[Jig].SizeX / 2;
				*OyaJigY = A_Jigus[Jig].H_IchiY - A_Jigus[Jig].SizeY / 2;
				*OyaJigZ = A_Jigus[Jig].H_IchiZ + JiguZ + A_Jigus[Jig].SizeZ / 2;

				jig_parts[JigPartssu].num = JiguOya;
				jig_parts[JigPartssu].jignum = Jig;
				jig_parts[JigPartssu].Id = A_Objects[0][3 * N + 2 + Jig + putting].Id;
				jig_parts[JigPartssu].IchiX = *OyaJigX;
				jig_parts[JigPartssu].IchiY = *OyaJigY;
				jig_parts[JigPartssu].IchiZ = *OyaJigZ;
				JigPartssu++;
			}

			for (i = 0; i < N; i++) {//部品属性から子部品の中心点を読み取る
				if (A_Buhin[i].Buhinnum == kumijun[line].ko) {
					Ko_X = A_Buhin[i].Tyusin_X;
					Ko_Y = A_Buhin[i].Tyusin_Y;
					Ko_Z = A_Buhin[i].Tyusin_Z;
				}
			}


			K_Sa_X = Ko_X - Oya_X;
			K_Sa_Y = Ko_Y - Oya_Y;
			K_Sa_Z = Ko_Z - Oya_Z;

			Sa_X = K_Sa_X;
			Sa_Y = K_Sa_Y;
			Sa_Z = K_Sa_Z;


			//回転を考える(回転行列を用いて計算)
			rotation_matrix_Coord(K_Sa_X, K_Sa_Y, K_Sa_Z);

			KIdo_X = Re_X + *OyaJigX;//絶対座標に変換
			KIdo_Y = Re_Y + *OyaJigY;
			KIdo_Z = Re_Z + *OyaJigZ;

		}

	}

	else if (JiguOya <= N) {//治具についてる部品が単部品の時

		if (kumijun[line].ko > N)
		{//子部品が中間製品の時

			for (j = 0; j < JigPartssu; j++)//子部品が治具についているかどうか調べる
			{
				if (jig_parts[j].num == kumijun[line].ko)//子部品が治具についているとき
				{
					//治具から子部品を外す
					for (supportlength = 0; supportlength < A_Supports[1][3 + N + putting + Jig].Length; supportlength++)
					{
						temp[supportlength] = 0;//配列の初期化
						temp[supportlength] = A_Supports[1][3 + N + putting + Jig].PId[supportlength];//値を移す
						A_Supports[1][3 + N + putting + Jig].PId[supportlength] = 0;//配列の初期化
					}
					templength = 0;
					templength = A_Supports[1][3 + N + putting + Jig].Length;
					A_Supports[1][3 + N + putting + Jig].Length = 0;//一旦0にする
					for (k = 0; k < templength; k++)
					{
						if (temp[k] != kumijun[line].ko)//一致する部品は治具から外す部品なので一致しない部品を入れ替える
						{
							A_Supports[1][3 + N + putting + Jig].PId[A_Supports[1][3 + N + putting + Jig].Length] = temp[k];
							A_Supports[1][3 + N + putting + Jig].Length++;
						}
					}
					if (A_Supports[1][3 + N + putting + Jig].Length == 0)
					{
						A_Supports[1][3 + N + putting + Jig].Flag = 0;
					}

					for (k = 0; k < JigPartssu; k++)
					{
						Karinum = jig_parts[k].num;
						KariX = jig_parts[k].IchiX;
						KariY = jig_parts[k].IchiY;
						KariZ = jig_parts[k].IchiZ;

						jig_parts[k].num = jig_parts[k].IchiX = jig_parts[k].IchiY = jig_parts[k].IchiZ = 0;//一旦0にする

						if (kumijun[line].ko != Karinum)
						{
							jig_parts[k].num = Karinum;
							jig_parts[k].IchiX = KariX;
							jig_parts[k].IchiY = KariY;
							jig_parts[k].IchiZ = KariZ;
							f++;
						}
					}

					JigPartssu = f;

					break;
				}
			}

			for (i = 0; i < e; i++) {//子部品である中間製品を探して中心点の部品を決める
				if (A_Tyukantyusin[i].TyukanNum == kumijun[line].ko) {
					KoKousei = A_Tyukantyusin[i].Tyusin;
				}
			}

			for (i = 0; i < N; i++) {//部品属性から子部品である中間製品の中心点になる部品の情報を読み取る
				if (A_Buhin[i].Buhinnum == KoKousei) {
					Ko_X = A_Buhin[i].Tyusin_X;
					Ko_Y = A_Buhin[i].Tyusin_Y;
					Ko_Z = A_Buhin[i].Tyusin_Z;
				}
			}

			for (i = 0; i < N; i++) {//部品属性から親部品の中心点を読み取る
				if (A_Buhin[i].Buhinnum == JiguOya) {
					Oya_X = A_Buhin[i].Tyusin_X;
					Oya_Y = A_Buhin[i].Tyusin_Y;
					Oya_Z = A_Buhin[i].Tyusin_Z;
				}
			}


			K_Sa_X = Ko_X - Oya_X;
			K_Sa_Y = Ko_Y - Oya_Y;
			K_Sa_Z = Ko_Z - Oya_Z;

			Sa_X = K_Sa_X;
			Sa_Y = K_Sa_Y;
			Sa_Z = K_Sa_Z;

			//回転を考える(回転行列を用いて計算)
			rotation_matrix_Coord(K_Sa_X, K_Sa_Y, K_Sa_Z);

			for (i = 0; i < N; i++) {//治具の組付け暫定的な位置
				if (A_Buhin[i].Buhinnum == JiguOya) {
					JiguZ = A_Buhin[i].Lengrh_Z / 2.0;
				}
			}

			//親部品の位置を治具の位置にする
			*OyaJigX = A_Jigus[Jig].H_IchiX - A_Jigus[Jig].SizeX / 2;
			*OyaJigY = A_Jigus[Jig].H_IchiY - A_Jigus[Jig].SizeY / 2;
			*OyaJigZ = A_Jigus[Jig].H_IchiZ + JiguZ + A_Jigus[Jig].SizeZ / 2;

			jig_parts[JigPartssu].num = JiguOya;
			jig_parts[JigPartssu].jignum = Jig;
			jig_parts[JigPartssu].Id = A_Objects[0][3 * N + 2 + Jig + putting].Id;
			jig_parts[JigPartssu].IchiX = *OyaJigX;
			jig_parts[JigPartssu].IchiY = *OyaJigY;
			jig_parts[JigPartssu].IchiZ = *OyaJigZ;
			JigPartssu++;

			KIdo_X = Re_X + *OyaJigX;//絶対座標に変換
			KIdo_Y = Re_Y + *OyaJigY;
			KIdo_Z = Re_Z + *OyaJigZ;

		}
		else if (kumijun[line].ko <= N) {//子部品が単部品の時
			//治具が親部品の位置なので、組付く子部品は治具の座標と親部品(部品属性における)の座標の差分から子部品の組付く位置を算出

			for (i = 0; i < N; i++) {//子部品と親部品の組付いた時の位置を読み込む
				if (A_Buhin[i].Buhinnum == kumijun[line].ko) {
					Ko_X = A_Buhin[i].Tyusin_X;
					Ko_Y = A_Buhin[i].Tyusin_Y;
					Ko_Z = A_Buhin[i].Tyusin_Z;
				}
				if (A_Buhin[i].Buhinnum == JiguOya) {
					Oya_X = A_Buhin[i].Tyusin_X;
					Oya_Y = A_Buhin[i].Tyusin_Y;
					Oya_Z = A_Buhin[i].Tyusin_Z;
				}
			}

			K_Sa_X = Ko_X - Oya_X;
			K_Sa_Y = Ko_Y - Oya_Y;
			K_Sa_Z = Ko_Z - Oya_Z;

			Sa_X = K_Sa_X;
			Sa_Y = K_Sa_Y;
			Sa_Z = K_Sa_Z;


			//回転を考える(回転行列を用いて計算)
			rotation_matrix_Coord(K_Sa_X, K_Sa_Y, K_Sa_Z);

			for (i = 0; i < N; i++) {//治具の組付け暫定的な位置
				if (A_Buhin[i].Buhinnum == JiguOya) {
					JiguZ = A_Buhin[i].Lengrh_Z / 2.0;
				}
			}

			//親部品の位置を治具の位置にする
			*OyaJigX = A_Jigus[Jig].H_IchiX - A_Jigus[Jig].SizeX / 2;
			*OyaJigY = A_Jigus[Jig].H_IchiY - A_Jigus[Jig].SizeY / 2;
			*OyaJigZ = A_Jigus[Jig].H_IchiZ + JiguZ + A_Jigus[Jig].SizeZ / 2;

			jig_parts[JigPartssu].num = JiguOya;
			jig_parts[JigPartssu].jignum = Jig;
			jig_parts[JigPartssu].Id = A_Objects[0][3 * N + 2 + Jig + putting].Id;
			jig_parts[JigPartssu].IchiX = *OyaJigX;
			jig_parts[JigPartssu].IchiY = *OyaJigY;
			jig_parts[JigPartssu].IchiZ = *OyaJigZ;
			JigPartssu++;


			KIdo_X = Re_X + *OyaJigX;//絶対座標に変換
			KIdo_Y = Re_Y + *OyaJigY;
			KIdo_Z = Re_Z + *OyaJigZ;

		}

	}
}

void rotation_matrix_Coord(double X, double Y, double Z)
{
	double X_rotation[3][3], Y_rotation[3][3], Z_rotation[3][3];
	double turnedX[3], turnedXY[3], turnedXYZ[3], cood[3];
	double pi = 0, temp = 0;
	int i = 0, j = 0, k = 0;

	cood[0] = X;
	cood[1] = Y;
	cood[2] = Z;

	//X軸周りの回転
	X_rotation[0][0] = 1;
	X_rotation[0][1] = X_rotation[0][2] = X_rotation[1][0] = X_rotation[2][0] = 0;
	X_rotation[1][1] = X_rotation[2][2] = cos(A_Objects[1][KoPnum].DirX * PI / 180);
	X_rotation[1][2] = -sin(A_Objects[1][KoPnum].DirX * PI / 180);
	X_rotation[2][1] = sin(A_Objects[1][KoPnum].DirX * PI / 180);

	//Y軸周りの回転
	Y_rotation[0][0] = Y_rotation[2][2] = cos(A_Objects[1][KoPnum].DirY * PI / 180);
	Y_rotation[0][1] = Y_rotation[1][0] = Y_rotation[1][2] = Y_rotation[2][1] = 0;
	Y_rotation[1][1] = 1;
	Y_rotation[0][2] = sin(A_Objects[1][KoPnum].DirY * PI / 180);
	Y_rotation[2][0] = -sin(A_Objects[1][KoPnum].DirY * PI / 180);

	//Z軸周りの回転
	Z_rotation[0][0] = Z_rotation[1][1] = cos(A_Objects[1][KoPnum].DirZ * PI / 180);
	Z_rotation[0][1] = -sin(A_Objects[1][KoPnum].DirZ * PI / 180);
	Z_rotation[0][2] = Z_rotation[1][2] = Z_rotation[2][0] = Z_rotation[2][1] = 0;
	Z_rotation[1][0] = sin(A_Objects[1][KoPnum].DirZ * PI / 180);
	Z_rotation[2][2] = 1;

	//X軸との掛け合わせ
	for (i = 0; i < 3; i++)
	{
		for (j = 0; j < 3; j++)
		{
			temp += X_rotation[i][j] * cood[j];
		}
		turnedX[i] = temp;
		temp = 0;
	}

	//Y軸の掛け合わせ
	for (i = 0; i < 3; i++)
	{
		for (j = 0; j < 3; j++)
		{
			temp += Y_rotation[i][j] * turnedX[j];
		}
		turnedXY[i] = temp;
		temp = 0;
	}

	//Z軸の掛け合わせ
	for (i = 0; i < 3; i++)
	{
		for (j = 0; j < 3; j++)
		{
			temp += Z_rotation[i][j] * turnedXY[j];
		}
		turnedXYZ[i] = temp;
		temp = 0;
	}


	Re_X = turnedXYZ[0];
	Re_Y = turnedXYZ[1];
	Re_Z = turnedXYZ[2];

}

void KP4MaikingOffset(int KoBuhin) {
	int i, q = 0, o = 0;//pは部品1でなかったかあったかを見分ける
	int OyaKousei, KoKousei;//中間製品の構成部品(親部品),中間製品の構成部品(子部品)
	double Ko_X = 0, Ko_Y = 0, Ko_Z = 0, Oya_X = 0, Oya_Y = 0, Oya_Z = 0, Sa_X, Sa_Y, Sa_Z;//子部品の中心、親部品の中心、その差
	double K_Sa_X, K_Sa_Y, K_Sa_Z;//計算用の差
	double X_Max = 0, X_Min = 0, Y_Max = 0, Y_Min = 0, Z_Max = 0, Z_Min = 0;//中間製品の中心座標を計算するのに用いる
	double rad;//ラジアンに変換
	double JiguZ = 0;
	int JiguOya;

	JiguOya = A_Supports[1][2 + N + 1 + putting].PId;

	if (JiguOya > N) {//治具についてる部品が中間製品の時
		if (KoBuhin > N) {//子部品が中間製品の時


			for (i = 0; i < e; i++) {//親部品である中間製品を探して中心点の部品を決める
				if (A_Tyukantyusin[i].TyukanNum == JiguOya) {
					OyaKousei = A_Tyukantyusin[i].Tyusin;
				}
			}

			for (i = 0; i < N; i++) {//部品属性から親部品である中間製品の中心点になる部品の情報を読み取る
				if (A_Buhin[i].Buhinnum == OyaKousei) {
					Oya_X = A_Buhin[i].Tyusin_X;
					Oya_Y = A_Buhin[i].Tyusin_Y;
					Oya_Z = A_Buhin[i].Tyusin_Z;
					JiguZ = A_Buhin[i].Lengrh_Z / 2.0;
				}
			}



			for (i = 0; i < e; i++) {//子部品である中間製品を探して中心点の部品を決める
				if (A_Tyukantyusin[i].TyukanNum == KoBuhin) {
					KoKousei = A_Tyukantyusin[i].Tyusin;
				}
			}

			for (i = 0; i < N; i++) {//部品属性から子部品である中間製品の中心点になる部品の情報を読み取る
				if (A_Buhin[i].Buhinnum == KoKousei) {
					Ko_X = A_Buhin[i].Tyusin_X;
					Ko_Y = A_Buhin[i].Tyusin_Y;
					Ko_Z = A_Buhin[i].Tyusin_Z;
				}
			}




			K_Sa_X = Ko_X - Oya_X;
			K_Sa_Y = Ko_Y - Oya_Y;
			K_Sa_Z = Ko_Z - Oya_Z;

			Sa_X = K_Sa_X;
			Sa_Y = K_Sa_Y;
			Sa_Z = K_Sa_Z;


			//回転を考える(回転行列を用いて計算)
			if (A_Objects[1][KoPnum].DirX != 0) {//X軸上に回転する場合
				rad = A_Objects[1][KoPnum].DirX * PI / 180.0;
				Sa_X = K_Sa_X;
				Sa_Y = (K_Sa_Y * cos(rad) - K_Sa_Z * sin(rad));
				Sa_Z = (K_Sa_Y * sin(rad) + K_Sa_Z * cos(rad));
			}

			if (A_Objects[1][KoPnum].DirY != 0) {//Y軸上に回転する場合
				rad = (A_Objects[1][KoPnum].DirY / 180.0 * PI);
				Sa_X = (K_Sa_X * cos(rad) + K_Sa_Z * sin(rad));
				Sa_Y = K_Sa_Y;
				Sa_Z = (-K_Sa_X * sin(rad) + K_Sa_Z * cos(rad));
			}

			if (A_Objects[1][KoPnum].DirZ != 0) {//Z軸上に回転する場合
				rad = (A_Objects[1][KoPnum].DirZ / 180.0 * PI);
				Sa_X = (K_Sa_X * cos(rad) - K_Sa_Y * sin(rad));
				Sa_Z = (K_Sa_X * sin(rad) + K_Sa_Y * cos(rad));
				Sa_Z = K_Sa_Z;
			}

			for (i = 0; i < N; i++) {//治具の組付け暫定的な位置
				if (A_Buhin[i].Buhinnum == JiguOya) {
					JiguZ = A_Buhin[i].Lengrh_Z / 2.0;
				}
			}



			KKIdo_X = Sa_X + A_Jigus[0].H_IchiX - A_Jigus[0].SizeX / 2;//絶対座標に変換
			KKIdo_Y = Sa_Y + A_Jigus[0].H_IchiY - A_Jigus[0].SizeY / 2;
			KKIdo_Z = Sa_Z + A_Jigus[0].H_IchiZ + JiguZ + A_Jigus[0].SizeZ / 2;



		}
		else if (KoBuhin <= N) {//子部品が単部品の時


			for (i = 0; i < e; i++) {//親部品である中間製品を探して中心点の部品を決める
				if (A_Tyukantyusin[i].TyukanNum == JiguOya) {
					OyaKousei = A_Tyukantyusin[i].Tyusin;
				}
			}

			for (i = 0; i < N; i++) {//部品属性から親部品である中間製品の中心点になる部品の情報を読み取る
				if (A_Buhin[i].Buhinnum == OyaKousei) {
					Oya_X = A_Buhin[i].Tyusin_X;
					Oya_Y = A_Buhin[i].Tyusin_Y;
					Oya_Z = A_Buhin[i].Tyusin_Z;
					JiguZ = A_Buhin[i].Lengrh_Z / 2.0;
				}
			}

			for (i = 0; i < N; i++) {//部品属性から子部品の中心点を読み取る
				if (A_Buhin[i].Buhinnum == KoBuhin) {
					Ko_X = A_Buhin[i].Tyusin_X;
					Ko_Y = A_Buhin[i].Tyusin_Y;
					Ko_Z = A_Buhin[i].Tyusin_Z;
				}
			}


			K_Sa_X = Ko_X - Oya_X;
			K_Sa_Y = Ko_Y - Oya_Y;
			K_Sa_Z = Ko_Z - Oya_Z;

			Sa_X = K_Sa_X;
			Sa_Y = K_Sa_Y;
			Sa_Z = K_Sa_Z;


			//回転を考える(回転行列を用いて計算)
			if (A_Objects[1][KoPnum].DirX != 0) {//X軸上に回転する場合
				rad = A_Objects[1][KoPnum].DirX * PI / 180.0;
				Sa_X = K_Sa_X;
				Sa_Y = (K_Sa_Y * cos(rad) - K_Sa_Z * sin(rad));
				Sa_Z = (K_Sa_Y * sin(rad) + K_Sa_Z * cos(rad));

			}

			if (A_Objects[1][KoPnum].DirY != 0) {//Y軸上に回転する場合
				rad = (A_Objects[1][KoPnum].DirY / 180.0 * PI);
				Sa_X = (K_Sa_X * cos(rad) + K_Sa_Z * sin(rad));
				Sa_Y = K_Sa_Y;
				Sa_Z = (-K_Sa_X * sin(rad) + K_Sa_Z * cos(rad));
			}

			if (A_Objects[1][KoPnum].DirZ != 0) {//Z軸上に回転する場合
				rad = (A_Objects[1][KoPnum].DirZ / 180.0 * PI);
				Sa_X = (K_Sa_X * cos(rad) - K_Sa_Y * sin(rad));
				Sa_Z = (K_Sa_X * sin(rad) + K_Sa_Y * cos(rad));
				Sa_Z = K_Sa_Z;
			}

			for (i = 0; i < N; i++) {//治具の組付け暫定的な位置
				if (A_Buhin[i].Buhinnum == JiguOya) {
					JiguZ = A_Buhin[i].Lengrh_Z / 2.0;
				}
			}

			KKIdo_X = Sa_X + A_Jigus[0].H_IchiX - A_Jigus[0].SizeX / 2;//絶対座標に変換
			KKIdo_Y = Sa_Y + A_Jigus[0].H_IchiY - A_Jigus[0].SizeY / 2;
			KKIdo_Z = Sa_Z + A_Jigus[0].H_IchiZ + JiguZ + A_Jigus[0].SizeZ / 2;

		}

	}

	else if (JiguOya <= N) {//治具についてる部品が単部品の時

		if (KoBuhin > N) {//子部品が中間製品の時



			for (i = 0; i < e; i++) {//子部品である中間製品を探して中心点の部品を決める
				if (A_Tyukantyusin[i].TyukanNum == KoBuhin) {
					KoKousei = A_Tyukantyusin[i].Tyusin;
				}
			}

			for (i = 0; i < N; i++) {//部品属性から子部品である中間製品の中心点になる部品の情報を読み取る
				if (A_Buhin[i].Buhinnum == KoKousei) {
					Ko_X = A_Buhin[i].Tyusin_X;
					Ko_Y = A_Buhin[i].Tyusin_Y;
					Ko_Z = A_Buhin[i].Tyusin_Z;
				}
			}

			for (i = 0; i < N; i++) {//部品属性から親部品の中心点を読み取る
				if (A_Buhin[i].Buhinnum == JiguOya) {
					Oya_X = A_Buhin[i].Tyusin_X;
					Oya_Y = A_Buhin[i].Tyusin_Y;
					Oya_Z = A_Buhin[i].Tyusin_Z;
				}
			}


			K_Sa_X = Ko_X - Oya_X;
			K_Sa_Y = Ko_Y - Oya_Y;
			K_Sa_Z = Ko_Z - Oya_Z;

			Sa_X = K_Sa_X;
			Sa_Y = K_Sa_Y;
			Sa_Z = K_Sa_Z;

			//回転を考える(回転行列を用いて計算)
			if (A_Objects[1][KoPnum].DirX != 0) {//X軸上に回転する場合
				rad = A_Objects[1][KoPnum].DirX * PI / 180.0;
				Sa_X = K_Sa_X;
				Sa_Y = (K_Sa_Y * cos(rad) - K_Sa_Z * sin(rad));
				Sa_Z = (K_Sa_Y * sin(rad) + K_Sa_Z * cos(rad));

			}

			if (A_Objects[1][KoPnum].DirY != 0) {//Y軸上に回転する場合
				rad = (A_Objects[1][KoPnum].DirY / 180.0 * PI);
				Sa_X = (K_Sa_X * cos(rad) + K_Sa_Z * sin(rad));
				Sa_Y = K_Sa_Y;
				Sa_Z = (-K_Sa_X * sin(rad) + K_Sa_Z * cos(rad));
			}

			if (A_Objects[1][KoPnum].DirZ != 0) {//Z軸上に回転する場合
				rad = (A_Objects[1][KoPnum].DirZ / 180.0 * PI);
				Sa_X = (K_Sa_X * cos(rad) - K_Sa_Y * sin(rad));
				Sa_Z = (K_Sa_X * sin(rad) + K_Sa_Y * cos(rad));
				Sa_Z = K_Sa_Z;
			}

			for (i = 0; i < N; i++) {//治具の組付け暫定的な位置
				if (A_Buhin[i].Buhinnum == JiguOya) {
					JiguZ = A_Buhin[i].Lengrh_Z / 2.0;
				}
			}

			KKIdo_X = Sa_X + A_Jigus[0].H_IchiX - A_Jigus[0].SizeX / 2;//絶対座標に変換
			KKIdo_Y = Sa_Y + A_Jigus[0].H_IchiY - A_Jigus[0].SizeY / 2;
			KKIdo_Z = Sa_Z + A_Jigus[0].H_IchiZ + JiguZ + A_Jigus[0].SizeZ / 2;

		}
		else if (KoBuhin <= N) {//子部品が単部品の時
			//治具が親部品の位置なので、組付く子部品は治具の座標と親部品(部品属性における)の座標の差分から子部品の組付く位置を算出

			for (i = 0; i < N; i++) {//子部品と親部品の組付いた時の位置を読み込む
				if (A_Buhin[i].Buhinnum == KoBuhin) {
					Ko_X = A_Buhin[i].Tyusin_X;
					Ko_Y = A_Buhin[i].Tyusin_Y;
					Ko_Z = A_Buhin[i].Tyusin_Z;
				}
				if (A_Buhin[i].Buhinnum == JiguOya) {
					Oya_X = A_Buhin[i].Tyusin_X;
					Oya_Y = A_Buhin[i].Tyusin_Y;
					Oya_Z = A_Buhin[i].Tyusin_Z;
				}
			}

			K_Sa_X = Ko_X - Oya_X;
			K_Sa_Y = Ko_Y - Oya_Y;
			K_Sa_Z = Ko_Z - Oya_Z;

			Sa_X = K_Sa_X;
			Sa_Y = K_Sa_Y;
			Sa_Z = K_Sa_Z;


			//回転を考える(回転行列を用いて計算)
			if (A_Objects[1][KoPnum].DirX != 0) {//X軸上に回転する場合
				rad = A_Objects[1][KoPnum].DirX * PI / 180.0;
				Sa_X = K_Sa_X;
				Sa_Y = (K_Sa_Y * cos(rad) - K_Sa_Z * sin(rad));
				Sa_Z = (K_Sa_Y * sin(rad) + K_Sa_Z * cos(rad));
			}

			if (A_Objects[1][KoPnum].DirY != 0) {//Y軸上に回転する場合
				rad = (A_Objects[1][KoPnum].DirY / 180.0 * PI);
				Sa_X = (K_Sa_X * cos(rad) + K_Sa_Z * sin(rad));
				Sa_Y = K_Sa_Y;
				Sa_Z = (-K_Sa_X * sin(rad) + K_Sa_Z * cos(rad));
			}

			if (A_Objects[1][KoPnum].DirZ != 0) {//Z軸上に回転する場合
				rad = (A_Objects[1][KoPnum].DirZ / 180.0 * PI);
				Sa_X = (K_Sa_X * cos(rad) - K_Sa_Y * sin(rad));
				Sa_Z = (K_Sa_X * sin(rad) + K_Sa_Y * cos(rad));
				Sa_Z = K_Sa_Z;
			}

			for (i = 0; i < N; i++) {//治具の組付け暫定的な位置
				if (A_Buhin[i].Buhinnum == JiguOya) {
					JiguZ = A_Buhin[i].Lengrh_Z / 2.0;
				}
			}




			KKIdo_X = Sa_X + A_Jigus[0].H_IchiX - A_Jigus[0].SizeX / 2;//絶対座標に変換
			KKIdo_Y = Sa_Y + A_Jigus[0].H_IchiY - A_Jigus[0].SizeY / 2;
			KKIdo_Z = Sa_Z + A_Jigus[0].H_IchiZ + JiguZ + A_Jigus[0].SizeZ / 2;

		}

	}
}

void Turn(FILE* fp2, int OyaP, double Turn0X, double Turn0Y, double Turn0Z, double Turn1X, double Turn1Y, double Turn1Z, int Te) {//回転する(持ち直す)
	fprintf(fp2, "F,%d,%d,%d,%d,%.3lf\n", Num, ZNum, HighNum, Flg, Time);
	Skakudo = fabs(Turn0X - Turn1X) + Skakudo;
	Skakudo = fabs(Turn0Y - Turn1Y) + Skakudo;
	Skakudo = fabs(Turn0Z - Turn1Z) + Skakudo;
	
	//古屋変更後
	//部品番号が完成品の部品番号より大きい場合
	printf("部品番号%d,完成品番号%d\n", OyaP, N);
	if (OyaP > N+1) 
	{
		TurnNum++;
		Kaitenkaisu++;
		HNum++;
	}

	Num++;
	STime = STime + Time;

	//古屋変更前
	/*TurnNum++;*/
	//Kaitenkaisu++;
	//Num++;
	//HNum++;
	//STime = STime + Time;
	fprintf(fp2, "%.3lf,%.3lf,%d,%.3lf\n", SKyori, Skakudo, TurnNum, STime);
	if (Te == 0) {
		fprintf(fp2, "持ち直す %d を 右手 で X から Y へ\n", OyaP);
	}
	else {
		fprintf(fp2, "持ち直す %d を 左手 で X から Y へ\n", OyaP);
	}
	fprintf(fp2, "X,%.1lf,%.1lf,%.1lf\n", Turn0X, Turn0Y, Turn0Z);
	fprintf(fp2, "Y,%.1lf,%.1lf,%.1lf\n\n", Turn1X, Turn1Y, Turn1Z);
	//printf("3\n");
}

void Fix(FILE* fp2, int Jigugu, int OyaP, int Te) {//治具に付ける
	fprintf(fp2, "F,%d,%d,%d,%d,%.3lf\n", Num, ZNum, HighNum, Flg, Time);
	Num++;
	HNum++;
	STime = STime + Time;
	fprintf(fp2, "%.3lf,%.3lf,%d,%.3lf\n", SKyori, Skakudo, TurnNum, STime);
	if (Te == 0) {
		fprintf(fp2, "付ける %d を %d に 右手 で\n\n", OyaP, Jigugu);
	}
	else {
		fprintf(fp2, "付ける %d を %d に 左手 で\n\n", OyaP, Jigugu);
	}
	//printf("6\n");

}

void Release(FILE* fp2, int OyaP, int Te) {//放す
	fprintf(fp2, "F,%d,%d,%d,%d,%.3lf\n", Num, ZNum, HighNum, Flg, Time);
	Num++;
	HNum++;
	STime = STime + Time;
	fprintf(fp2, "%.3lf,%.3lf,%d,%.3lf\n", SKyori, Skakudo, TurnNum, STime);
	if (Te == 0) {
		fprintf(fp2, "放す %d を 右手 で 7 により\n\n", OyaP);
	}
	else {
		fprintf(fp2, "放す %d を 左手 で 7 により\n\n", OyaP);
	}
	//printf("7\n");
}

void Reach(FILE* fp2, double IchiX1, double IchiY1, double IchiZ1, double IchiX2, double IchiY2, double IchiZ2, int Te) {//伸ばす
	fprintf(fp2, "F,%d,%d,%d,%d,%.3lf\n", Num, ZNum, HighNum, Flg, Time);
	Num++;
	HNum++;
	STime = STime + Time;
	Kyori = sqrt((IchiX1 - IchiX2) * (IchiX1 - IchiX2) + (IchiY1 - IchiY2) * (IchiY1 - IchiY2) + (IchiZ1 - IchiZ2) * (IchiZ1 - IchiZ2));
	SKyori = SKyori + Kyori;
	fprintf(fp2, "%.3lf,%.3lf,%d,%.3lf\n", SKyori, Skakudo, TurnNum, STime);
	if (Te == 0) {
		fprintf(fp2, "伸ばす 右手 を A から B へ\n");
		MKyori = MKyori + sqrt((IchiX1 - IchiX2) * (IchiX1 - IchiX2) + (IchiY1 - IchiY2) * (IchiY1 - IchiY2) + (IchiZ1 - IchiZ2) * (IchiZ1 - IchiZ2));
	}
	else {
		fprintf(fp2, "伸ばす 左手 を A から B へ\n");
		HKyori = HKyori + sqrt((IchiX1 - IchiX2) * (IchiX1 - IchiX2) + (IchiY1 - IchiY2) * (IchiY1 - IchiY2) + (IchiZ1 - IchiZ2) * (IchiZ1 - IchiZ2));
	}
	fprintf(fp2, "A,%.1lf,%.1lf,%.1lf\n", IchiX1, IchiY1, IchiZ1);
	fprintf(fp2, "B,%.1lf,%.1lf,%.1lf\n\n", IchiX2, IchiY2, IchiZ2);
	//printf("8\n");
}

void Kumimove(FILE* fp2, double IchiX1, double IchiY1, double IchiZ1, double IchiX2, double IchiY2, double IchiZ2, int Te) {//組立移動
	fprintf(fp2, "F,%d,%d,%d,%d,%.3lf\n", Num, ZNum, HighNum, Flg, Time);
	Num++;
	HNum++;
	STime = STime + Time;
	Kyori = sqrt((IchiX1 - IchiX2) * (IchiX1 - IchiX2) + (IchiY1 - IchiY2) * (IchiY1 - IchiY2) + (IchiZ1 - IchiZ2) * (IchiZ1 - IchiZ2));
	SKyori = SKyori + Kyori;
	fprintf(fp2, "%.3lf,%.3lf,%d,%.3lf\n", SKyori, Skakudo, TurnNum, STime);
	if (Te == 0) {
		fprintf(fp2, "組立移動する 右手 で APP から OFFSET へ\n");
		MKyori = MKyori + sqrt((IchiX1 - IchiX2) * (IchiX1 - IchiX2) + (IchiY1 - IchiY2) * (IchiY1 - IchiY2) + (IchiZ1 - IchiZ2) * (IchiZ1 - IchiZ2));
	}
	else {
		fprintf(fp2, "組立移動する 左手 で APP から OFFSET へ\n");
		HKyori = HKyori + sqrt((IchiX1 - IchiX2) * (IchiX1 - IchiX2) + (IchiY1 - IchiY2) * (IchiY1 - IchiY2) + (IchiZ1 - IchiZ2) * (IchiZ1 - IchiZ2));
	}
	fprintf(fp2, "APP,%.1lf,%.1lf,%.1lf\n", IchiX1, IchiY1, IchiZ1);
	fprintf(fp2, "OFFSET,%.1lf,%.1lf,%.1lf\n\n", IchiX2, IchiY2, IchiZ2);
	//printf("0\n");
}

void Kumitate(FILE* fp2, int Jigugu, int Tyuka, int OyaP, int KoP, int Te) {//組立
	int f;
	fprintf(fp2, "F,%d,%d,%d,%d,%.3lf\n", Num, ZNum, HighNum, Flg, Time);
	Num++;
	HNum++;
	STime = STime + Time;
	fprintf(fp2, "%.3lf,%.3lf,%d,%.3lf\n", SKyori, Skakudo, TurnNum, STime);


	/*if (e == 0) {//中間製品の中心点になる部品を記録します
		A_Tyukantyusin[e].TyukanNum = Tyuka;
		A_Tyukantyusin[e].Tyusin = OyaP;
	}
	else {
		if (OyaP <= N) {
			A_Tyukantyusin[e].TyukanNum = Tyuka;
			A_Tyukantyusin[e].Tyusin = OyaP;
		}
		else {
			A_Tyukantyusin[e].TyukanNum = Tyuka;
			for (f = 0; f < e; f++) {
				if (OyaP == A_Tyukantyusin[f].TyukanNum) {
					A_Tyukantyusin[e].Tyusin = A_Tyukantyusin[f].Tyusin;
				}
			}
		}
	}
	e++;
	*/

	if (kumijun[a].scene_type != tegumi)//治具で組立てを行っている時
	{
		if (Te == migite) {
			fprintf(fp2, "組立てる %d の %d と 右手 の %d を %d,右手 で 右手,%d の %d にする\n\n", Jigugu, OyaP, KoP, Jigugu, Jigugu, Tyuka);

		}
		else if (Te == hidarite) {
			fprintf(fp2, "組立てる %d の %d と 左手 の %d を %d,左手 で 左手,%d の %d にする\n\n", Jigugu, OyaP, KoP, Jigugu, Jigugu, Tyuka);
		}
	}
	else//手組みの時
	{
		if (Te == hidarite) {
			fprintf(fp2, "組立てる 右手 の %d と 左手 の %d を 右手＿左手 で 右手,左手 の %d にする\n\n", OyaP, KoP, Tyuka);

		}
		else if (Te == migite) {
			fprintf(fp2, "組立てる 左手 の %d と 右手 の %d を 右手＿左手 で 左手,右手 の %d にする\n\n", OyaP, KoP, Tyuka);
		}
	}
	//printf("1\n");
}

void Grip(FILE* fp2, int KoP, int BeforeJig, int Te) {//掴み取る
	fprintf(fp2, "F,%d,%d,%d,%d,%.3lf\n", Num, ZNum, HighNum, Flg, Time);
	Num++;
	HNum++;
	STime = STime + Time;
	fprintf(fp2, "%.3lf,%.3lf,%d,%.3lf\n", SKyori, Skakudo, TurnNum, STime);
	if (Te == 0) {
		if (BeforeJig == 0)
		{
			fprintf(fp2, "掴み取る %d を 部品置き場1 から 右手 で 4 により\n\n", KoP);
		}
		else
		{
			fprintf(fp2, "掴み取る %d を %d から 右手 で 4 により\n\n", KoP, BeforeJig);
		}
	}
	else {
		if (BeforeJig == 0)
		{
			fprintf(fp2, "掴み取る %d を 部品置き場1 から 左手 で 4 により\n\n", KoP);
		}
		else
		{
			fprintf(fp2, "掴み取る %d を %d から 左手 で 4 により\n\n", KoP, BeforeJig);
		}
	}
	//printf("9\n");
}

void Carry(FILE* fp2, double IchiX1, double IchiY1, double IchiZ1, double IchiX2, double IchiY2, double IchiZ2, int Te) {//運ぶ
	fprintf(fp2, "F,%d,%d,%d,%d,%.3lf\n", Num, ZNum, HighNum, Flg, Time);
	Num++;
	HNum++;
	STime = STime + Time;
	Kyori = sqrt((IchiX1 - IchiX2) * (IchiX1 - IchiX2) + (IchiY1 - IchiY2) * (IchiY1 - IchiY2) + (IchiZ1 - IchiZ2) * (IchiZ1 - IchiZ2));
	SKyori = SKyori + Kyori;
	fprintf(fp2, "%.3lf,%.3lf,%d,%.3lf\n", SKyori, Skakudo, TurnNum, STime);
	if (Te == 0) {
		fprintf(fp2, "運ぶ 右手 で A から B へ\n");
		MKyori = MKyori + sqrt((IchiX1 - IchiX2) * (IchiX1 - IchiX2) + (IchiY1 - IchiY2) * (IchiY1 - IchiY2) + (IchiZ1 - IchiZ2) * (IchiZ1 - IchiZ2));
	}
	else {
		fprintf(fp2, "運ぶ 左手 で A から B へ\n");
		HKyori = HKyori + sqrt((IchiX1 - IchiX2) * (IchiX1 - IchiX2) + (IchiY1 - IchiY2) * (IchiY1 - IchiY2) + (IchiZ1 - IchiZ2) * (IchiZ1 - IchiZ2));
	}
	fprintf(fp2, "A,%.1lf,%.1lf,%.1lf\n", IchiX1, IchiY1, IchiZ1);
	fprintf(fp2, "B,%.1lf,%.1lf,%.1lf\n\n", IchiX2, IchiY2, IchiZ2);
	//printf("10\n");
}

void leave(FILE* fp2, int OyaP, int Te) {//置き放す
	fprintf(fp2, "F,%d,%d,%d,%d,%.3lf\n", Num, ZNum, HighNum, Flg, Time);
	Num++;
	HNum++;
	STime = STime + Time;
	fprintf(fp2, "%.3lf,%.3lf,%d,%.3lf\n", SKyori, Skakudo, TurnNum, STime);
	if (Te == 0) {
		fprintf(fp2, "置き放す %d を 工具置き場-20 に 右手 で 7 により\n\n", OyaP);
	}
	else {
		fprintf(fp2, "置き放す %d を 工具置き場-20 に 左手 で 7 により\n\n", OyaP);
	}
	//printf("11\n");
}

void Gripping(FILE* fp2, int OyaP, int Te) {//掴む
	fprintf(fp2, "F,%d,%d,%d,%d,%.3lf\n", Num, ZNum, HighNum, Flg, Time);
	Num++;
	HNum++;
	STime = STime + Time;
	fprintf(fp2, "%.3lf,%.3lf,%d,%.3lf\n", SKyori, Skakudo, TurnNum, STime);
	if (Te == 0) {
		fprintf(fp2, "掴む %d を 右手 で 4 により\n\n", OyaP);
	}
	else {
		fprintf(fp2, "掴む %d を 左手 で 4 により\n\n", OyaP);
	}
}

void Remove(FILE* fp2, int Jigugu, int OyaP, int Te) {//治具から外す
	fprintf(fp2, "F,%d,%d,%d,%d,%.3lf\n", Num, ZNum, HighNum, Flg, Time);
	Num++;
	HNum++;
	STime = STime + Time;
	fprintf(fp2, "%.3lf,%.3lf,%d,%.3lf\n", SKyori, Skakudo, TurnNum, STime);
	if (Te == 0) {
		fprintf(fp2, "外す %d を %d から 右手 で\n\n", OyaP, Jigugu);
	}
	else {
		fprintf(fp2, "外す %d を %d から 左手 で\n\n", OyaP, Jigugu);
	}
	//printf("2\n");
}

void WReach(FILE* fp2, double LIchiX1, double LIchiY1, double LIchiZ1, double LIchiX2, double LIchiY2, double LIchiZ2, double RIchiX1, double RIchiY1, double RIchiZ1, double RIchiX2, double RIchiY2, double RIchiZ2) {//両手同時に伸ばす


	ZNum = 2;
	fprintf(fp2, "F,%d,%d,%d,%d,%.3lf,%.3lf\n", Num, ZNum, HighNum, Flg, Time, Time);
	Num++;
	HNum++;
	STime = STime + Time;
	Kyori = sqrt((RIchiX1 - RIchiX2) * (RIchiX1 - RIchiX2) + (RIchiY1 - RIchiY2) * (RIchiY1 - RIchiY2) + (RIchiZ1 - RIchiZ2) * (RIchiZ1 - RIchiZ2)) + sqrt((LIchiX1 - LIchiX2) * (LIchiX1 - LIchiX2) + (LIchiY1 - LIchiY2) * (LIchiY1 - LIchiY2) + (LIchiZ1 - LIchiZ2) * (LIchiZ1 - LIchiZ2));
	SKyori = SKyori + Kyori;
	fprintf(fp2, "%.3lf,%.3lf,%d,%.3lf\n", SKyori, Skakudo, TurnNum, STime);

	fprintf(fp2, "伸ばす 右手 を A から B へ\n");
	MKyori = MKyori + sqrt((RIchiX1 - RIchiX2) * (RIchiX1 - RIchiX2) + (RIchiY1 - RIchiY2) * (RIchiY1 - RIchiY2) + (RIchiZ1 - RIchiZ2) * (RIchiZ1 - RIchiZ2));
	fprintf(fp2, "A,%.1lf,%.1lf,%.1lf\n", RIchiX1, RIchiY1, RIchiZ1);
	fprintf(fp2, "B,%.1lf,%.1lf,%.1lf\n", RIchiX2, RIchiY2, RIchiZ2);

	fprintf(fp2, "伸ばす 左手 を A から B へ\n");
	HKyori = HKyori + sqrt((LIchiX1 - LIchiX2) * (LIchiX1 - LIchiX2) + (LIchiY1 - LIchiY2) * (LIchiY1 - LIchiY2) + (LIchiZ1 - LIchiZ2) * (LIchiZ1 - LIchiZ2));
	fprintf(fp2, "A,%.1lf,%.1lf,%.1lf\n", LIchiX1, LIchiY1, LIchiZ1);
	fprintf(fp2, "B,%.1lf,%.1lf,%.1lf\n\n", LIchiX2, LIchiY2, LIchiZ2);


	//printf("W8\n");
	ZNum = 1;
}

void WGrip(FILE* fp2, int LKoP, int RKoP, int BeforeJigL, int BeforeJigR) {//両手同時に掴み取る

	ZNum = 2;
	fprintf(fp2, "F,%d,%d,%d,%d,%.3lf,%.3lf\n", Num, ZNum, HighNum, Flg, Time, Time);
	Num++;
	HNum++;
	STime = STime + Time;
	fprintf(fp2, "%.3lf,%.3lf,%d,%.3lf\n", SKyori, Skakudo, TurnNum, STime);

	if (BeforeJigL == 0 && BeforeJigR == 0)
	{
		fprintf(fp2, "掴み取る %d を 部品置き場1 から 右手 で 4 により\n", RKoP);

		fprintf(fp2, "掴み取る %d を 部品置き場1 から 左手 で 4 により\n\n", LKoP);
	}
	else if (BeforeJigR == 0)
	{
		fprintf(fp2, "掴み取る %d を 部品置き場1 から 右手 で 4 により\n", RKoP);

		fprintf(fp2, "掴み取る %d を %d から 左手 で 4 により\n\n", LKoP, BeforeJigL);
	}
	else if (BeforeJigL == 0)
	{
		fprintf(fp2, "掴み取る %d を %d から 右手 で 4 により\n", RKoP, BeforeJigR);

		fprintf(fp2, "掴み取る %d を 部品置き場1 から 左手 で 4 により\n\n", LKoP);
	}
	else
	{
		fprintf(fp2, "掴み取る %d を %d から 右手 で 4 により\n", RKoP, BeforeJigR);
		fprintf(fp2, "掴み取る %d を %d から 左手 で 4 により\n\n", LKoP, BeforeJigL);
	}

	//printf("W9\n");
	ZNum = 1;

}

void WCarry(FILE* fp2, double LIchiX1, double LIchiY1, double LIchiZ1, double LIchiX2, double LIchiY2, double LIchiZ2, double RIchiX1, double RIchiY1, double RIchiZ1, double RIchiX2, double RIchiY2, double RIchiZ2) {//両手同時に運ぶ

	ZNum = 2;
	fprintf(fp2, "F,%d,%d,%d,%d,%.3lf,%.3lf\n", Num, ZNum, HighNum, Flg, Time, Time);
	Num++;
	HNum++;
	STime = STime + Time;
	Kyori = sqrt((RIchiX1 - RIchiX2) * (RIchiX1 - RIchiX2) + (RIchiY1 - RIchiY2) * (RIchiY1 - RIchiY2) + (RIchiZ1 - RIchiZ2) * (RIchiZ1 - RIchiZ2)) + sqrt((LIchiX1 - LIchiX2) * (LIchiX1 - LIchiX2) + (LIchiY1 - LIchiY2) * (LIchiY1 - LIchiY2) + (LIchiZ1 - LIchiZ2) * (LIchiZ1 - LIchiZ2));
	SKyori = SKyori + Kyori;
	fprintf(fp2, "%.3lf,%.3lf,%d,%.3lf\n", SKyori, Skakudo, TurnNum, STime);

	fprintf(fp2, "運ぶ 右手 で A から B へ\n");
	MKyori = MKyori + sqrt((RIchiX1 - RIchiX2) * (RIchiX1 - RIchiX2) + (RIchiY1 - RIchiY2) * (RIchiY1 - RIchiY2) + (RIchiZ1 - RIchiZ2) * (RIchiZ1 - RIchiZ2));
	fprintf(fp2, "A,%.1lf,%.1lf,%.1lf\n", RIchiX1, RIchiY1, RIchiZ1);
	fprintf(fp2, "B,%.1lf,%.1lf,%.1lf\n", RIchiX2, RIchiY2, RIchiZ2);

	fprintf(fp2, "運ぶ 左手 で A から B へ\n");
	HKyori = HKyori + sqrt((LIchiX1 - LIchiX2) * (LIchiX1 - LIchiX2) + (LIchiY1 - LIchiY2) * (LIchiY1 - LIchiY2) + (LIchiZ1 - LIchiZ2) * (LIchiZ1 - LIchiZ2));
	fprintf(fp2, "A,%.1lf,%.1lf,%.1lf\n", LIchiX1, LIchiY1, LIchiZ1);
	fprintf(fp2, "B,%.1lf,%.1lf,%.1lf\n\n", LIchiX2, LIchiY2, LIchiZ2);


	//printf("W10\n");
	ZNum = 1;
}

void WKumimove(FILE* fp2, double LIchiX1, double LIchiY1, double LIchiZ1, double LIchiX2, double LIchiY2, double LIchiZ2, double RIchiX1, double RIchiY1, double RIchiZ1, double RIchiX2, double RIchiY2, double RIchiZ2)
{
	ZNum = 2;
	fprintf(fp2, "F,%d,%d,%d,%d,%.3lf,%.3lf\n", Num, ZNum, HighNum, Flg, Time, Time);
	Num++;
	HNum++;
	STime = STime + Time;
	Kyori = sqrt((RIchiX1 - RIchiX2) * (RIchiX1 - RIchiX2) + (RIchiY1 - RIchiY2) * (RIchiY1 - RIchiY2) + (RIchiZ1 - RIchiZ2) * (RIchiZ1 - RIchiZ2)) + sqrt((LIchiX1 - LIchiX2) * (LIchiX1 - LIchiX2) + (LIchiY1 - LIchiY2) * (LIchiY1 - LIchiY2) + (LIchiZ1 - LIchiZ2) * (LIchiZ1 - LIchiZ2));
	SKyori = SKyori + Kyori;
	fprintf(fp2, "%.3lf,%.3lf,%d,%.3lf\n", SKyori, Skakudo, TurnNum, STime);

	fprintf(fp2, "組立移動する 右手 で APP から OFFSET へ\n");
	MKyori = MKyori + sqrt((RIchiX1 - RIchiX2) * (RIchiX1 - RIchiX2) + (RIchiY1 - RIchiY2) * (RIchiY1 - RIchiY2) + (RIchiZ1 - RIchiZ2) * (RIchiZ1 - RIchiZ2));
	fprintf(fp2, "APP,%.1lf,%.1lf,%.1lf\n", RIchiX1, RIchiY1, RIchiZ1);
	fprintf(fp2, "OFFSET,%.1lf,%.1lf,%.1lf\n", RIchiX2, RIchiY2, RIchiZ2);

	fprintf(fp2, "組立移動する 左手 で APP から OFFSET へ\n");
	HKyori = HKyori + sqrt((LIchiX1 - LIchiX2) * (LIchiX1 - LIchiX2) + (LIchiY1 - LIchiY2) * (LIchiY1 - LIchiY2) + (LIchiZ1 - LIchiZ2) * (LIchiZ1 - LIchiZ2));
	fprintf(fp2, "APP,%.1lf,%.1lf,%.1lf\n", LIchiX1, LIchiY1, LIchiZ1);
	fprintf(fp2, "OFFSET,%.1lf,%.1lf,%.1lf\n\n", LIchiX2, LIchiY2, LIchiZ2);

	ZNum = 1;
}

void WTurn(FILE* fp2, int LKoP, double LTurn0X, double LTurn0Y, double LTurn0Z, double LTurn1X, double LTurn1Y, double LTurn1Z, int RKoP, double RTurn0X, double RTurn0Y, double RTurn0Z, double RTurn1X, double RTurn1Y, double RTurn1Z) {//両手同時に回転
	ZNum = 2;
	fprintf(fp2, "F,%d,%d,%d,%d,%.3lf,%.3lf\n", Num, ZNum, HighNum, Flg, Time, Time);
	Skakudo = fabs(RTurn0X - RTurn1X) + Skakudo;
	Skakudo = fabs(RTurn0Y - RTurn1Y) + Skakudo;
	Skakudo = fabs(RTurn0Z - RTurn1Z) + Skakudo;
	Skakudo = fabs(LTurn0X - LTurn1X) + Skakudo;
	Skakudo = fabs(LTurn0Y - LTurn1Y) + Skakudo;
	Skakudo = fabs(LTurn0Z - LTurn1Z) + Skakudo;
	Kaitenkaisu = Kaitenkaisu + 2;
	TurnNum++;
	Num++;
	HNum++;
	STime = STime + Time;
	fprintf(fp2, "%.3lf,%.3lf,%d,%.3lf\n", SKyori, Skakudo, TurnNum, STime);

	fprintf(fp2, "持ち直す %d を 右手 で X から Y へ\n", RKoP);
	fprintf(fp2, "X,%.1lf,%.1lf,%.1lf\n", RTurn0X, RTurn0Y, RTurn0Z);
	fprintf(fp2, "Y,%.1lf,%.1lf,%.1lf\n", RTurn1X, RTurn1Y, RTurn1Z);

	fprintf(fp2, "持ち直す %d を 左手 で X から Y へ\n", LKoP);
	fprintf(fp2, "X,%.1lf,%.1lf,%.1lf\n", LTurn0X, LTurn0Y, LTurn0Z);
	fprintf(fp2, "Y,%.1lf,%.1lf,%.1lf\n\n", LTurn1X, LTurn1Y, LTurn1Z);
	//printf("W3\n");
	ZNum = 1;

}

void WRelease(FILE* fp2, int LKoP, int RKoP) {//両手同時に放す
	ZNum = 2;
	fprintf(fp2, "F,%d,%d,%d,%d,%.3lf,%.3lf\n", Num, ZNum, HighNum, Flg, Time, Time);
	Num++;
	HNum++;
	STime = STime + Time;
	fprintf(fp2, "%.3lf,%.3lf,%d,%.3lf\n", SKyori, Skakudo, TurnNum, STime);

	fprintf(fp2, "放す %d を 右手 で 7 により\n", RKoP);

	fprintf(fp2, "放す %d を 左手 で 7 により\n\n", LKoP);

	//printf("W7\n");
	ZNum = 1;
}

void WFix(FILE* fp2, int LJig, int RJig, int LOyaP, int ROyaP)
{
	ZNum = 2;
	fprintf(fp2, "F,%d,%d,%d,%d,%.3lf,%.3lf\n", Num, ZNum, HighNum, Flg, Time, Time);
	Num++;
	HNum++;
	STime = STime + Time;
	fprintf(fp2, "%.3lf,%.3lf,%d,%.3lf\n", SKyori, Skakudo, TurnNum, STime);
	fprintf(fp2, "付ける %d を %d に 右手 で\n", ROyaP, RJig);
	fprintf(fp2, "付ける %d を %d に 左手 で\n\n", LOyaP, LJig);

	ZNum = 1;
}

void WGripping(FILE* fp2, int LKoP, int RKoP) {//両手同時につかむ

	ZNum = 2;
	fprintf(fp2, "F,%d,%d,%d,%d,%.3lf,%.3lf\n", Num, ZNum, HighNum, Flg, Time, Time);
	Num++;
	HNum++;
	STime = STime + Time;
	fprintf(fp2, "%.3lf,%.3lf,%d,%.3lf\n", SKyori, Skakudo, TurnNum, STime);

	fprintf(fp2, "掴む %d を 右手 で 4 により\n", RKoP);

	fprintf(fp2, "掴む %d を 左手 で 4 により\n\n", LKoP);

	//printf("W9\n");
	ZNum = 1;

}

void Wleave(FILE* fp2, int LKoP, int RKoP) {//両手同時に置き放す
	ZNum = 2;
	fprintf(fp2, "F,%d,%d,%d,%d,%.3lf,%.3lf\n", Num, ZNum, HighNum, Flg, Time, Time);
	Num++;
	HNum++;
	STime = STime + Time;
	fprintf(fp2, "%.3lf,%.3lf,%d,%.3lf\n", SKyori, Skakudo, TurnNum, STime);

	fprintf(fp2, "置き放す %d を 部品置き場-20 に 右手 で 7 により\n", RKoP);

	fprintf(fp2, "置き放す %d を 部品置き場-20 に 左手 で 7 により\n\n", LKoP);

	//printf("W7\n");
	ZNum = 1;
}

void WRemove(FILE* fp2, int LJig, int RJig, int LOyaP, int ROyaP) {//両手で治具から外す
	ZNum = 2;
	fprintf(fp2, "F,%d,%d,%d,%d,%.3lf,%.3lf\n", Num, ZNum, HighNum, Flg, Time, Time);
	Num++;
	HNum++;
	STime = STime + Time;
	fprintf(fp2, "%.3lf,%.3lf,%d,%.3lf\n", SKyori, Skakudo, TurnNum, STime);

	fprintf(fp2, "外す %d を %d から 右手 で\n", ROyaP, RJig);
	fprintf(fp2, "外す %d を %d から 左手 で\n\n", LOyaP, LJig);

	//printf("2\n");
	ZNum = 1;
}

void Tipmove(FILE* fp2, int line, int IchiFlag, int Te) {//先端移動

	int sentan = 0;
	if (NewNOS0 == 0)
	{
		sentan = kumijun[line].kougu;
	}
	else
	{
		sentan = abs(kumijun[line].kougu) % 10 + 1;
	}

	fprintf(fp2, "F,%d,%d,%d,%d,%.3lf\n", Num, ZNum, HighNum, Flg, Time);
	Num++;//有効ステップ数には含まれない
	STime = STime + Time;
	fprintf(fp2, "%.3lf,%.3lf,%d,%.3lf\n", SKyori, Skakudo, TurnNum, STime);
	if (Te == migite) {
		if (IchiFlag == Original_P) {
			fprintf(fp2, "先端を変更する 右手 の位置を 元 に\n\n");
		}
		else {
			fprintf(fp2, "先端を変更する 右手 の位置を 1 に\n\n" );
		}
	}
	else {
		if (IchiFlag == Original_P) {
			fprintf(fp2, "先端を変更する 左手 の位置を 元 に\n\n");
		}
		else {
			fprintf(fp2, "先端を変更する 左手 の位置を 1 に\n\n");
		}
	}
}

void KouguKumi(FILE* fp2, int Jigugu, int Kougu, int Tyuka, int OyaP, int KoP) {//工具を用いた組立
	int f;
	fprintf(fp2, "F,%d,%d,%d,%d,%.3lf\n", Num, ZNum, HighNum, Flg, Time);
	Num++;
	HNum++;
	STime = STime + Time;
	fprintf(fp2, "%.3lf,%.3lf,%d,%.3lf\n", SKyori, Skakudo, TurnNum, STime);

	fprintf(fp2, "組立てる 左手,%d の %d と %d の %d を %d,%d,右手＿左手 で 右手,%d,%d の %d にする\n\n", Jigugu, OyaP, Kougu, KoP, Jigugu, Kougu, Jigugu, Kougu, Tyuka);
}

void Reset() {
	int i = 0, j = 0;
	Okihanashinum = 0;
	putting = 0;
	a = 0;
	//Kumitatenum = 0;
	Tnum = 0;
	Num = 1;
	ZNum = 1;
	HighNum = 0;
	Skakudo = 0;
	Kaitenkaisu = 0;
	TurnNum = 0;
	HNum = 0;
	SKyori = 0;
	STime = 0;
	MKyori = 0;
	HKyori = 0;
	e = 0;
	Oyakaiten = 0;
	Oyakaitenkakudo = 0;

	PreStep = 0;
	boxflag = 0;
	for (i = 0; i < 2 * N + Bboxnum + 1; i++)
	{
		A_Objects[0][i].Id = 0;
		A_Objects[0][i].Flag = 0;
		A_Objects[0][i].IchiX = 0;
		A_Objects[0][i].IchiY = 0;
		A_Objects[0][i].IchiZ = 0;
		A_Objects[0][i].DirX = 0;
		A_Objects[0][i].DirY = 0;
		A_Objects[0][i].DirZ = 0;

		A_Supports[0][i].Id = 0;
		A_Supports[0][i].Flag = 0;
		for (j = 0; j < MaxSupport; j++)
		{
			A_Supports[0][i].PId[0] = 0;
		}
		A_Supports[0][i].Length = 0;
	}
	//B_bigX = 0;
	//B_bigY = 0;
	//B_sitaZ = 0;
	Bboxnum = 0;
	Total_Box = 0;
	JigPartssu = 0;
}


// 読み込んだ文字列の「, 」（カンマ）を「 」（半角スペース）に置き換える関数
void Del_Com(char* s) {
	int	i;
	char a[STR_MAX];
	char* b;//ポインタで宣言

	i = 0;
	while (s[i] != '\0')
	{
		if (s[i] == ',' && s[i + 1] == ',')//もし空白があったら
		{
			strncpy(a, s, i + 1);//空白の前までの文字列をaに移す
			b = s + i + 1;//空白の後ろからのポインタ(文字列)をbに保存
			a[i] = ' ';//カンマの代わりにスペースを入れる
			a[i + 1] = 'N';//空白の代わりに0を入れる
			a[i + 2] = '\0';//文字列の終わりにナル文字を入れる
			strcat(a, b);//aの後ろにbを結合
			strcpy(s, a);//sにaをコピー
		}
		else if (s[i] == ',') s[i] = ' ';
		i++;
	}
}

void GetNowPath(char* NP, char* S) {
	char* p;
	int i;

	p = strrchr(S, '\\');
	// strrchr
	// 文字列の最後から文字を検索する
	// 【引数】
	// const char *s　：　検索対象文字列
	// int c　：　検索文字
	// 【戻り値】
	// 見つかったとき　：　一致文字のアドレス
	// 見つからなかったとき　：　NULL

	for (i = 0; i <= (p - S); i++) {
		NP[i] = S[i];
	}
	NP[i] = '\0'; // 最後にNULLを付加
}

void ShowFinMsg(char* msg) {
	int c;
	printf("%s\n", msg);
	printf("(Enterキーを押してください。)");
	c = getchar();
	exit(1);
}
